<!DOCTYPE html>
<html lang="ru">
<head>
	<title>Демонстрационная программа</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta content="true" name="HandheldFriendly">
	<meta content="width" name="MobileOptimized">
	<meta content="yes" name="apple-mobile-web-app-capable">
	<meta name="description" content="Недокументированные возможности программируемого микрокалькулятора МК-61. Демонстрационная программа">
	<link rel="stylesheet" href="../styles/buttons.css">
	<link rel="stylesheet" href="../styles/tables.css">
	<link rel="stylesheet" href="../styles/other.css">
</head>

<body>
	<header><h1>Демонстрационная программа</h1></header>

	<section id="id_preface">
		<header><h2>Описание интерфейса программы</h2></header>
		<p>
			Для демонстрации используется <strong>модификация</strong> программы
			<q>Пещера сокровищ</q>, из журнала
			<a href="https://zhurnalko.net/=nauka-i-tehnika/tehnika-molodezhi/1987-07--num42" target="_blank">
				Техника Молодёжи №7 за 1987.
			</a>
		</p>
		<p>
			Для тех, кто не желает идти по ссылке, или высматривать шрифт скана,
			опишем игру. Игра представляет собой трёхмерный лабиринт в 3 этажа размером 7 на 4,
			где каждая ячейка на этаже или свободна для прохода, или
			занята – <q>стена</q>. Цель игры – пройти лабиринт, и собрать как можно больше
			сокровищ. Начальная точка входа задаётся игроком, а выход
			в левой нижней точке на третьем	этаже влево.
			Для понимания адресации покажем план 1-го этажа из публикации
			в журнале:
		</p>
		<table>
			<tr>
			<td></td><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th>
			</tr>
			<tr>
			<th>1</th>
			<td>&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td class="wall_color">&emsp;</td>
			</tr>
			<tr>
			<th>2</th>
			<td>&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td>&emsp;</td>
			<td>&emsp;</td>
			<td>&emsp;</td>
			<td>&emsp;</td>
			<td class="wall_color">&emsp;</td>
			</tr>
			<tr>
			<th>4</th>
			<td>&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td>&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td>&emsp;</td>
			<td>&emsp;</td>
			</tr>
			<tr>
			<th>8</th>
			<td class="wall_color">&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td>&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td>&emsp;</td>
			<td class="wall_color">&emsp;</td>
			<td>X</td>
			</tr>
		</table>
		<p>
			Сверху показана нумерация колонок, слева – строк с учётом битовой арифметики.
			Стенки  <span class="wall_color">&emsp;</span> отображены ячейками
			с тёмным цветом. Крестиком, как пример, отображено положение игрока
			в точке 1.0000008. Координаты расшифровываются так:
		</p>
		<ul>
			<li> 1, целая часть числа, это номер этажа.</li>
			<li>
				7, степень дробной части: количество нулей + цифра. Это положение по
				горизонтали или номер колонки.
			</li>
			<li>8, цифра в дробной части. Это положение по вертикали или номер строки.</li>
		</ul>
		<p>
			С учётом этого выход из лабиринта будет влево от точки 3.8.
		</p>
		<p>
			У игрока в наличии ограниченные ресурсы:
		</p>
		<ul>
			<li>
				Еда. В оригинале вода, но так как хранится в регистре Re, то
				удобнее называть еда. Еда тратится при каждом ходе.
			</li>
			<li>
				Динамит или гранаты. Для запоминания хранится в регистре
				Rd или в обозначении ПМК
				<span class="code"> Г.          </span>.
				Динамит используется для пробивания стенок т.&#8239;е. уничтожения
				стенок и освобождение прохода.
			</li>
			<li>
				Сокровища. Хранится, аналогично, в Rc. Цель – набрать как можно
				больше. В этой модификации возможно набрать не меньше десяти
				за одну игру.
			</li>
		</ul>
		<p>
			Для пополнения ресурса выполняется раскопки или поиск. Учтите, что поиск
			может быть безуспешным. Далее такие обнаруженные ресурсы будем
			называть кладами. При этом результат будет зависеть от этажа.
			На 1-м этаже будет еда. За раз +9 единиц, в оригинале +10.
			На 2-м – динамит, за раз +4.
			И только на 3-м только за раз будет одно сокровище.
			Особенность поиска – как только
			нашли клад, то на всех этажах в той же ячейке клад пропадает.
		</p>
		<p>
			Если нашли клад, то появляется разбойник, с которым можно подраться.
			Ставка – новое общее значение ресурса, в зависимости от этажа.
			В результате сумма может как увеличиться, так и уменьшиться.
			Если не хотите рисковать, то от драки можно просто отказаться.
		</p>
		<p>
			Управление игрока – задание команды на движение, или поиск кладов,
			или подрыв стены в последней ячейке, где не удалось пройти. Каждая команда
			расходует еду. Подрыв, понятно, ещё и динамит. Код направления движения
			определяется положением цифр на клавиатуре относительно центра:
			2, 4, 6, 8, &plusmn;5 – вниз, влево, вправо, вверх и выше, ниже этажом.
			Подрыв стены нулём. В оригинале число
			<span class="but_f">F</span><span class="op_f">&pi;</span>, но обычно
			при неудаче прохода выдаёт 0, так что сразу удобнее его
			использовать для команды подрыва.
			Поиск – число 10. В оригинале ноль, но 1/0 как бы намекает
			на найдём или нет.
		</p>
		<p>
			Если движение прошло успешно, то по окончании отображается новая
			координата игрока, в кодировке, как описано выше. Если нет – ноль.
			Выход из лабиринта определяется числом 11, в оригинале трамвай 11-го маршрута.
		</p>
		<p>
			При поиске клада: если не найдено – ноль.
			Если найдено, то показывает новое количество ресурса с учётом найденного,
			а в регистре Y букву типа клада и позицию, где нашли, например:
			<span class="code"> E.00002     </span>.
			При этом, как в оригинале, с разбойником, который защищал клад, можно
			бороться, нажав <span class="but">В&uarr;</span>, или пропустить, нажав
			<span class="but">0</span>. Затем <span class="but_b">С/П</span>.
			Если боремся, то итог может как увеличиться, так и уменьшиться.
		</p>
		<p>
			При успешном подрыве – новое положение игрока, т.&#8239;е. подрыв
			подразумевает сразу ход в новую ячейку. В оригинале для этого приходилось
			делать отдельный ход. При неудаче, когда была попытка подрыва границ лабиринта,
			или последний ход это не движение – ноль.
		</p>
		<p>
			Несколько отличий демонстрационной программы от оригинала уже было сказано,
			но приведём весь список:
		</p>
		<ul>
			<li class="li_change">
				Для подрыва используется два динамита, чтобы компенсировать
				большую прибавку +4. Соответственно и вначале даётся
				не два, а четыре.
			</li>
			<li class="li_change">
				При нехватке динамита вместо ЕГГ0Г отображается
				соответственно отрицательное число, которое обозначает, сколько
				не хватило. Обычно число чётное, но от <q>щедрот</q> разбойника у вас
				могло остаться нечётное число гранат.
				Отсутствие ЕГГ0Г ясно показывает, что игру можно продолжить.
			</li>
			<li class="li_change">
				При нехватке еды вместо ЕГГ0Г программа зацикливается. Это ясно
				показывает, что текущая игра закончилась неудачно.
			</li>
			<li class="li_change">
				Подрыв определяется числом ноль, а не <span class="pi">&pi;</span>.
				Причём игрок сразу делает ход в новую ячейку, а иначе зачем подрыв?
			</li>
			<li class="li_change">
				Поиск определяется числом 10, а не ноль. Кроме буквы типа
				показывается и положение клада на этаже.
				Например, <span class="code"> E.00002     </span>.
				В оригинале только буква.
			</li>
			<li class="li_change">
				Стенки удаляются, а не делается <q>xor</q>. Хотя можно сделать в коде и так,
				поменяв <span class="but_k">К</span><span class="op_k">&or;</span>
				на <span class="but_k">К</span><span class="op_k">&oplus;</span>, но
				ставить новые стенки для затруднения прохода, на мой
				взгляд, нецелесообразно.
			</li>
			<li class="li_add">
				Блокируется неожиданный <q>телепорт</q> из N.0000008 в N.0000001 при
				движении вправо, возникающий в силу  особенности округления. В оригинале
				автор в примере в нескольких местах поставил стенки, чтобы
				это не проявлялось.
			</li>
			<li class="li_add">
				Блокируется подрыв <q>капитальных</q> стен. Это которые по краям лабиринта:
				слева, справа, сверху, снизу, в том числе подвал и крыша.
				В оригинале это можно делать, что приводило к непредсказуемым
				результатам.
			</li>
			<li class="li_add">
				Не портится стек возврата. В оригинале при ЕГГ0Г не отрабатывала
				команда <span class="but_b">В/О</span>, что забивало стек возврата. Хотя
				на работу самой программы это и не сказывалось.
			</li>
			<li class="li_add">
				Начальные значения счётчиков ресурсов заполняются
				автоматически программой. Не требуется вводить перед каждой игрой. Понятно,
				что и <q>начало</q> сделано по-другому.
			</li>
			<li class="li_add">
				И <strong>главное</strong> – ПМК сам (!) генерит как лабиринт, так и
				расположение кладов, причём начальное положении игрока обеспечивается
				<q>не в стенке</q>. В оригинале нужно было самому разработать,
				закодировать и вбить лабиринт при каждой новой игре. Получается, что в
				отличии от оригинала у игрока нет плана лабиринта и кладов.
				С учётом этого начальный объем еды	задаётся вручную, т.&#8239;к.
				план неизвестен и придётся
				многократно упираться в стенки при изучении. Также подрыв стены
				совмещен с ходом на новое место.
			</li>
		</ul>
	</section>

	<hr>

	<section id="id_detail">
		<header><h2>Разбор программы</h2></header>
		<p>
			Полный код программы приведём в конце, а по ходу изложения будем
			приводить фрагменты, изучая трюки и использование недокументированных
			особенностей ПМК, без которых не удалось обойтись, с учётом всех
			улучшений.
		</p>
		<p>
			Сначала общий алгоритм программы. Как в оригинале
			сказано, это демонстрация возможностей ПМК работать с отдельными битами,
			используя шестнадцатеричные числа. Планы этажей и кладов представляются
			битовыми масками. Хватает одного числа на весь этаж. А местоположение
			игрока фактически определяет один бит. Именно он <q>двигается</q>,
			накладываясь на битовые маски, определяя возможность пройти.
			При взятии клада биты в масках удаляются, а при удалении стенок
			устанавливаются.
			Большая часть кода программы – это преобразование хода игрока в
			правильные битовые операции, проверка границ, ресурсов и т.&#8239;п.
		</p>
		<p>
			Распределение регистров частично совпадает с оригиналом.
		</p>
		<ul>
			<li>R0 – план кладов.</li>
			<li>R1&hellip;R3 – план 1&hellip;3 этажей.</li>
			<li>
				R4&hellip;R7 – специальные числовые константы для преобразования
				движения в битовую операцию: 2; 10; 0.1; 0.5. В действительности вместо 0.1
				используется другое	число, но смысл тот же.
				Т.&#8239;е. берётся дробная часть положения игрока, как положение на этаже,
				и производится умножение на указанные величины,
				как бы сдвигая бит вниз (&times; 2), влево (&times; 10),
				вправо (&times; &#8530;) и вверх (&times; &frac12;).
				В оригинале это всё вычисляется программно, но я предпочёл убрать
				в регистры памяти, чтобы освободить большего место для команд.
				Хотя это и привело к дефициту регистров памяти.
			</li>
			<li>
				R8, R9 – содержат вспомогательные константы для адресов перехода
				и др., которые так же не меняются между играми. Детальное значение ниже
				по ходу изложения.
			</li>
			<li>
				Ra – текущее положение игрока в кодировке, указанной в
				описательной части.
			</li>
			<li>
				Rb – точка на плане, куда игрок не смог пройти последний раз,
				уткнувшись в стену. Также этот регистр (всего один!) используется
				как рабочий для всевозможных вычислений, поэтому при <q>не ходах</q>
				там может быть совсем другое значение, но в любом случае
				подрыв стен контролирует и это.
			</li>
			<li>
				Rc, Rd, Re, как было указано выше, используются для хранения ресурсов:
				сокровища, динамит, еда.
			</li>
		</ul>
		<p>
			Начнём с <strong>основной</strong> подпрограммы, которая делает битовую проверку.
			Сначала приведём формализацию её действия. На входе в регистре X
			план этажа для проверки в виде шестнадцатеричной битовой маски.
			В регистре Y тоже шестнадцатеричное число – новое положение игрока.
			После исполнения значение регистра Y (новое положение игрока) безусловно
			запишется в регистр Rb,	чтобы запомнить предполагаемое место, даже если нет прохода.
			При успешной битовой проверке, т.&#8239;е. при совпадении битов,
			проход возможен, и значение из регистра Y (новое положение игрока)
			будет скопировано и в регистры X и Ra, а в регистре Y останется только
			дробная часть, лучше отображающая положение на этаже, потому что
			порядок числа и будет равен номеру колонки.
			Если битовая проверка не успешна, то вернет ноль в регистрах X и Y.
			Посмотрим, как это делается.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;40&#8202;|&#8202;</th>
				<td></td>
				<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but">&larr;&rarr;</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="op_k">max</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">a</span></td>
				<td colspan="2"></td>
			</tr>
		</table>
		<p>
			Если с битовым умножением и копированием Y в Rb всё ясно, то вот
			<span class="but_k">К</span><span class="op_k">max</span> явно использован
			<q>недокументированно</q>. При неудаче ноль из регистра Y будет
			<q>недокументированно</q> скопирован как <q>самое большое число</q> в X.
			Т.&#8239;е. при неудаче будет ноль, что от подпрограммы и требуется.
			А если битовая операция успешная, т.&#8239;е. есть дробная часть, то ничего
			не произойдёт: исходный Y останется в X, а дробная часть,
			которая конечно меньше всего числа, в Y.
			И результат будет скопирован в Ra.
		</p>
		<p>
			Напомню, что в регистре R7 у нас 0.5, а косвенный переход по нему
			при неудаче аналогичен переходу на нулевой адрес,
			где собственно и располагается начало основного цикла программы.
		</p>
		<p>
			На самом деле эта подпрограмма полезна ещё в другом случае. Если
			на входе в одном из регистров X или Y число состоит из одной цифры,
			то эта процедура безусловно из-за логического умножения даст
			на выходе ноль. Эта возможность
			тоже используется в программе, поэтому назовём её также
			процедурой <strong>очистки</strong>.
		</p>
		<p>
			Но внимательный читатель спросит, а где же <span class="but_b">В/О</span>?
			А он&hellip; не нужен!
			Так вот, тут используется побочная ветвь адресного пространства, но
			только не после 105 адреса, а та, которая начинается с адреса B2,
			и заканчивается на адресе F9. А так как адрес F9 совпадает с адресом
			47, то следующим для выполнения будет адрес 00.
			И сама подпрограмма начинается не с адреса 41, а с аналогичного адреса F3.
		</p>
		<p>
			Здесь уже можно раскрыть, что константа в регистре R9, который
			используется для перехода на эту подпрограмму, заканчивается на F3, хотя
			можно чтобы оканчивалась и на ED. Точнее в R9 хранится
			<span class="code"> 4. 3     -08</span>. Зачем вначале идёт 4 и такой порядок будет
			пояснено позднее. Хотя, если читали весь документ, то об этом уже
			упоминалось. Главное, что такой <q>довесок</q> не меняет косвенной
			адресации. Упомяну только, что после <q>использования</q> в
			косвенной адресации значение в R9 станет ненормализованным
			<span class="code"> 0.00004 3-03</span>,
			зато сразу покажет адрес перехода.
		</p>
		<p>
			Давайте, наконец, рассмотрим основной цикл программы, который начинается
			с адреса 00.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_b">С/П</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">e</span></td>
				<td><span class="but">1</span></td>
				<td><span class="but">-</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&lt;0</span></td>
				<td><span class="but">B9</span></td>
				<td><span class="but_b">В/О</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
				<td><span class="but">&lt;-&gt;</span></td>
				<td colspan="1"></td>
			</tr>
		</table>
		<p>
			Как и ожидалось, цикл начинается с остановки, чтобы игрок мог ввести свой ход.
			Затем идёт уменьшение ресурса еды и&hellip; необычный переход.
		</p>
		<p>
			Поясню зачем это. Выше уже упоминалось, что основная процедура выполняется
			по адресам второй побочной ветки, чтобы по окончании автоматически
			<q>завернуть</q> на начало. В этой проверке и делается переход на
			побочную ветвь через адрес B9, который аналогичен адресу 07.
			В этом случае уменьшенное значение еды запоминается, а в регистр X
			возвращается ход игрока. Обращаю внимание, что если
			исключить наш случай, когда регистров просто не хватает, тут всё равно
			делается экономия на команде. Всё-таки
			<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="but">R</span> – это
			две команды, а <span class="but">&larr;&rarr;</span> – только одна.
			Но это конечно при условии, что запомненное значение не понадобится ещё раз.
		</p>
		<p>
			А в случае, если еда кончилась, то идёт переход на команду
			<span class="but_b">В/О</span>, которая, с адреса 01, снова сделает
			ту же проверку с тем же результатом – вот и зациклилась программа
			при нехватке еды.
		</p>
		<p>
			Продолжим. Сначала содержимое Ra (текущее положение игрока)
			заталкивается заранее в регистр Y.
			Зачем это нужно, поясню позднее.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td colspan="9"></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
			</tr>
			<tr>
				<th>&#8202;10&#8202;|&#8202;</th>
				<td><span class="but">&lt;-&gt;</span></td>
				<td colspan="9"></td>
			</tr>
		</table>
		<p>
			Для того чтобы ход игрока 2, 4, 6, 8 преобразовать
			в номер регистра R4, R5, R6, R7, которые содержат коэффициенты для умножения,
			нужно провести несложную операцию: X / 2 + 3. Но для начала неплохо
			бы проверить на ноль, что является ходом для взлома стены.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;10&#8202;|&#8202;</th>
				<td colspan="1"></td>
				<td><span class="but">2</span></td>
				<td><span class="but">&divide;</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
				<td><span class="but">63</span></td>
				<td colspan="5"></td>
			</tr>
		</table>
		<p>
			Вот и проверка команды на взлом стены на ноль. <q>Но позвольте, зачем сначала
			деление, а только потом проверка на ноль?</q> спросите вы. Ответ в том,
			что нам не хватает регистров. Кстати, обратите внимание, что рабочий
			регистр Rb пока не задействован, и взлом будет на его основе. Поэтому ход игрока,
			точнее уже половину &#128522; хода, мы запоминаем в регистре&hellip; X2. Да, да,
			вспомните, ведь проверка условий при успехе запоминает X в X2. А дальше
			посмотрим, как мы это используем:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;10&#8202;|&#8202;</th>
				<td colspan="5"></td>
				<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td><span class="but">ВП</span></td>
				<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
			</tr>
		</table>
		<p>
			Ага, вот и выбор пользователя преобразован в номер регистра для
			коэффициента умножения. Для прояснения, приведу таблицу с возможным выбором
			игрока, при условии, что ноль уже исключили, и то что попало в регистр Rb:
		</p>
		<table class="center">
			<tr>
				<th>Ход игрока</th><th>После &divide; 2</th><th>После + 3</th>
			</tr>
			<tr>
				<th>2</th><td>1</td><td>4</td>
			</tr>
			<tr>
				<th>4</th><td>2</td><td>5</td>
			</tr>
			<tr>
				<th>&plusmn;5</th><td>&plusmn;2.5</td><td>Что-то больше нуля</td>
			</tr>
			<tr>
				<th>6</th><td>3</td><td>6</td>
			</tr>
			<tr>
				<th>8</th><td>4</td><td>7</td>
			</tr>
			<tr>
				<th>10</th><td>5</td><td>8</td>
			</tr>
		</table>
		<p>
			Вариант &plusmn;5 не будет использовать регистр Rb, как мы увидим позднее.
		</p>
		<p>
			Обратите внимание, что мы на самом деле сложили не с тройкой, а с
			числом <span class="pi">&pi;</span>. Почему? Дело в том, что команда
			<span class="but_f">F</span><span class="op_f">&pi;</span> не X2-влияющая,
			к тому же при косвенной адресации дробная часть значения не имеет.
			Вспоминаем – всё это из главы по косвенной адресации.
			Т.&#8239;е. для нас всё равно, будет в Rb число 7 или 7.1415926, при
			<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>
			он всё равно извлечёт 0.5, как значение в R7.
		</p>
		<p>
			А самое главное, это то, что останется после
			команды <span class="but">ВП</span>.
			Вспомним из главы про X2, что сочетание этой команды с предшествующей
			командой сохранения в регистр <q>съест</q> первую цифру числа из X2,
			и восстановит его в X.
			Важно ещё то, что в результате сложения с <span class="pi">&pi;</span> значение в X
			не отрицательное. А что у нас в X2?
			Это значение во второй колонке таблицы выше. Т.&#8239;е. он для всех
			вариантов из таблицы оставит ноль, и
			только от &plusmn;2.5 оставит &plusmn;0.5.
			Вот сколько может сделать одна недокументированная команда!
		</p>
		<p>
			Кстати, в данном случае действие <span class="but">ВП</span>
			очень похоже на команду <span class="but_k">К</span><span class="op_k">{x}</span>,
			которая нам не походит. Потому что, даже если бы мы вместо &pi;
			использовали просто тройку,
			<span class="but_k">К</span><span class="op_k">{x}</span> выполняет
			действия над регистром X, который в случае движения между
			этажами равен 0.5 или 5.5. Оба положительных.
			А <span class="but">ВП</span> использует X2, который помнит
			отрицательное число,
			хотя <q>документально</q> нигде и не хранится.
		</p>
		<p>
			Завершающий <span class="but_k">К</span><span class="op_k">ЗН</span>
			из &plusmn;0.5 делает &plusmn;1 – такой вот трюк вместо умножения
			на два. Ноль при этом остаётся нулём.
			А далее мы оставляем только варианты движения по этажу, с нулём,
			уводя &plusmn;1 в другое место.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;20&#8202;|&#8202;</th>
				<td><span class="but_f">F</span><span class="op_f">x=0</span></td>
				<td><span class="but">EA</span></td>
				<td colspan="8"></td>
			</tr>
		</table>
		<p>
			Напомню, что у нас программа выполняется во второй побочной ветви,
			и <q>странный</q> адрес EA равен 38. Точнее, адресу 38 соответствует
			адрес F0, но такое не ввести, поэтому мы заменяем аналогом – трюк.
			Ладно, займемся этим адресом, когда туда дойдём, а сейчас продолжим
			разбор движения по этажу, но сначала таинственное
			пропускание вперёд:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;20&#8202;|&#8202;</th>
				<td colspan="2"></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">6</span></td>
				<td colspan="7"></td>
			</tr>
		</table>
		<p>
			Так, пришла пора раскрыть, что же находится в регистре R6, которое
			почти 0.1. Там хранится число D.<sup>|&minus;02</sup>:
			<span class="code"> Г.       -02</span>.
			Дело в том, что в операции умножения, если D находится слева в регистре X, то
			оно ведёт себя как число 10. Кто забыл, просмотрите главу про шестнадцатеричную
			арифметику. А для степени &minus;02 получается как 0.1:
			10 &times; 10.<sup>|&minus;2</sup> = 10.<sup>|&minus;1</sup>.
			А когда справа в регистре Y, то	гораздо хитрее.
			Это <q>хитрее</q> нам понадобится позднее, поэтому пока
			загоняем число в стек, чтобы оно было <q>справа</q>. Я мысленно стек
			представляю как X1 – X – Y – Z – T, если кто-то по другому,
			то <q>справа</q> поменяйте на другое.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;20&#8202;|&#8202;</th>
				<td colspan="3"></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but">&times;</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
				<td><span class="but">77</span></td>
				<td colspan="1"></td>
			</tr>
		</table>
		<p>
			Ну вот, наконец-то умножение дробной части числа Ra, как положение на этаже,
			на коэффициент движения. Ещё не забыли, что у нас в Rb?. Тут же проводится
			отсечка варианта поиска клада, когда команда = 10. Дело в том, что в R8,
			на который указывает Rb в варианте 10 / 2 + 3,
			специально записано отрицательное число, а значит поиск уходит на адрес 77.
			Но это не всё.
			Тут мы опять используем регистр X2, через X2-влияющую операцию сравнения.
			Мы сохраняем новое положение игрока на этаже в X2, но не потому что нет
			регистра, а для экономии команд:
			<span class="but_b">x&rarr;П</span><span class="reg">b</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="reg">b</span> это две
			команды, а <span class="but">.</span>, всего одна, а сравнение всё равно
			нужно делать. Именно поэтому сравнение делается не сразу после
			<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>,
			а после умножения, чтобы запомнить в X2 итог.
		</p>
		<p>
			Так, теперь, после получения нового значения на этаже нам нужно проверить,
			что в результате мы не вышли за границы этажа. Изучим такую
			проверку подробнее.
		</p>
		<p>
			Рассмотрим для начала левую границу. Как мы можем за нее попасть? Только
			если перед этим было число M.N (M = 1, 2, 3; N = 1, 2, 4, 8), а затем мы N
			умножили на 10. Понятно, что потом мы <q>дробную</q> часть приплюсуем к
			этажу M. В данном случае она очень даже не дробная, но в результате
			сложения итоговых вариантов не так много, и самое главное, они будут в
			диапазоне 2&hellip;11 и состоять только из одной цифры, кроме 11. А одна
			цифра бинарную конъюнкцию
			<span class="but_k">К</span><span class="op_k">&and;</span>
			<q>не переживёт</q> в процедуре очистки. Вариант с 11, который влево от 3.8 –
			это исключение, поэтому он и выбран как выход из лабиринта.
			Причём будет выполнена операция
			<span class="but">1</span>
			<span class="but">1</span>
			<span class="but_k">К</span><span class="op_k">&and;</span>
			<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>,
			при условии, что Rb = 11. Это обеспечит гарантированный выход.
			Получается даже регистр Rb, а b = 11, кто забыл, выбран неслучайно:
			трюк с подтасовкой регистров!
			В общем, левая граница <q>защитилась</q> автоматически.
		</p>
		<p>
			Правая граница. Там значение дробной части становится порядка 1.<sup>|&minus;08</sup>
			и при сложении с номером этажа просто потеряется, потому что
			точности не хватит на 9 цифр, опять же оставляя только
			одну целую часть, которая будет 1&hellip;3 и конъюнкцию не переживёт.
			Исключение составляет 8.<sup>|&minus;08</sup>, которое округляется
			при сложении до 1.<sup>|&minus;07</sup>, но и его мы победим позднее.
		</p>
		<p>
			Верх и низ. При переходе верхней границы, 1 &times; 0.5, получается число,
			оканчивающиеся на 5, а при переходе нижней, 8 &times; 2, число из двух цифр 16.
			Вот тут нам и пригодится таинственное D.<sup>|&minus;02</sup> из R6. Используя знания
			шестнадцатеричной арифметики можно узнать, что при умножении, а
			D.<sup>|&minus;02</sup> как раз осталось справа, на число 1, 2, 4 или 8 результат будет
			содержать только одну цифру, а на 5 и тем более 16 уже больше.
			Это поясняет последующий код:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;20&#8202;|&#8202;</th>
				<td colspan="9"></td>
				<td><span class="but">&times;</span></td>
			</tr>
			<tr>
				<th>&#8202;30&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but_k">К</span><span class="op_f">x=0</span><span class="but">9</span></td>
				<td colspan="7"></td>
			</tr>
		</table>
		<p>
			Здесь кроме того, что указано, применяется ещё один трюк. После умножения
			будет число с одной или более цифрой.
			Как же вычислить одна или больше? Приходит на помощь операция
			<span class="but_k">К</span><span class="op_k">&or;</span>
			при том, что в регистре Y остался ноль ещё после
			команды <span class="but">ВП</span> по адресу 18. Какой автор
			предусмотрительный, даже давний ноль у него при деле &#128522;.
			В результате будет ровно 8. – всё хорошо и границы не нарушены.
			Или 8.{с чем-то} – плохо, выход за границы. А после
			<span class="but_k">К</span><span class="op_k">{x}</span> либо ноль,
			либо 0.{что-то}. Вот это плохое <q>что-то</q> последняя команда и отправит
			на процедуру очистки. Для очистки важно, чтобы в одном из регистров X
			или Y было число с одной цифрой – ноль в Y
			вполне подходит. Напомню, что в логических бинарных операциях второй
			операнд, ноль в данном случае, не исчезает, но это документировано.
			Продолжим далее.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;30&#8202;|&#8202;</th>
				<td colspan="3"></td>
				<td><span class="but">.</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
				<td><span class="but">-</span></td>
				<td colspan="4"></td>
			</tr>
		</table>
		<p>
			Первое, что мы делаем, это восстанавливаем X2, содержащий новое положение на этаже
			ещё с команды сравнения по адресу 27,
			т.&#8239;к. все команды в промежутке были не X2-влияющие. А потом
			корректируем значение на маленькую величину порядка 4.<sup>|&minus;08</sup>. Это не
			изменит итог ни для кого, кроме 8.<sup>|&minus;08</sup>. В этом случае оно тоже станет
			очень маленьким. Вот где заблокирован <q>телепорт</q> и вот зачем в R9 к
			адресу перехода были добавлены четвёрка вначале и порядок &minus;08.
			Далее проще:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;30&#8202;|&#8202;</th>
				<td colspan="6"></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
			</tr>
			<tr>
				<th>&#8202;40&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td colspan="9"></td>
			</tr>
		</table>
		<p>
			Мы к нашему новому значению на этаже прибавляем номер этажа, это
			целая часть Ra. Заталкиваем новые координаты игрока в Y,
			а в X извлекаем план соответствующего ходу этажа.
			Далее следом идёт переход на основную процедуру, которая
			с адреса 41 = F3, и мы её уже смотрели. Она отбросит все
			нестандартные этажи, где одна цифра в числе, а также случай, когда битовая
			карта этажа просто не совпадёт с положением игрока. Обращаю внимание, что
			косвенной адресацией мы из Rb удалили дробную часть, и в исходном виде
			число осталось только в регистре Y. Но основная процедура запомнит в Rb
			полное значение нового положения. Т.&#8239;е.
			если даже по этажу не пройти, мы запомним точку, куда
			хотели попасть. В случае удачи эта процедура автоматически обновит
			содержимое Ra.
		</p>
		<p>
			Вспомним про адрес перехода 38 = EA, куда мы попадаем при движении между
			этажами. Оказывается – банальный плюс, но с учётом &plusmn;1 и
			заранее, на шаге 09, извлеченного Ra, это <q>то, что доктор прописал</q>: вверх/вниз.
			Так вариант с движением вверх/вниз плавно влился в текущий кусок
			кода: очередной трюк. Тут тоже стоит заострить внимание, как экономятся команды.
			По адресу 09 <q>потрачено</q> две команды, но зато потом идёт просто переход
			на нужный адрес без дополнительных команды. В случае, если бы мы
			выделили это в отдельную ветку исполнения, то после извлечения из Ra
			потребовался бы безусловный переход на тот же плюс. Но в итоге это
			было бы уже три команды, потому что команда <span class="but_b">БП</span> двойная.
		</p>
		<p>
			Сделаем паузу и подведём итоги, что мы изучили до этого.
			Первое – основную процедуру проверки, так же процедуру очистки.
			Второе – начало основного цикла программы с анализом ходов.
			Третье – все ходы движения по этажу, в том числе выход.
			Четвертое – все ходы движения между этажами.
			Осталось три возможности: поиск клада, взлом стены и начальная
			инициализация программы. Вот с неё и продолжим.
		</p>
		<p>
			Как начинается игра, предполагая что глобальные
			константы вбиты, как и сама программа? А вот так: задаётся начальное
			количество еды, затем <span class="but">B&uarr;</span>, чтобы
			это значение попало в регистр Y, а затем начальное положение
			игрока в лабиринте. После чего выполняется команды
			<span class="but_b">БП</span>&ensp;
			<span class="but">44</span>&ensp;
			<span class="but_b">С/П</span>.
			Я рекомендую задавать следующие значения: для еды 44, а для
			положения 1.0000001. Поясню почему. Положение такое является
			максимально удалённым от выхода и набирать его не сложно, как я
			сейчас покажу. А 44 просто удобно для ввода после перехода
			на адрес 44, на случай дребезга числовых клавиш.
			Проще всего так:
			<span class="but_b">БП</span>&ensp;
			<span class="but">44</span>&ensp;
			<span class="but">4</span>&ensp;
			<span class="but">4</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
			<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>&ensp;
			<span class="but_b">С/П</span>.
			Последние две команды перед запуском как раз и выдают значение
			<span class="code"> 1.0000001   </span>.
			Кто-то может подумать, что автор даже это предусмотрел, но нет, это,
			но только это, случайно так совпало.
			Тут же фрагмент начальной инициализации:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;40&#8202;|&#8202;</th>
				<td colspan="4"></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="op_k">max</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">a</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
				<td><span class="but">0</span></td>
			</tr>
			<tr>
				<th>&#8202;50&#8202;|&#8202;</th>
				<td><span class="but_b">x&rarr;П</span><span class="reg">c</span></td>
				<td colspan="9"></td>
			</tr>
		</table>
		<p>
			Положение игрока запоминается в Rb, как бы куда хотим пойти. А потом
			начальное значение еды как-то очень сложно с дополнительными
			ненужными проверками запоминается кроме
			Re зачем-то ещё и в Ra, и обнуляется счётчик сокровищ.
			В данном случае <span class="but_k">К</span><span class="op_k">max</span>
			выступает аналогом <span class="but">&lt;-&gt;</span>, потому что
			начальное значение еды обычно больше, чем номер этажа. Впрочем, если
			вы укажете меньше, то программа разумно даст хоть что-то.
		</p>
		<p>
			<q>Зачем такие сложности?</q> может кто-то спросить, а наиболее
			догадливые уже увидели, что это же код основной процедуры, который
			мы рассмотрели, и использовали совсем для других целей.
			Но здесь мы идём с нормального адреса 44, а значит нестандартного
			перехода на адрес 00 после адреса 47 не будет.
			Да, такой вот необычный трюк, когда
			один и тот же набор команд используется для разных целей в
			разных ветках исполнения. В результате мы <q>бесплатно</q>
			получили две команды для сохранения начального ввода:
			<span class="but_b">x&rarr;П</span><span class="reg">b</span>&ensp;
			<span class="but">&lt;-&gt;</span>.
		</p>
		<p>
			Ладно, поудивлялись и продолжим далее код инициализации.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;50&#8202;|&#8202;</th>
				<td colspan="1"></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">3</span></td>
				<td><span class="but">6</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
				<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
				<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
				<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
				<td><span class="but_f">F</span><span class="op_f">x<sup>y</sup></span></td>
				<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
			</tr>
			<tr>
				<th>&#8202;60&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">8</span></td>
				<td colspan="7"></td>
			</tr>
		</table>
		<p>
			Тут идёт код генерации плана лабиринта и расположения кладов.
			Поясню, как это делается. С помощью датчика случайных чисел
			генерируется число в диапазоне (0..1). Из него с помощью
			стандартных степенных функций получается два случайных числа,
			которые уже содержат все семь знаков мантиссы. Затем результат
			логического сложения этих двух случайных чисел запоминается в нужном регистре.
		</p>
		<p>
			А теперь детали.
			Сначала зануляем R0, который нестандартно в цикле используем для заполнения
			регистров R1&hellip;R3 и R0 (!). Благодаря особенностям
			косвенной адресации при первом обращении
			<span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span>
			ноль превратится
			в &minus;99999999, что соответствует регистру R3, затем в &minus;99999998 – R2,
			и так пока не дойдёт до R0, где &minus;99999996 перепишется новым
			сгенерированным значением, но уже положительным.
			Это и отслеживаем в цикле на шаге 62. Тут уже можно сказать, что в R8
			храниться адрес начала цикла = 52, только со знаком минус.
			Почему минус – читай ранее по вычленению команды поиска клада.
		</p>
		<p>
			Зачем <span class="but_b">П&rarr;x</span><span class="but">3</span>?
			Дело в датчике случайных чисел. Его генерируемое значение очень зависит от содержимого
			регистра Y и частично от X. Чтобы лабиринты отличались от одной игры
			к другой, именно значение регистра R3, как первое сгенерируемое
			случаное значение, и вносится в регистр Y. А в регистре X остаётся шестёрка,
			как начальное значение гранат. Почему 6, а не 4? Так две мы потратим, чтобы
			убрать возможную стенку в точке высадки. Всё-таки лабиринт генерируется
			случайно, и начальное положение игрока может случайно оказаться
			в стенке. Кажется, что инициализацию Rd можно вынести за цикл, но
			испытания показали, что именно такой порядок команд лучше всего сказывается
			на датчике случайных чисел - он не циклиться.
		</p>
		<p>
			<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>
			более равномерно <q>размазывает</q> цифры случайного числа по мантиссе.
			При этом первая	цифра, конечно, получается из очень ограниченного
			диапазона, но для логических операций она не важна.
			<span class="but_f">F</span><span class="op_f">x<sup>y</sup></span>
			делает другое подобное <q>размазывание</q> из случайного числа,
			но эта операция, как документировано, оставляет регистр Y на месте.
		</p>
		<p>
			Любители усложнения вместо
			<span class="but_k">К</span><span class="op_k">&or;</span> могут
			записать команду <span class="but_k">К</span><span class="op_k">&oplus;</span>.
			В этом случае будет больше стенок и меньше кладов.
		</p>
		<p>
			Далее код последовательно переходит в процедуру взлома стены.
			Сначала проверяется наличный запас гранат, с уменьшением.
			Если не хватает, то переход на адрес 00.
			Причём сохранение остатка делается после проверки, чтобы не было
			&minus;2, &minus;4, &minus;6 и т.&#8239;д.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;60&#8202;|&#8202;</th>
				<td colspan="3"></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">d</span></td>
				<td><span class="but">2</span></td>
				<td><span class="but">-</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
				<td colspan="2"></td>
			</tr>
		</table>
		<p>
			Потом код проверки границ и удаление стенки.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;60&#8202;|&#8202;</th>
				<td colspan="8"></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but">4</span></td>
			</tr>
			<tr>
				<th>&#8202;70&#8202;|&#8202;</th>
				<td><span class="but">-</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="but">9</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">9</span></td>
				<td colspan="3"></td>
			</tr>
		</table>
		<p>
			Напомню, что координаты взламываемой стены находятся в Rb. Вначале
			проверяем, что это значение в пределах регистров R1&hellip;R3,
			т.&#8239;е. &lt; 4, причём R0 тоже пройдёт проверку, но это не страшно
			и вот почему.
			На самом деле в Rb число меньше единицы может быть или в виде одной цифры,
			например, хотели с первого этажа 1.0002 пойти вниз и получили 0.0002.
			Или просто ноль – получается при попытке выхода за границы этажа.
			Главное, что число будет из одной цифры, т.&#8239;е. со второго разряда цифр нет,
			а значит в этом случае план этажа извлечётся из плана кладов R0,
			потому что косвенная адресация через Rb будет равна нулю. Да,
			последние две цифры мантиссы будут нулевыми, даже для числа 1.<sup>|&minus;07</sup>,
			что можно посмотреть в главе по косвенной адресации. Затем операция
			<span class="but_k">К</span><span class="op_k">&or;</span> ничего не
			изменит, потому что нет цифр у второго операнда, и вернет обратно
			в R0 значение неизменным. Последующая процедура очистки, с учётом
			того, что второй операнд из одной цифры, поставит <q>0</q> на попытке
			пробить пол в подвал.
		</p>
		<p>

			А если число больше или равно 4, то мы сразу  перейдём на процедуру очистки
			через регистр R9. С учётом работы остальной части программы, это
			можно потом прикинуть, для Rb &ges; 4 число в Rb либо состоит из
			одной цифры, в случае взлома левой стенки, и процедура очистки безусловно
			сработает, либо это <q>крыша</q>, при Rb = 4.{&hellip;}. Но в R4, как это
			я так удачно всё расположил, сам удивляюсь,
			у нас тоже константа из одной цифры,
			а значит процедура очистки тоже сработает.
		</p>
		<p>
			Для R1&hellip;R3 это операция установит бит из Rb в плане этажа.
			В этом случае в X у нас план этажа, в Y точка взлома, которую мы тут
			устанавливаем. В этом случае основная процедура успешно пройдёт битовую
			проверку, потому что мы же только что этот бит поставили, и завершится, записав
			новое расположение в регистре Ra. Т.&#8239;е. мы сразу сделаем ход в новое место.
		</p>
		<p>
			Итак. Инициализация закончена. Игрок в точке высадки, стенки там нет.
			Код начальной инициализации и код взлома стены изучен.
			Остался поиск клада, и разбойник.
			Там тоже не всё так просто.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;70&#8202;|&#8202;</th>
				<td colspan="7"></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
			</tr>
			<tr>
				<th>&#8202;80&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
				<td colspan="8"></td>
			</tr>
		</table>
		<p>
			Путём инверсии бита положения игрока и наложения на маску плана мы
			безусловно очистим этот бит в плане кладов. Кажется странным, что мы сразу
			сохраняем новое значение в R0, даже не проверив, что он там может уже
			отсутствовал. Но последующее
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;80&#8202;|&#8202;</th>
				<td colspan="2"></td>
				<td><span class="but">-</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
				<td colspan="6"></td>
			</tr>
		</table>
		<p>
			проясняет ситуацию. Мы опять пользуемся тем, что логическая операция
			оставляет регистр Y на месте, а именно в нём хранилось исходное значение
			плана кладов. Вот тут и делаем проверку. Заодно убираем безвозвратно
			план кладов из стека, чтобы он случайно не засветился.
		</p>
		<p>
			А теперь приведём код, который из номера этажа получает
			шестнадцатеричную цифру, из соответствия 1 = E, 2 = D, 3 = C.
			В оригинале автор использовал для этого заранее сохранённую
			константу <q>E</q> и цикл с уменьшением её через регистр R0.
			Мы сделаем то же самое без
			использования дополнительных регистров и короче, пользуясь
			недокументированными возможностями.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;80&#8202;|&#8202;</th>
				<td colspan="4"></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
			</tr>
			<tr>
				<th>&#8202;90&#8202;|&#8202;</th>
				<td><span class="but">ВП</span></td>
				<td colspan="9"></td>
			</tr>
		</table>
		<p>
			Тут снова придётся вспомнить раздел про регистр X2 и команду
			<span class="but">ВП</span>, которая восстанавливает его. Сначала с помощью
			сложения с 10, это константа из R5, мы номер этажа
			текущего положения игрока загоняем во второй разряд.
			Тут порядок операндов важен, т.&#8239;к. последний
			<span class="but_b">П&rarr;x</span> и будет содержаться в X2.
			Затем с помощью инверсии и отсеканию целой части, первой цифры,
			мы получим, что нужная буква находится в первом разряде. Но в X вроде
			ещё что-то есть? Так вот, восстановление X2 через
			<span class="but">ВП</span>, сделает так, что
			при восстановлении X2 только первая цифра останется из X, т.&#8239;е. 2.00004
			восстановится в D.00004. То, что нам нужно. Ещё нужно помнить, что перед
			<span class="but">ВП</span> должна быть любая не X2-влияющая команда,
			которая будет выполнена, но результат проигнорирован. Обычно для этих
			целей используется <span class="but_k">К</span><span class="op_k">НОП</span>,
			но мы используем <span class="but_k">К</span><span class="op_k">СЧ</span>. Дело
			в том, что основная процедура может использовать
			<span class="but_k">К</span><span class="op_k">max</span> с нулём в Y, а это
			<q>сбрасывает</q> датчик случайных чисел. Для последующих игр,
			вдруг захочется пройти другой лабиринт, желательно <q>оживить</q> датчик
			случайных чисел. Как говориться <q>с паршивой овцы хоть шерсти клок</q> – даже
			из игнорируемой команды пытаемся получить эффект. Идём далее.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;90&#8202;|&#8202;</th>
				<td></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but">1</span></td>
				<td><span class="but">-</span></td>
				<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_b">С/П</span></td>
				<td></td>
			</tr>
		</table>
		<p>
			Сохраняем полученную букву с дробной частью в Rb и оставляем его в стеке
			для информации игроку. Потом не только извлекаем старое значение ресурса,
			но и заодно отсекаем дробную часть от буквы, при косвенной адресации,
			чтобы потом преобразовать её в нужную добавку.
			Тут нужно пояснить, что именно происходит для вычисления <q>добавки</q>, в
			зависимости от значения регистра X: C, D или E.
			При вычитании срабатывают правила шестнадцатеричной арифметики.
		</p>
		<table class="center">
			<tr>
				<th>X</th>
				<th>После <q>&minus; 1</q></th>
				<th>После x<sup>2</sup></th>
			</tr>
			<tr>
				<th>C</th>
				<td>1</td><td>1 (сокровище)</td>
			</tr>
			<tr>
				<th>D</th>
				<td>2</td><td>4 (динамит)</td>
			</tr>
			<tr>
				<th>E</th>
				<td>3</td><td>9 (еды)</td>
			</tr>
		</table>
		<p>
			Код борьбы с разбойником полностью взят из оригинала. Главное,
			чтобы переключатель Р-ГРД-Г был в положении Р. Окончательное значение
			ресурса сохраняется.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;90&#8202;|&#8202;</th>
				<td colspan="9"></td>
				<td><span class="but_f">F</span><span class="op_f">sin</span></td>
			</tr>
			<tr>
				<th>&#8202;A0&#8202;|&#8202;</th>
				<td><span class="but">1</span></td>
				<td><span class="but">+</span></td>
				<td><span class="but">&times;</span></td>
				<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
				<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td colspan="5"></td>
			</tr>
		</table>
		<p>
			Вот собственно и всё. Конечно далее программа пойдёт по малой побочной
			ветке адресации, как бы с A5 = 00. Но она заканичивается на команде с адресом B1 = 06, а
			в этом диапазоне существующие команды безусловно переведут на другую ветвь.
		</p>
	</section>

	<hr>

	<section id="id_full">
		<header><h2>Полный текст программы</h2></header>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_b">С/П</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">e</span></td>
				<td><span class="but">1</span></td>
				<td><span class="but">-</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&lt;0</span></td>
				<td><span class="but">B9</span></td>
				<td><span class="but_b">В/О</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
				<td><span class="but">&lt;-&gt;</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
			</tr>
			<tr>
				<th>&#8202;10&#8202;|&#8202;</th>
				<td><span class="but">&lt;-&gt;</span></td>
				<td><span class="but">2</span></td>
				<td><span class="but">&divide;</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
				<td><span class="but">63</span></td>
				<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td><span class="but">ВП</span></td>
				<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
			</tr>
			<tr>
				<th>&#8202;20&#8202;|&#8202;</th>
				<td><span class="but_f">F</span><span class="op_f">x=0</span></td>
				<td><span class="but">EA</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">6</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but">&times;</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
				<td><span class="but">77</span></td>
				<td><span class="but">&times;</span></td>
			</tr>
			<tr>
				<th>&#8202;30&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but_k">К</span><span class="op_f">x=0</span><span class="but">9</span></td>
				<td><span class="but">.</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
				<td><span class="but">-</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
			</tr>
			<tr>
				<th>&#8202;40&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but">&lt;-&gt;</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="op_k">max</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">a</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
				<td><span class="but">0</span></td>
			</tr>
			<tr>
				<th>&#8202;50&#8202;|&#8202;</th>
				<td><span class="but_b">x&rarr;П</span><span class="reg">c</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">3</span></td>
				<td><span class="but">6</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
				<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
				<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
				<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
				<td><span class="but_f">F</span><span class="op_f">x<sup>y</sup></span></td>
				<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
			</tr>
			<tr>
				<th>&#8202;60&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">8</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">d</span></td>
				<td><span class="but">2</span></td>
				<td><span class="but">-</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but">4</span></td>
			</tr>
			<tr>
				<th>&#8202;70&#8202;|&#8202;</th>
				<td><span class="but">-</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="but">9</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">9</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
			</tr>
			<tr>
				<th>&#8202;80&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
				<td><span class="but">-</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
			</tr>
			<tr>
				<th>&#8202;90&#8202;|&#8202;</th>
				<td><span class="but">ВП</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
				<td><span class="but">1</span></td>
				<td><span class="but">-</span></td>
				<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_b">С/П</span></td>
				<td><span class="but_f">F</span><span class="op_f">sin</span></td>
			</tr>
			<tr>
				<th>&#8202;A0&#8202;|&#8202;</th>
				<td><span class="but">1</span></td>
				<td><span class="but">+</span></td>
				<td><span class="but">&times;</span></td>
				<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
				<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td colspan="5"></td>
			</tr>
		</table>
		<p>
			Начальные значения констант, которые не меняются между играми:
		</p>
		<ul>
			<li>R4 = 2</li>
			<li>R5 = 10</li>
			<li>R6 = D.<sup>|&minus;02</sup> или
				<span class="code"> Г.       -02</span>
			</li>
			<li>R7 = 0.5</li>
			<li>R8 = &minus;52. С минусом!</li>
			<li>
				R9 = 4.F3<sup>|&minus;08</sup> или
				<span class="code"> 4. 3     -08</span>
			</li>
		</ul>
		<p>
			Вот последовательность для ввода констант:
			<br>
			<span class="but">5</span>&ensp;
			<span class="but">2</span>&ensp;
			<span class="but">/-/</span>&ensp;
			<span class="but_b">x&rarr;П</span><span class="but">8</span>
			<br>
			<span class="but">4</span>&ensp;
			<span class="but">4</span>&ensp;
			<span class="but">7</span>&ensp;
			<span class="but">3</span>&ensp;
			<span class="but">В&uarr;</span>&ensp;
			<span class="but">8</span>&ensp;
			<span class="but">0</span>&ensp;
			<span class="but">8</span>&ensp;
			<span class="but_k">К</span><span class="op_k">&or;</span>&ensp;
			<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
			<span class="but">ВП</span>&ensp;
			<span class="but">7</span>&ensp;
			<span class="but">/-/</span>&ensp;
			<span class="but_b">x&rarr;П</span><span class="but">9</span>
			<br>
			<span class="but">1</span>&ensp;
			<span class="but">0</span>&ensp;
			<span class="but_b">x&rarr;П</span><span class="but">5</span>
			<br>
			<span class="but">2</span>&ensp;
			<span class="but_b">x&rarr;П</span><span class="but">4</span>
			<br>
			<span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
			<span class="but_b">x&rarr;П</span><span class="but">7</span>
			<br>
			<span class="but">2</span>&ensp;
			<span class="but">2</span>&ensp;
			<span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
			<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
			<span class="but">ВП</span>&ensp;
			<span class="but">1</span>&ensp;
			<span class="but_k">К</span><span class="op_k">[x]</span>&ensp;
			<span class="but">ВП</span>&ensp;
			<span class="but">2</span>&ensp;
			<span class="but">/-/</span>&ensp;
			<span class="but_b">x&rarr;П</span><span class="but">6</span>
		</p>
		<p>
			Положение переключателя Р-ГРД-Г должно быть в Р.
		</p>
		<p>
			И напомню порядок начала игры:
			в регистре Y – начальное количество еды, в регистре X
			– начальное положение. Выполнение должно начинаться с адреса 44.
			Проще всего так:
			<span class="but_b">БП</span>&ensp;
			<span class="but">44</span>&ensp;
			<span class="but">4</span>&ensp;
			<span class="but">4</span>&ensp;
			<span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
			<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>&ensp;
			<span class="but_b">С/П</span>.
		</p>
	</section>

	<hr>

	<section id="id_tricks">
		<header>
			<h2>Список трюков и недокументированных особенностей в программе</h2>
		</header>
		которые мы использовали в программе для её сокращения,
		чтобы всё влезло.
		<ul>
			<li>
				Адрес перехода хранится в регистре для сокращения длины команды при
				косвенном обращении. Для R7 это команды по адресам 46, 66, и 83.
				Для R8 – команда по адресу 62.
				Для R9 – команды по адресам 32, 71, 76.
			</li>
			<li>
				Использование константы в двух смыслах. R5 – как коэффициент
				умножения по адресу 26, так и для <q>сдвига</q> во второй разряд
				по адресу 84.
				R7 – тоже как коэффициент умножения, но и как адрес перехода.
				R8 – кроме косвенной адресации используется отрицательным для
				проверки хода поиска клада по адресу 27. R9 – кроме косвенной
				адресации используется для корректировки округления по адресу 34.
			</li>
			<li>
				Цикличность адресного пространства. В процедуре после команды по адресу
				47 нет команды возврата на начало. И последняя команда в
				программе так же не возврат на начало. Сюда же относится необычный трюк по
				использованию одних и тех же команды в разных ветках исполнения.
			</li>
			<li>
				Использование хвоста одной процедуры для другой: основная подпрограмма,
				которая вызывается и из другого места,
				идёт сразу после окончания вычисления нового положения (адрес 41).
			</li>
			<li>
				<q>Слияние</q> окончания одной процедуры с другой для исключения команды
				перехода. В данном случае окончание инициализации и начало
				взлома стены по адресу 63. А также слияние двух веток вычисления,
				этажной и межэтажной, по адресу 38.
			</li>
			<li>
				Регистр X2. Несколько раз. Сохранение по адресу 14, чтобы
				извлечь по адресу 18, уже после того, как значение поучаствовало в
				операции сложения: экономия регистра. Причём с применением не
				X2-влияющей <span class="pi">&pi;</span> вместо тройки. Сохранение по адресу 27 и
				восстановление по адресу 33: экономия одной команды. Сохранение
				по адресу 85 и нестандартное восстановление по адресу 90:
				экономия нескольких команд.
			</li>
			<li>
				Использование ВП. Совмещение восстановления X2 с неявной операцией
				взятия дробной части по адресу 18. Объединение X2 и шестнадцатеричной
				цифры по адресу 90.
			</li>
			<li>
				Использование знаний косвенной адресации. Кроме значений в регистре
				R7&hellip;R9, это <q>игнорирование</q> дробной части после сложения по
				адресам 16 или 38, и умышленное <q>отрубание</q> её по адресу 92.
				А также необычное использование регистра R0 в цикле по адресу 60
				с отрицательным счётчиком.
			</li>
			<li>
				<span class="but_k">К</span><span class="op_k">ЗН</span> как команда
				умножения на 2 по адресу 19.
			</li>
			<li>
				<span class="but_k">К</span><span class="op_k">&or;</span> для
				проверки, что число содержит более одной цифры по адресу 30. Тут
				следует сравнить с оригиналом, где автор для проверки выхода за
				границы верх/низ использовал конъюнкцию квадрата нового положения
				и числа <span class="pi">&pi;</span>, проверяя нулевой бит (and 1) во втором разряде.
				После возведения в квадрат 5² = 25 и 16² = 256 его содержат,
				а 1² = 1, 2² = 4, 4² = 16, 8² = 64 – нет.
				Вроде, это выглядит как альтернатива, вместо команд
				<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
				<span class="but">&times;</span>&ensp;
				<span class="but_k">К</span><span class="op_k">&or;</span>
				использовать
				<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>&ensp;
				<span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
				<span class="but_k">К</span><span class="op_k">&and;</span>,
				благодаря отрезанию первой цифры и тому,
				что биты 2 и 3 у числа <span class="pi">&pi;</span>
				не пересекаются: для 3.14&hellip; это 1 и 4.
				Это даже можно сделать, длина
				программы не изменится, даже R6 можно сделать обычным 0.1.
				Но тут есть подводный камень:
				процедура очистки также запомнит число <q>справа</q> в Rb, а для процедуры
				подрыва и проверки выхода за границу Rb такое количество цифр в числе
				недопустимо, потому что процедура очистки вместо очистки внесёт в Ra что-то
				случайное. Вот так, иногда приходится использовать недокументированные
				возможности для корректности поведения алгоритма
				без увеличения длины программы.
			</li>
			<li>
				Использование шестнадцатеричной арифметики. Содержимое регистра R6
				используется то как 0.1 по адресу 26, то как увеличение количества
				значащих цифр по адресу 29. Операция вычитания по адресу 95 приводит
				цифры C, D, E к более удобным 1, 2, 3.
			</li>
			<li>
				Использование <span class="but_k">К</span><span class="op_k">max</span>
				в нестандартном случае для <q>просвечивания</q> нуля из Y по адресу 45.
				А также как замена команде <span class="but">&lt;-&gt;</span>.
			</li>
		</ul>
	</section>

	<footer>
		<a href="../Недокументированные%20возможности%20ПМК%20МК-61.html">К оглавлению</a>
	</footer>

</body>
</html>