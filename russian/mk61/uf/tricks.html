<!DOCTYPE html>
<html lang="ru">
<head>
	<title>Трюки по оптимизации</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta content="true" name="HandheldFriendly">
	<meta content="width" name="MobileOptimized">
	<meta content="yes" name="apple-mobile-web-app-capable">
	<meta name="description" content="Недокументированные возможности программируемого микрокалькулятора МК-61. Трюки по оптимизации.">
	<link rel="stylesheet" href="../styles/buttons.css">
	<link rel="stylesheet" href="../styles/tables.css">
	<link rel="stylesheet" href="../styles/other.css">
</head>

<body>
	<section>
		<header><h1>Трюки по оптимизации</h1></header>
		<p>
			Здесь рассмотрены некоторые способы, которые позволяют оптимизировать
			программу. Большинство трюков – это использование документированных
			возможностей, но возможно необычным образом.
			Ясно, что все варианты не рассмотреть, а лишь несколько для
			демонстрации, как нужно нестандартно подходить к вопросу оптимизации.
		</p>
		<ol>
			<li>
				<strong>Косвенная адресация вместо прямой.</strong> Это очевидное решение,
				т.&#8239;к. (без)условный переход (или вызов подпрограммы) занимает две
				команды, а то же самое с косвенной адресацией – только одну. Чем
				больше таких вызовов, тем выгоднее.
				<p></p>
			</li>
			<li>
				<strong>Правильный порядок в стеке.</strong> Это так же
				очевидное решение, при
				котором порядок вычисления меняют так, чтобы операнды по максимуму
				использовали стек (а не регистры памяти), и при этом располагались в
				порядке последующего вычисления. Или ещё – использование стека
				вычислений для дублирования числа. Пусть некое число нужно многократно
				использовать в вычислениях. Чтобы не вызывать его несколько раз из
				регистра памяти (а может даже и не сохранять), используется следующая
				методика: число вычисляют раньше, чем положено, затем после него
				делаются другие вычисления, но так, чтобы наше число <q>дошло</q> до
				регистра T. Затем другие вычисления завершаются, а регистры стека
				Y&hellip;T остаются заполнены нашим числом (причём и далее будут им
				заполняться). Экономия в командах на вызов из регистра.
				<p></p>
			</li>
			<li>
				<strong>Использования побочной ветви адресного пространства</strong> для
				сокращения программы. Эти способы уже были рассмотрены ранее в
				разделе по <a href="addr_space.html">адресному пространству</a>.
				<p></p>
			</li>
			<li>
				<strong>Замена <span class="but_b">БП</span>&ensp;
				<span class="but">01</span> на <span class="but_b">В/О</span>.</strong>
				Это работает, только если стек возврата адресов пустой (нулевой).
				См. в <a href="commands.html">приложении</a> комментарий по команде
				<span class="but_b">В/О</span>.
				<p>
					На самом деле с механизмом возврата
					на адрес 01 через <span class="but_b">В/О</span> используются много разных
					способов оптимизации. Вот пример: программа состоит из кода начальное подготовки
					HEAD, основного цикла MAIN, который начинается с вызова попрограммы
					SUB (она даже потом вызывается несколько раз, иначе зачем делать
					подпрограммой). А в конце цикла делается возрат на начало
					(<span class="but_b">Б/П</span>&ensp;<span class="but">00</span> или
					аналогичное). Так вот, оптимизация состоит в том, что программа
					выстраивается в таком порядке:
					по адресу 00
					<span class="but_k">К</span><span class="but_b">БП</span><span class="reg">R</span>
					(R – содержит некий адрес, с которого фактически начинается HEAD),
					затем тело SUB без вызова через <span class="but_b">ПП</span> (!).
					По окончании процедуры пройдет возврат на адрес 01 по команде
					<span class="but_b">В/О</span>, с которого
					продолжиться тело MAIN до адреса в регистре R, т.е. до начала цикла.
					Где экономия? Почти всё то же, но нет одного вызова <span class="but_b">ПП</span>,
					а это одна (для косвенного) или две команды.
					</p>
				<p></p>
			</li>
			<li>
				<strong>Совмещение адреса перехода и команды.</strong> В этом случае адрес
				перехода для двойных команд (чаще всего <span class="but_b">БП</span>)
				используется одновременно и как обычная команда для другой
				последовательности. Очевидно, что требуется знание кодов операций.
				Благодаря наличию побочных ветвей адресации или её неоднозначности можно
				<q>подогнать</q> адрес под нужную команду. Например, последовательность
				<span class="but_b">БП</span>&ensp;
				<span class="but">53</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="reg">d</span>
				можно заменить на
				<span class="but_b">БП</span>&ensp;
				<span class="but">4D</span>,
				т.&#8239;к. адрес 4D = 53, а 4D = это
				<span class="but_b">x&rarr;П</span><span class="reg">d</span>.
				<p>
					Иногда ради такой <q>подгонки</q> делают перестроение программы:
					перемешивание независимых кусков программы, располагая их по
					разным адресам. Сюда же относится пример из журнала
					<a href="https://zhurnalko.net/=nauka-i-tehnika/tehnika-molodezhi/1985-09--num50" target="_blank">
						ТМ №9 за 1985:
					</a>
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;60&#8202;|&#8202;</th>
						<td><span class="but_f">F</span><span class="op_f">x&lt;0</span></td>
						<td><span class="but">61</span></td>
						<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
						<td><span class="but">63</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="5"></td>
					</tr>
				</table>
				Когда перед остановкой выводилось содержимое нужного регистра при
				проверке условия. Экономия на том, что адрес перехода совпадает с
				командой извлечения из регистра.
				<p></p>
			</li>
			<li>
				<strong>Удаление условных операторов.</strong> Речь идёт о замене условных
				операторов, которые обычно двойные, на простую арифметику.
				<p>
					Пусть есть часть программы, где при X &ne; 0 нужно к регистру R9
					добавить единицу (некий счётчик). Решение в лоб:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
						<td><span class="but">06</span></td>
						<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but">+</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td colspan="4"></td>
					</tr>
				</table>
				<p>
					Решение с удалением условия:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
						<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td><span class="but">+</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td colspan="6"></td>
					</tr>
				</table>
				<p>
					В случае, если X может быть и отрицательным, будет чуть длиннее, но
					всё равно короче прямого решения:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
						<td><span class="but_k">К</span><span class="op_k">&mid;x&mid;</span></td>
						<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td><span class="but">+</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td colspan="5"></td>
					</tr>
				</table>
				<p></p>
			</li>
			<li>
				<strong>Нестандартное использование циклов FLx.</strong>
				<ul>
					<li>
						Знание того, что цикл по завершении оставит единицу, позволяет
						не инициализировать его при повторном заходе.
					</li>
					<li>
						Быстрая проверка на единицу содержимого регистров R0&hellip;R3 с
						переходом при невыполнении. Иногда для этой возможности
						переставляют регистры, т.&#8239;е. специально используется R0&hellip;R3
						вместо других для такой возможности.
					</li>
					<li>
						Выполнение операций, не имеющих отношение к циклу. Например,
						нужно в конце некой подпрограммы уменьшить счётчик попыток в
						регистре R2 и перейти на адрес (пусть 77). Вместо
						<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
						<span class="but_b">БП</span>&ensp;
						<span class="but">77</span>
						которое, кстати, портит стек (и для исправления может
						потребоваться ещё команда), сделать:
						<span class="but_f">F</span><span class="op_f">L2</span>&ensp;
						<span class="but">77</span>.
						Разумеется, счётчик должен не кончаться или сразу после этого кода
						идёт проверка по его окончанию. При этом для <q>бесконечности</q>
						счётчика иногда делают его отрицательным, если в конце вычислений важна
						только разница между началом и концом.
					</li>
				</ul>
				<p></p>
			</li>
			<li>
				<strong>Проверка на больше/меньше единицы.</strong> Если известно, что число
				не отрицательное, то вместо отнимания единицы и проверки на
				больше/меньше нуля можно сразу взять
				<span class="but_f">F</span><span class="op_f">lg</span> и проверить на
				больше/меньше нуля.
				<p></p>
			</li>
			<li>
				<strong>Остановка по ошибке при условии.</strong> Вот несколько способов
				сгенерировать ошибку и сделать остановку без проверки условия:
				<ul>
					<li>
						Если ноль – <span class="but_f">F</span><span class="op_f">1/x</span>
					</li>
					<li>
						Если меньше или равно нулю –
						<span class="but_f">F</span><span class="op_f">lg</span>
					</li>
					<li>
						Если меньше нуля –
						<span class="but_f">F</span><span class="op_f">&radic;</span>
					</li>
					<li>
						Если больше единицы –
						<span class="but_f">F</span><span class="op_f">cos<sup>-1</sup></span> или
						<span class="but_f">F</span><span class="op_f">sin<sup>-1</sup></span>
					</li>
					<li>
						Если больше или равно 100 –
						<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>
					</li>
					<li>
						Если дробная часть больше или равно 0.6 –
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
					</li>
				</ul>
				<p></p>
			</li>
			<li>
				<strong>Вызов части подпрограммы.</strong> Пример, пусть есть некий алгоритм,
				который особым образом обрабатывает число, но только целое или
				дробное отдельно. А нужно сделать её более универсальной, т.&#8239;е. для
				любого числа. Можно сделать так:
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
						<td><span class="but">0</span></td>
						<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
						<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
						<td><span class="but_b">ПП</span></td>
						<td><span class="but">07</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td colspan="3"></td>
					</tr>
					<tr><td colspan="11">&hellip;</td></tr>
					<tr>
						<th>&#8202;30&#8202;|&#8202;</th>
						<td><span class="but">+</span></td>
						<td><span class="but_b">В/О</span></td>
						<td colspan="8"></td>
					</tr>
				</table>
				Что здесь происходит? Сначала подготавливается на будущее дробная
				часть, затем заталкивается ноль и оставляется целая часть.
				Далее вызывается часть кода (часть кода текущей подпрограммы),
				которая делает обработку над целой частью, а в конце делает сложение
				(с нулём, в данном случае). Затем целая и дробная часть меняются
				местами и код повторяется, причём в конце сложение уже делает
				объединение, а затем возврат. Где экономия? Если бы мы вызывали
				обрабатываемую часть по очереди, то нам всё равно потребовалось бы
				разделять на целую и дробную часть, обрабатывать по очереди, а затем
				объединять сложением. Для этого потребовались бы всё те же команды,
				кроме <span class="but">0</span>. Но при это пришлось бы делать дважды
				<span class="but_b">ПП</span>, а это две команды. Заменив на одну команду
				<span class="but">0</span> и вызвав свой <q>хвост</q>, мы сэкономили одну команду.
				<p></p>
			</li>
			<li>
				<strong>Совмещение констант и адресов перехода.</strong> В данном
				случае речь
				идёт о том, что некоторая константа, используемая для вычислений,
				одновременно содержит и адрес перехода. Иногда это делают
				искусственно, перемещая программу под значение константы, а иногда
				удаётся совместить. Пример из практики автора – для битового
				положения игрока использовался формат N.0000H, где N – некий <q>этаж</q>,
				H – бит (число 1, 2, 4 или 8), а количество нулей в дробной части
				определяет положение на <q>этаже</q>. Движение по <q>этажу</q> выполнялось над
				дробной частью, путём умножения/деления на два (биты) и путем
				умножения/деления десять (влево/вправо на этаже). Подводный камень –
				в автоматическом округлении ПМК, возникающим при сложении чисел
				разных порядков. В данном случае при дробной части =
				0.000000H (H.<sup>|&minus;07</sup>) и делении на 10 получается число <q>вне этажа</q>,
				H.<sup>|&minus;08</sup>, которое должно обнулиться. Для H = 1, 2, 4 при сложении с
				целым так и есть, но если H = 8, то происходит исключение: в
				результате округления 8.<sup>|&minus;08</sup> превращается
				в 1.<sup>|&minus;07</sup> (неожиданный
				телепорт). Чтобы программа вела себя корректно, необходимо перед
				сложением от полученного числа отнять некое значение в диапазоне
				3.<sup>|&minus;08</sup> &les; X &lt; 5.<sup>|&minus;08</sup>, тогда это не испортит случая
				H = 1, 2, 4, и сделает число с H = 8 обнуляемым при округлении.
				Так вот, используя знание
				<a href="indirect_addr.html">косвенной адресации</a> можно к
				3.<sup>|&minus;08</sup> (или 4.<sup>|&minus;08</sup>) добавить пару цифр.
				Это на исправление округления
				не скажется, но позволит использовать эти цифры как адрес перехода.
				Пусть нужна косвенная адресация с адресом 77, тогда константа будет
				3.77<sup>|&minus;08</sup>. А если учесть, что при косвенной адресации оно будет
				ненормализовано, то оно же использовалось для видеоизображения особой
				ситуации: <span class="code"> 0.0000377-03</span>.
			</li>
		</ol>
	</section>

	<footer>
		<a href="../Недокументированные%20возможности%20ПМК%20МК-61.html">К оглавлению</a>
	</footer>

</body>
</html>