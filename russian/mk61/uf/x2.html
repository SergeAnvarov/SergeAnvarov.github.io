<!DOCTYPE html>
<html lang="ru">
<head>
	<title>Таинственный регистр X2</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta content="true" name="HandheldFriendly">
	<meta content="width" name="MobileOptimized">
	<meta content="yes" name="apple-mobile-web-app-capable">
	<meta name="description" content="Недокументированные возможности программируемого микрокалькулятора МК-61. Таинственный регистр X2">
	<link rel="stylesheet" href="../styles/buttons.css">
	<link rel="stylesheet" href="../styles/tables.css">
	<link rel="stylesheet" href="../styles/other.css">
</head>

<body>
	<section>
		<header><h1>Таинственный регистр X2</h1></header>
		<p>
			Такой регистр действительно не упоминается в документации. В
			действительности этот тот регистр, содержимое которого отображается на
			дисплее при остановке ПМК. Поэтому его иногда называют <em>экранным</em> регистром.
		</p>
		<p>
			В документации указано, что таковым является регистр X, но это не так.
			В режиме вычислений после каждой команды содержимое регистра X2 (экрана)
			сразу же копируется в X. И поэтому разницы между ними нет.
			При таком копировании производятся дополнительные проверки,
			например, на предмет переполнения.
			В целях экономии в программном режиме при выполнении
			большинства (!) команд такое копировании не производится, точнее
			результат их исполнения напрямую пишется в регистр X, не затрагивая X2,
			как в режиме вычислений.
			Более того, а это и есть самое полезное, некоторые команды
			при выполнении используют только X2, игнорируя текущий X, как бы
			восстанавливая старое значение.
		</p>
	</section>

	<hr>

	<section id="id_affect">
		<header><h2>X2-влияющие команды</h2></header>
		<p>
			Для начала опишем список команд, которые результат своего выполнения
			записывают напрямую в X2, а только потом копируют его в X. Назовём такие команды
			<dfn>X2-влияющие</dfn>.
			<strong>Безусловно</strong> это делают следующие команды:
		</p>
		<ul>
			<li>
				Ввод числа, после ввода каждой цифры, в том числе разделителя
				<span class="but">.</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but">ВП</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but">/-/</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_cx">Сx</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but">В&uarr;</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">Вx</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_b">В/О</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_b">П&rarr;x</span><span class="but">R</span> (R = 0&hellip;F)
			</li>
			<li style="padding: 3px 0">
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>
				(R = 0&hellip;F)
			</li>
			<li style="padding: 3px 0">
				пустые операторы с кодами F0&hellip;FF
			</li>
			<li style="padding: 3px 0">
				все команды, генерирующие ошибку, в силу перехода в режим вычислений,
				например,
				27(<span class="but_k">К</span><span class="but">&minus;</span>),
				28(<span class="but_k">К</span><span class="but">&times;</span>),
				29(<span class="but_k">К</span><span class="but">&divide;</span>),
				2B&hellip;2E, 3C и стандартные операции при генерации ошибок.
			</li>
		</ul>
		<p>
			Команда <span class="but_b">С/П</span> выполняют копирование
			только при остановке. Но не при запуске программы.
		</p>
		<p>
			Выполняют копирование (в данном случае X &rarr; X2)
			только <strong>при НЕ переходе на адрес</strong>
			следующие команды:
		</p>
		<ul>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">x&lt;0</span>,
				но команда <span class="but_k">К</span><span class="op_f">x&lt;0</span>
				не влияет на X2
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">x=0</span>, но команда
				<span class="but_k">К</span><span class="op_f">x=0</span>
				не влияет на X2
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">x&ge;0</span>, но команда
				<span class="but_k">К</span><span class="op_f">x&ge;0</span>
				не влияет на X2
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">x&ne;0</span>, но команда
				<span class="but_k">К</span><span class="op_f">x&ne;0</span>
				не влияет на X2
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">L0</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">L1</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">L2</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">L3</span>
			</li>
		</ul>
		<p>
			Для условных операторов это означает, что копирование X&rarr;X2
			производится, когда условие выполняется. Для циклов – когда
			цикл завершается.
		</p>
		<p>
			Остальные операторы НЕ копируют результат в X2. А это,
			например, означает, что	регистр X во время таких операций может содержать
			<a href="glossary.html#id_super_num">сверхчисло</a>.
			При этом, конечно, нужно учитывать, чтобы команда сам по себе не делала
			такую проверку на переполнение.
			Например,
			<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span> делает
			проверку параметра перед выполнением, а
			<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
			– нет.
		</p>
		<p>
			Для пояснения работы условных операторов рассмотрим такую программу:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
				<td><span class="but">5</span></td>
				<td><span class="but">0</span></td>
				<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
				<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
				<td><span class="but_f">F</span><span class="op_f">x=0</span></td>
				<td><span class="but">07</span></td>
				<td><span class="but_cx">Cx</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="1"></td>
			</tr>
		</table>
		<p>
			Можно увидеть, что на шаге 04 в регистре X возникает сверхчисло.
			Причём оператор
			<span class="but_f">F</span><span class="op_f">x=0</span>
			не выполняется, т.&#8239;е. идёт переход на адрес 07, как адрес перехода.
			В соответствии с таблицей выше, в этом случае копирование X в X2
			не происходит, а значит, ошибки не должно возникать.
			В чем легко убедиться, запустив программ.
			Но если в программе заменить оператор на
			<span class="but_f">F</span><span class="op_f">x&ne;0</span>,
			то условие уже будет выполняться, и будет выполняться копирование
			X в X2, которое приведёт к ошибке.
			Что так же проверяется запуском программы.
		</p>
		<p>
			Хочу отметить, что команда <span class="but_b">В/О</span> также
			является X2-влияющей, т.&#8239;е. если перед возвратом из подпрограммы
			в регистре X будет сверхчисло, то произойдёт остановка по ошибке,
			причём возврат успеет отработать, т.&#8239;е. остановка будет на адресе
			сразу после вызова подпрограммы. Возможно это связано с тем, что
			микропрограмма вычисления адреса возврата использует X2 для вычислений,
			а затем восстанавливает X2 из X.
		</p>
		<p>
			Работая в режиме вычислений кажется, что ненормализованные числа,
			у которых есть ведущие нули, образующиеся, например,
			при косвенной адресации, автоматически
			нормализуется при выполнении любой следующей команды.
			Так вот, в программном режиме это не так.
			Фактически, <dfn>когда команда является X2-влияющей,
			то после выполнения X2 копируется в X, и в этот момент X нормализуются,
			заодно проверяется на переполнение</dfn>.
			А не X2-влияющие команды так не делают: не выполняют нормализацию, не
			проверяют переполнения, не копируют X в X2.
			Именно поэтому они работают немного быстрее. Приблизительное
			время выполнения команд см. <a href="commands.html#id_times">в приложении</a>.
		</p>
		<p>
			В режиме вычислений можно считать все команды X2-влияющие.
			Это значит, что если вы извлекли ненормализованное
			число, то в регистре X2, т.&#8239;е. на экране, оно с ведущими нулями, а вот
			в регистре X уже без них!
			Для доказательства возьмём простенькую программу:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
				<td><span class="but">ВП</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="7"></td>
			</tr>
		</table>
		<p>
			Если ввести 001, то в X2 будет 001, а в X уже 1. И после нажатия
			<span class="but_b">С/П</span> именно эта нормализованная
			единица подставится	в итог: <span class="code"> 101.        </span>.
			Почему вообще так, рассмотрим в других разделах подробнее.
		</p>
		<p>
			Несмотря на это, регистр X2 при остановке не нормализуется.
			Вообще говоря, он специально вообще никогда не нормализуется.
			Вот пример, при условии, что переключатель Р-ГРД-Г не в положении Р.
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_cx">Cx</span></td>
				<td><span class="but_f">F</span><span class="op_f">sin<sup>-1</sup></span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">1</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="6"></td>
			</tr>
		</table>
		<p>
			Тут ненормализованное число 00 получается не X2-влияющей командой,
			чтобы в X оставаться ненормализованным. Сохраняется и
			остаётся как в R1, так и в X2 (на экране) в ненормализованном виде, потому
			что оператор <span class="but_b">С/П</span> при остановке копирует
			его в X2. Но регистр X уже будет нормализован.
			Например, нейтральное <span class="but_f">F</span><span class="op_f">АВТ</span>
			скопирует X в X2 и вы увидим простой ноль.
			Чуть удлиним программу:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_cx">Cx</span></td>
				<td><span class="but_f">F</span><span class="op_f">sin<sup>-1</sup></span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">1</span></td>
				<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="5"></td>
			</tr>
		</table>
		<p>
			Теперь на экране мы увидим &pi;. Но в Y и в X1 останется ненормализованное 00.
			Чтобы увидеть его, можно ещё чуть удлинить программу:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_cx">Cx</span></td>
				<td><span class="but_f">F</span><span class="op_f">sin<sup>-1</sup></span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">1</span></td>
				<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
				<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
				<td><span class="but">ВП</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="3"></td>
			</tr>
		</table>
		<p>
			Тут у ненормализованного 00 после извлечения из X1, с помощью
			<span class="but">ВП</span> первая цифра заменится на 1 и получится 10.
			Получается, что нормализуется только регистр X.
		</p>
		<p>
			На всякий случай ещё раз напомним, как действуют X2-влияющие команды. Они результат
			своего выполнения, возможно ненормализованный, копируют в X2. А затем X2 копируется
			в X, но уже с нормализацией. Для примера возьмём <span class="but">В&uarr;</span>.
			Она сначала сдвигает стек, копирую X в Y, возможно ненормализованное. Затем результат,
			который в данном случае X или Y, копирует в X2, тоже, возможно, ненормализованное, а
			затем из X2 в X, но уже с нормализацией. Пример, при условии что Р-ГРД-Г не в положении Р:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_cx">Cx</span></td>
				<td><span class="but_f">F</span><span class="op_f">sin<sup>-1</sup></span></td>
				<td><span class="but">В&uarr;</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">1</span></td>
				<td><span class="but">&lt;-&gt;</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">2</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="4"></td>
			</tr>
		</table>
		<p>
			Ненормализованное <span class="code"> 00.         </span> копируется в Y,
			а позднее в R2, а вот полученный X в R1. Результат можно проверить по
			содержимому регистров по окончании: R1 = 0, R2 = 00.
		</p>
		<p>
			Аналогично <span class="but_b">П&rarr;x</span><span class="but">R</span>,
			при ненормализованном значение в R, скопирует его в таком виде
			только в X2 (на экран), но в X уже будет нормализованное. Проверяется
			аналогичным образом.
		</p>
	</section>

	<hr>

	<section id="id_restore">
		<header><h2>X2-восстанавливающие</h2></header>
		<p>
			Некоторые команды игнорируют регистр X и для вычислений используют
			напрямую X2, т.&#8239;е. делают как бы обратное копирование X2&rarr;X.
			Именно их мы и рассмотрим.
		</p>
		<p>
			А причиной нестандартного поведения этих команд
			является то, что подпрограммы ввода числа в ПМК, в том числе его порядка,
			работают напрямую с регистром X2, иногда нестандартно. А только потом,
			как X2-влияющие, копируют его обратно в X. Именно поэтому, они, фактически,
			игнорируют текущее значение в X.
		</p>
		<ul>
			<li>
				Команда	<span class="but">.</span> проверяет, что разделитель не введён
				повторно.
			</li>
			<li>
				Команда <span class="but">ВП</span> проверяет, что
				значение не нулевое. А в случае нуля первый разряд <q>подправляет</q>.
				В программном режиме получаются разнообразные способы вычисления
				этого разряда в зависимости от истории команд.
			</li>
			<li>
				Команда <span class="but">/-/</span> после
				<span class="but">ВП</span> готовится считать суммарный
				порядок.
			</li>
			<li>
				Команды ввода числа (цифры). Да, они тоже вводят напрямую в X2.
			</li>
		</ul>
		<p>
			Чтобы выделить эти команды, назовём их <dfn>X2-восстанавливающими</dfn>.
			Они модифицируют X2, возможно нестандартным способом, а
			потом копируют X2&rarr;X.
		</p>
		<p>
			Ещё. Т.&#8239;к. эти команды также X2-влияющие, то число в X
			всегда нормализованное, даже если X2 не нормализованное.
		</p>
		<p>
			Ввод цифр не будет рассматривать отдельно. Обычно в этом нет ничего особенного,
			потому что поведение ожидаемое. На всякий случай продемонстрируем, что они
			работают напрямую с X2:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
				<td><span class="but">0</span></td>
				<td><span class="but">0</span></td>
				<td><span class="but">0</span></td>
				<td><span class="but">ВП</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="4"></td>
			</tr>
		</table>
		<p>
			Тут в результате будет 100, потому что X2 не нормализуются и
			цифры поочерёдно добавляются в него, а финальный <span class="but">ВП</span>
			исправит первую цифру на 1.
		</p>
	</section>

	<hr>

	<section id="id_point">
		<header><h2>Команда <span class="but">.</span> (код 0A)</h2></header>
		<p>
			Данная команда в программном режиме восстанавливает в регистре X
			значение X2 как есть, за исключением случая, когда идёт обычный ввод числа,
			например, 1.23, в этом случае поведение полностью соответствует
			документации и эквивалентно режиму вычислений. При этом содержимое
			стека не меняется. Также команда ничего не делает после X2-влияющей
			команды. Точнее, она восстанавливает то, что было только что введено,
			по факту ничего не делает.
			На практике команду <span class="but">.</span> чаще всего используют
			для экономии регистров,
			реже – когда требуется ввод без изменения стека.
			<br>
			Пример: проверка битового флага и если его нет, то его установка.
			Пусть в R9 хранится некое число для работы с битами, а в R1 хранится бит
			для проверки, тогда следующий фрагмент сначала сделает проверку
			доступности бита, а при недоступности, сделает его установку:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">1</span></td>
				<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
				<td><span class="but">77</span></td>
				<td colspan="4"></td>
			</tr>
			<tr>
				<th colspan="11">&hellip;</th>
			</tr>
			<tr>
				<th>&#8202;70&#8202;|&#8202;</th>
				<td colspan="7"></td>
				<td><span class="but">.</span></td>
				<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
			</tr>
		</table>
		<p>
			Получается, что оператор <span class="but">.</span> по адресу 77
			восстановит R1 в X без сдвига стека, что позволит сразу выполнить
			бинарную операцию. Обычно само значение из R1 <q>вычислено</q>, а не
			хранится в регистре. Обратите внимание, что выбрана не X2-влияющая
			проверка с переходом.
		</p>
		<p>
			Ещё пример – использовать оператор <span class="but">.</span> как
			входной параметр подпрограммы, т.&#8239;е. эта команда стоит первым оператором.
			В этом случае например, после ввода пользователя
			и нажатия <span class="but_b">С/П</span> сначала выполняются некие вычисления,
			не затрагивающие X2, в том числе сохранение этих результатов в регистры,
			а затем вызов подпрограммы,	которая таким образом <q>видит</q> ввод пользователя.
		</p>
		<p>
			После восстановления ввод цифр не является продолжением ввода числа.
			Они воспринимаются как новый ввод.
		<p>

		</p>
			Вот интересный пример. Пусть в программе есть последовательность
			<span class="but">1</span>
			<span class="but">.</span>
			<span class="but">2</span>
			<span class="but">.</span>
			<span class="but">3</span>.
			Тогда при прямом выполнении будет 1.23. Если идёт переход откуда-то на
			первую точку, то будет восстановление X2 и затем ввод 2.3. Если идёт
			переход на вторую точку, то будет восстановление X2 и ввод 3.
			Вот фрагмент, на котором это видно:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
				<td><span class="but">&times;</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
				<td><span class="but">07</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
				<td><span class="but">09</span></td>
				<td><span class="but">1</span></td>
				<td><span class="but">.</span></td>
				<td><span class="but">2</span></td>
				<td><span class="but">.</span></td>
			</tr>
			<tr>
				<th>&#8202;10&#8202;|&#8202;</th>
				<td><span class="but">3</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="8"></td>
			</tr>
		</table>
		<p>
			Передадим на вход 10, получим 1.23, а RY = 10 &times; &pi;.
			Передадим на вход &minus;10, получим 2.3, а RY = &minus;10 (умножение пропало, как и число &pi;).
			Передадим на вход 0, получим 3, а RY = 0 (умножение тоже пропало, как и число &pi;).
		</p>
	</section>

	<hr>

	<section id="id_exp">
		<header>
			<h2>Команда <span class="but">ВП</span> (код 0C)</h2>
		</header>
		<p>
			Для этой команды существуют несколько условий и правил восстановления.
			Обращаю внимание, что после X2-влияющей команды она ведёт себя как
			обычно, как документировано. Причём даже если она используется
			нестандартно, и выполняет некое восстановление, то всё равно после её
			выполнения ввод цифр будет восприниматься как ввод порядка.
		</p>
		<p>
			Особенность этой операции связана с тем, что разработчики в целях
			лучшего сервиса придумали автоматически исправлять ноль на единицу,
			если вы собираетесь вводить порядок. Но для нас важно, помимо того,
			что команда X2-восстанавливающая, как именно она восстанавливает.
		</p>
		<p>
			Прежде чем привести <dfn>общий алгоритм восстановления
			после <span class="but">ВП</span></dfn> введём несколько
			понятий.
		</p>
		<dl>
			<td>Источник первого разряда</td>
			<dd>
				Или коротко источник. Он обозначает, откуда ПМК будет
				брать первый разряд	числа при восстановлении
				после <span class="but">ВП</span>.
			</dd>
			<dt>Флаг нулевой мантиссы</dt>
			<dd>
				Или коротко ZF. Он показывает, что содержимое X2
				нулевое (точнее только мантисса),
				и требуется модификация первого разряда.
			</dd>
		</dl>
		<p>
			Теперь можно описать общий алгоритм восстановления после
			<span class="but">ВП</span>.
			Сначала анализируется флаг ZF. Если он установлен,
			то первый разряд X2, если он нулевой, заменяется на 1.
			Как не странно, есть редкий случай, когда он не нулевой,
			даже при установленном ZF.
			Затем к нему (первому разряду) прибавляется первый разряд
			источника (сложение шестнадцатеричное, по модулю 16).
			Если же ZF не установлен, то первый разряд источника просто
			копируется в первый разряд X2. Интересно, что в варианте
			ZF складывается, а без него – копируется.
			И только потом новое X2 копируется в X.
			Кстати, после выполнения флаг ZF пересчитывается.
		</p>
		<p>
			Этот алгоритм выведен эмпирически. По крайней в таком виде
			он <q>оправдывает</q> результаты восстановления после
			<span class="but">ВП</span>. Возможно
			реальный алгоритм совсем другой, но этот подходит.
		</p>
		<p>
			А вот источники разные для разных последовательностей
			команд перед <span class="but">ВП</span>.
			И это мы детально рассмотрим ниже.
		</p>

		<hr>

		<section id="id_exp_SR">
			<header>
				<h3>Восстановление X2 с отбрасыванием первой цифры</h3>
			</header>
			<p>
				Это выполняется после последовательности операторов
				<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
				<span class="but">ВП</span>,
				где R – любой регистр памяти. При этом текущее содержимое
				регистра X теряется, без изменения стека. Вместо
				<span class="but_b">x&rarr;П</span><span class="but">R</span>
				может быть и команда
				<span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">R</span>.
			</p>
			<p>
				Пример. Пусть нам нужно обработать ввод выбора пользователя для
				перемещения в некоем трёхмерном лабиринте. Обычно используются клавиши
				2,4,6,8,&plusmn;5, что соответствует направлению движения.
				Рассмотрим такую последовательность, в предположении, что выбор
				пользователя хранится в регистре R9 и значение 0 имеет ещё
				какой-то дополнительный смысл:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">&divide;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">77</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_f">F</span><span class="op_f">x=0</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but">55</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td colspan="8"></td>
				</tr>
			</table>
			<p>
				Что здесь происходит? На шаге два мы получим одно из чисел
				1, 2, 3, 4, &plusmn;2.5 или 0. Условным оператором мы не только
				отсекаем вариант с нулём, но делаем X&rarr;X2. Далее к полученному
				числу сразу прибавляем <span class="pi">&pi;</span> и сохраняем в R9
				для дальнейшей косвенной
				адресации: пусть в R4&hellip;R7 хранятся коэффициенты умножения для
				выполнения движения. Обращаю внимание, что тут использованы не
				X2-влияющие команды. После команды <span class="but">ВП</span> мы
				<q>восстановим</q> в X то значение, что было после деления на шаге 02,
				только без первой цифры, т.&#8239;е. ноль для 1&hellip;4, или
				&plusmn;0.5 для &plusmn;5 как хвост 2.5.
				И использовать это для последующего ветвления программы:
				умножение на коэффициент деления, а для &plusmn;0.5 можно будет
				взять знак числа и т.&#8239;д. Без использования <span class="but">ВП</span>
				потребовалось бы использовать или дополнительный
				регистр, или дополнительные команды по манипуляции со стеком.
			</p>
			<p>
				Дополнительные условия. <strong>Если</strong> содержимое X2
				равно <strong>нулю</strong>,
				то будет восстановлена <strong>единица</strong>, точнее
				единица будет на месте первой цифры нулевого значения,
				т.&#8239;е. если X2 было ненормализованным нулём, то результат
				будет уже не 1. Пример ниже выдаст в результате
				<span class="code"> 10000000.   </span>:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
			<p>
				<strong>Если</strong> в момент восстановления, т.&#8239;е.
				выполнения команды <span class="but">ВП</span>, содержимое
				регистра <strong>X меньше нуля</strong>,
				то вместо удаления первой цифры у числа X2,
				она будет <strong>заменена на 9</strong>.
				<br>
				Например, после выполнения программы
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
			<p>
				на экране будет <span class="code">-9.1415926   </span>,
				потому что команда по адресу 01 X2-влияющая, а в
				R9 будет &minus;<span class="pi">&pi;</span><sup>2</sup>.
			</p>
			<p>
				С учётом знаний по <a href="glossary.html#zero_digit">знакоцифрам</a>
				приведём более точное правило: эта последовательность
				при восстановлении X2 первую цифру результата меняет на
				значение равное знакоцифре числа в регистре X минус 1.
				А если восстанавливаемое X2	равно нулю, то ещё и увеличивает
				первую цифру результата на 1.
				Тогда получается:
			</p>
			<ol>
				<li>
					X2 не ноль. Число X больше нуля, знакоцифра X равна единице,
					значит первая цифра X2 при восстановлении заменяется на ноль, т.&#8239;е.
					удаляется. За исключением случая, когда X2 было ненормализованным,
					т.&#8239;е. первая цифра и так была нулём.
				</li>
				<li>
					X2 не ноль. Число X меньше нуля, с минусом, знакоцифра
					X равна 10 (A), значит первая цифра X2 при
					восстановлении заменяется на 9.
				</li>
				<li>
					Число X2 равно нулю. В этом случае так же первая цифра
					заменяется на знакоцифру числа X минус один,
					но потом увеличивается на 1.
					Итого первой цифрой будет единица для X &ges; 0, или
					цифра А = 10, для X &lt; 0. Если X2 не было нормализовано, то
					остальные цифры восстановятся как было.
				</li>
			</ol>
			<p>
				Для последнего правила приведём пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Здесь на шаге 04 происходит не только уменьшение R0 до нуля,
				но и извлечение этого ненормализованного нуля с помощью X2-влияющей команды.
				Команда по адресу 05 подгоняет в регистр X отрицательное
				значение &minus;1 и при восстановлении получится
				<span class="code"> -0000000.   </span>, где знакоцифра
				A, как минус, сначала уменьшается на один, а потом снова
				увеличивается и копируется в первый разряд. Это не минус ноль.
				Для наглядности можно ещё нажать
				<span class="but">/-/</span>, получится
				<span class="code">--0000000.   </span>, которое численно равно
				&minus;1.0<sup>|+08</sup>, что легко проверить, сложив с нулём.
				<br>
				<span class="code">--0000000.   </span> само по себе тоже
				интересно. Если провести
				его косвенное увеличение через R4&hellip;R6, то как уже
				указано в разделе по косвенной адресации,
				для этих регистров сначала пройдёт
				нормализация числа с переносом старшего разряда, здесь единицы,
				поскольку A = 10, в знакоцифру, которая была минусом, т.&#8239;е. число 10.
				А ещё плюс один сделает уже 11, что снова вызовет перенос лишней
				единицы, но уже в никуда, оставив только 1 на месте знакоцифры,
				т.&#8239;е. просто пусто, потому что неотрицательное число.
				А мантисса останется их одних нулей, значит она увеличится на один,
				что приведёт к содержимому R4&hellip;R6 в виде
				<span class="code"> 00000001.   </span>. Для R0&hellip;R3
				нормализации не будет, но при уменьшении &minus;1.0<sup>|+08</sup>
				превратиться в &minus;99999999. Для R7&hellip;Re ничего не
				произойдёт.
			</p>
			<p>
				Интересно, что можно сразу в X2 получить <q>минус ноль</q> и добиться
				сходного результата <span class="code">--.          </span>, но это уже
				из следующего раздела:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
			<p>
				Так же хочу напомнить, что команда
				<span class="but">ВП</span> X2-восстанавливающая, а это значит,
				что если второй раз сделать
				<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
				<span class="but">ВП</span>, то учитываться будет уже знак
				восстановленного значения X. В частности, для программы выше из
				8 команд, если в конце ещё добавить
				<span class="but_b">x&rarr;П</span><span class="but">8</span>&ensp;
				<span class="but">ВП</span>,
				то получим уже ноль, т.&#8239;к. в неотрицательном
				<span class="code"> -0000000.   </span> первая цифра
				заменится на ноль.
			</p>
			<p>
				Вот интересный пример, использующий ненормализованность чисел
				в необычном контексте. Пусть вводом пользователя является
				некоторое двузначное число, как координаты, и вы
				последовательностью
				<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
				<span class="but">ВП</span> не только сохраняете
				ввод, а также сразу
				отбрасываете десятки. Но часто в таких случаях однозначное
				число подразумевает нулевой десяток, и эта
				последовательность уберёт эту единственную цифру. Что же
				делать? Оказывается, ввод пользователя с ведущим нулём
				оставляет X2 ненормализованным, с тем самым нулём. Т.&#8239;е.
				достаточно вместо числа 3, вводить 03 и всё снова заработает
				– будет отброшен незначащий ноль.
				Для примера приведём программу, которая входное положительное
				двузначное число разделит на десятки, которые будут в регистре Y,
				и единицы, которые будет в регистре X. Вводить нужно всегда две
				цифры, возможно с ведущим нулём.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but">&minus;</span></td>
					<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
			<p>
				Ещё рассмотрим для примера один фрагмент.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but">&minus;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">1</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">2</span></td>
					<td><span class="but">&minus;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">3</span></td>
					<td><span class="but">ВП</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but_b">С/П</span></td>
					<td colspan="9"></td>
				</tr>
			</table>
			<p>
				Для пояснения, что происходит, составим подробно таблицу при выполнении
				этой программы, когда на вход задано число 1.23.
				Обращаю внимание, что пошагово такие значения не получить.
				Это синтетический результат, который можно детально проверить
				вставляя после каждой команды <span class="but_b">С/П</span>,
				или просто посмотрев значения регистров R1-R3, в которые
				специально для этого значения и сохраняются.
			</p>
				<table>
				<tr>
					<th>Команда</th>
					<th>X</th>
					<th>Y</th>
					<th>Z</th>
					<th>X2</th>
					<th>Пояснение</th>
				</tr>
				<tr>
					<th><span class="but_f">F</span><span class="op_f">&pi;</span></th>
					<td><span class="code"> 3.1415926   </span></td>
					<td><span class="code"> 1.23        </span></td>
					<td></td>
					<td><span class="code"> 1.23        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but_f">F</span><span class="op_f">&pi;</span></th>
					<td><span class="code"> 3.1415926   </span></td>
					<td><span class="code"> 3.1415926   </span></td>
					<td><span class="code"> 1.23        </span></td>
					<td><span class="code"> 1.23        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></th>
					<td><span class="code"> 9.869604    </span></td>
					<td><span class="code"> 3.1415926   </span></td>
					<td><span class="code"> 1.23        </span></td>
					<td><span class="code"> 1.23        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but">&minus;</span></th>
					<td><span class="code">-6.7280114   </span></td>
					<td><span class="code"> 1.23        </span></td>
					<td></td>
					<td><span class="code"> 1.23        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but_b">x&rarr;П</span><span class="but">1</span></th>
					<td><span class="code">-6.7280114   </span></td>
					<td><span class="code"> 1.23        </span></td>
					<td></td>
					<td><span class="code"> 1.23        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but">ВП</span></th>
					<td><span class="code"> 9.23        </span></td>
					<td><span class="code"> 1.23        </span></td>
					<td></td>
					<td><span class="code"> 9.23        </span></td>
					<td>
						Произошло восстановление X2 (1.23), но т.&#8239;к.
						число в RX отрицательное, то первая цифра заменена на 9.
					</td>
				</tr>
				<tr>
					<th><span class="but_b">x&rarr;П</span><span class="but">2</span></th>
					<td><span class="code"> 9.23        </span></td>
					<td><span class="code"> 1.23        </span></td>
					<td></td>
					<td><span class="code"> 9.23        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but">&minus;</span></th>
					<td><span class="code">-8           </span></td>
					<td></td>
					<td></td>
					<td><span class="code"> 9.23        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but_b">x&rarr;П</span><span class="but">3</span></th>
					<td><span class="code">-8           </span></td>
					<td></td>
					<td></td>
					<td><span class="code"> 9.23        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but">ВП</span></th>
					<td><span class="code"> 9.23        </span></td>
					<td></td>
					<td></td>
					<td><span class="code"> 9.23        </span></td>
					<td>Восстановлено X2, с заменой 9 на 9.</td>
				</tr>
			</table>
			<p>
				Теперь передадим на вход 000.
			</p>
			<table>
				<tr>
					<th>Команда</th>
					<th>X</th>
					<th>Y</th>
					<th>Z</th>
					<th>X2</th>
					<th>Пояснение</th>
				</tr>
				<tr>
					<th><span class="but_f">F</span><span class="op_f">&pi;</span></th>
					<td><span class="code"> 3.1415926   </span></td>
					<td><span class="code"> 000.        </span></td>
					<td></td>
					<td><span class="code"> 000.        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but_f">F</span><span class="op_f">&pi;</span></th>
					<td><span class="code"> 3.1415926   </span></td>
					<td><span class="code"> 3.1415926   </span></td>
					<td><span class="code"> 000.        </span></td>
					<td><span class="code"> 000.        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></th>
					<td><span class="code"> 9.869604    </span></td>
					<td><span class="code"> 3.1415926   </span></td>
					<td><span class="code"> 000.        </span></td>
					<td><span class="code"> 000.        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but">&minus;</span></th>
					<td><span class="code">-6.7280114   </span></td>
					<td><span class="code"> 000.        </span></td>
					<td></td>
					<td><span class="code"> 000.        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but_b">x&rarr;П</span><span class="but">1</span></th>
					<td><span class="code">-6.7280114   </span></td>
					<td><span class="code"> 000.        </span></td>
					<td></td>
					<td><span class="code"> 000.        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but">ВП</span></th>
					<td><span class="code"> -00.        </span></td>
					<td><span class="code"> 000.        </span></td>
					<td></td>
					<td><span class="code"> -00.        </span></td>
					<td>
						Произошло восстановление X2 (000), причём
						ноль не просто заменился на 9, но и произошло его
						увеличение на 1.
						Получилась шестнадцатеричная цифра A.
					</td>
				</tr>
				<tr>
					<th><span class="but_b">x&rarr;П</span><span class="but">2</span></th>
					<td><span class="code"> -00.        </span></td>
					<td><span class="code"> 000.        </span></td>
					<td></td>
					<td><span class="code"> -00.        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but">&minus;</span></th>
					<td><span class="code">-1000.       </span></td>
					<td></td>
					<td></td>
					<td><span class="code"> -00.        </span></td>
					<td>Прошла нормализация шестнадцатеричной A до 10.</td>
				</tr>
				<tr>
					<th><span class="but_b">x&rarr;П</span><span class="but">3</span></th>
					<td><span class="code">-1000.       </span></td>
					<td></td>
					<td></td>
					<td><span class="code"> -00.        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but">ВП</span></th>
					<td><span class="code"> 900         </span></td>
					<td></td>
					<td></td>
					<td><span class="code"> 900.        </span></td>
					<td>Уже не <span class="code"> -00.        </span>. ZF не установлен, поэтому 9 просто копируется в первый разряд.</td>
				</tr>
			</table>
			<p>
				В данном случае проявляется то, что во время выполнения
				ZF изменился, поэтому +1 уже не делается. Теперь приведём пример,
				где наоборот ZF устанавливается в процессе вычисления.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">x&rarr;П</span><span class="but">1</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">2</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<p>
				Для неё тоже приведём полный разбор. Сначала неинтересный случай – на вход число 24:
			</p>
			<table>
				<tr>
					<th>Команда</th>
					<th>X</th>
					<th>X2</th>
					<th>Пояснение</th>
				</tr>
				<tr>
					<th><span class="but_b">x&rarr;П</span><span class="but">1</span></th>
					<td><span class="code"> 24.        </span></td>
					<td><span class="code"> 24.        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but">ВП</span></th>
					<td><span class="code"> 4   </span></td>
					<td><span class="code"> 04   </span></td>
					<td>Прошла замена первого разряда на знакоцифру &minus; 1 = 0</td>
				</tr>
				<tr>
					<th><span class="but_b">x&rarr;П</span><span class="but">2</span></th>
					<td><span class="code"> 4   </span></td>
					<td><span class="code"> 04   </span></td>
					<td>В R2 сохранилось 4</td>
				</tr>
				<tr>
					<th><span class="but">ВП</span></th>
					<td><span class="code"> 4   </span></td>
					<td><span class="code"> 04   </span></td>
					<td>Повтор того же. У 04 первая цифра меняется на ноль</td>
				</tr>
			</table>
			<p>
				Обратите внимание, что несмотря на то, что при восстановлении X
				сразу нормализуется, само X2 – нет. Теперь более интересный
				вариант. На вход число 20:
			</p>
			<table>
				<tr>
					<th>Команда</th>
					<th>X</th>
					<th>X2</th>
					<th>Пояснение</th>
				</tr>
				<tr>
					<th><span class="but_b">x&rarr;П</span><span class="but">1</span></th>
					<td><span class="code"> 20.        </span></td>
					<td><span class="code"> 20.        </span></td>
					<td></td>
				</tr>
				<tr>
					<th><span class="but">ВП</span></th>
					<td><span class="code"> 0   </span></td>
					<td><span class="code"> 00   </span></td>
					<td>Вот тут флаг ZF пересчитался</td>
				</tr>
				<tr>
					<th><span class="but_b">x&rarr;П</span><span class="but">2</span></th>
					<td><span class="code"> 0   </span></td>
					<td><span class="code"> 00   </span></td>
					<td>В R2 сохранился ноль</td>
				</tr>
				<tr>
					<th><span class="but">ВП</span></th>
					<td><span class="code"> 10   </span></td>
					<td><span class="code"> 10   </span></td>
					<td>Из-за флага первая цифра ещё раз увеличилась</td>
				</tr>
			</table>
			<p>
				Как итог для данного раздела. Последовательность
				<span class="but_b">x&rarr;П</span><span class="but">R</span>
				<span class="but">ВП</span> придерживается
				общего алгоритма восстановления после <span class="but">ВП</span>,
				но в качестве источника первого разряда выступает
				цифра, равная (знакоцифра &minus; 1).
			</p>
		</section>

		<hr>

		<section id="id_exp_combine">
			<header>
				<h3>Восстановление X2 с сохранением первой цифры числа в X</h3>
			</header>
			<p>
				Как правило это наиболее интересная последовательность.
				Она позволяет нестандартно сочетать два числа.
			</p>
			<p>
				Рассмотрим последовательность
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but">ВП</span>.
				При этом <span class="but_k">К</span><span class="op_k">НОП</span> взята как
				более нейтральная, могут быть и другие не X2-влияющие команды.
				Назовём это первой командой. Тут важно учитывать:
			</p>
			<ol>
				<li>
					В качестве образца первой цифры берётся содержимое X до (!)
					начала данной последовательности.
				</li>
				<li>
					Если вместо <span class="but_k">К</span><span class="op_k">НОП</span>
					стоит другая не X2-влияющая команда, причём команда может быть даже
					X2-восстанавливающая, то она выполнится, но
					результат её выполнения, т.&#8239;е. содержимое X, будет потерян.
					При этом стек будет иметь состояние как после выполнения команды.
				</li>
				<li>
					Если первая команда – это переход на другой адрес, то она
					выполнится и последовательность с <span class="but">ВП</span>
					будет нарушена. Но если <span class="but">ВП</span> расположена
					по адресу, куда идёт переход, то сработает.
					Для косвенных переходов сложнее – см. ниже.
				</li>
				<li>
					Если первая команда генерит ошибку, то снова последовательность
					с <span class="but">ВП</span> будет нарушена.
				</li>
				<li>
					Если первая команда это
					<span class="but_b">x&rarr;П</span><span class="but">R</span>, то будет
					выполнено по правилу, описанному разделом выше, с отбрасыванием первой цифры.
				</li>
			</ol>
			<p>
				Пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
					<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				В результате получим <span class="code">1.ELE-6Г9   </span>.
				Тут дробная часть понятна – это инверсия числа <span class="pi">&pi;</span>
				которое
				сохраняется X2-влияющей командой по адресу 03. А интересна тут
				цифра 1 на первом месте, которая появилась в стеке по команде
				<span class="but_k">К</span><span class="op_k">ЗН</span>.
				Именно она подставляется вместо восьмерки при восстановлении.
			</p>
			<p>
				Интересно, что первой цифрой может быть и шестнадцатеричная, тем
				самым можно получить то, что в режиме вычислений трудно сделать.
				Например,
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">9</span></td>
					<td><span class="but_f">F</span><span class="op_f">1/x</span></td>
					<td><span class="but">5</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but">/-/</span></td>
					<td><span class="but">9</span></td>
					<td><span class="but">9</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="6"></td>
				</tr>
			</table>
			<p>
				Будет 10 (!) минусов.
				<span class="code">--.--------99</span>. Тут
				X2-влияющая команда по адресу 06, добавляя минус,
				запоминает в X2 число &minus;8.AAAAAAA.
				Потом оператор дробной части <q>продвигает</q> на
				первый разряд тоже цифру A. Последовательность с
				<span class="but">ВП</span> успешно объединяет X2
				с этой первой цифрой A, а порядок &minus;99 в конце
				дописывается для красоты. Хочу снова
				повторить, что даже восстанавливая, команда
				<span class="but">ВП</span> сохраняет контекст своего
				исполнения, т.&#8239;е. после неё ожидается ввод порядка.
				Это отличается, например, от команды <span class="but">.</span>,
				которая после восстановления не подразумевает ввод дробной
				части числа.
			</p>
			<p>
				Ещё пример. Пусть нужна подпрограмма, которая из первой цифры,
				целой части дробного числа в регистре X делает букву.
				Например, 1&rarr;E, 2&rarr;D, 3&rarr;C, 4&rarr;A.
				В режиме вычислений для этого подошла бы последовательность:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but_b">С/П</span></td>
				</tr>
			</table>
			<p>
				В реальной подпрограмме первый
				<span class="but_k">К</span><span class="op_k">НОП</span>
				не нужен, а вместо <span class="but_b">С/П</span> должно
				стоять <span class="but_b">В/О</span>, но в таком виде
				это можно сразу ввести и попробовать. С учётом специфики выполнения команды <span class="but">ВП</span> в
				программном режиме нужно ещё скопировать X&rarr;X2 после команды
				<span class="but_k">К</span><span class="op_k">{x}</span>, т.&#8239;е.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">В&uarr;</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but_b">С/П</span></td>
					<td colspan="9"></td>
				</tr>
			</table>
			<p>
				Это +1 команда, к тому же стек будет испорчен. Рассмотрим
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Здесь, благодаря восстановлению единицы с шага 01 на шаге 07,
				останется только одна шестнадцатеричная цифра.
				Так недокументированная последовательность сделала подпрограмму
				короче на два шага.
			</p>
			<p>
				Нужно понимать, что если число в X2 ненормализованное, то всё равно
				заменяется только первая цифра. Воспользуемся знаниями
				косвенной адресации:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">4</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">7</span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				В данном случае 4 после косвенного перехода становится 00000004,
				а значит замена первой цифры приведёт к
				<span class="code"> 40000004.   </span>,
				в чем легко убедиться, запустив программу.
			</p>
			<p>
				Теперь рассмотрим особенности. Если число <strong>X</strong>
				до начала последовательности <strong>было нулём</strong>, то
				вместо первой цифры
				устанавливается <strong>ноль</strong>.
				Обычно это значит, что число будет без первой
				цифры, потому что начальный ноль не значащий. Но если он уже и так там был
				например, как результат косвенной адресации с
				ведущими нулями, тогда никаких полезных действий не будет.
				Впрочем, иногда, именно это различие можно использовать, чтобы
				узнать, выполнялась ли косвенная адресация или нет.
			</p>
			<p>
				Если <strong>X2 нулевое</strong>, то тут как бы проявляется
				упомянутый ранее анализ ZF.
				Фактически, в этом случае, первая цифра числа X увеличивается
				на 1. Вот фрагмент:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<p>
				Если на вход этой программе дать 5, то выдаст 6. А если 9, то
				выдаст&hellip; A (!), потом аналогично B, C, D, E, F. Впрочем,
				последнее лучше тут же заменить на 0 и прочистить стек –
				пустышки коварны. Во всяком случае, если на вход передать F, то
				программа однозначно будет перекручена во что-то неузнаваемое.
				Ещё пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">1/x</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="6"></td>
				</tr>
			</table>
			<p>
				На вход
				<span class="code">-9.          </span>,
				на выходе первая цифра от обратной величины
				<span class="code">-1.          </span>.
			</p>
			<p>
				Как итог для данного раздела. Последовательность
				<span class="but_k">К</span><span class="op_k">НОП</span>
				<span class="but">ВП</span> также придерживается
				общего алгоритма восстановления после <span class="but">ВП</span>,
				но в качестве источника первого разряда выступает
				число в X до начала этой последовательности.
				Можно чуть расширить пример ранее:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">&lt;-&gt;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				Как и ранее, если на вход передать 9, то первый <span class="but">ВП</span>
				восстановит 9 + 1 = A (9 из X вместо нуля). Второй <span class="but">ВП</span>
				из регистра X2 уже иcпользует цифру A, но только её и восстановит вместо нуля, заменив &pi;,
				но уже без +1.
			</p>
		</section>

		<hr>

		<section id="id_exp_plus">
			<header>
				<h3>Использование <span class="but">ВП</span> как сложение</h3>
			</header>
			<p>
				Редкий случай, скорее для информации только. Последовательность
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">ВП</span> при <strong>нулевом значении X2</strong>,
				сначала, как и описывалось ранее, увеличит X
				на единицу, а второе <span class="but">ВП</span> уже на величину
				цифры, которая была до увеличения. Добавление ещё команд
				<span class="but">ВП</span> уже ничего не меняют. Пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
			<p>
				На вход 6, на выходе D (6 + 7 = 13). На вход D, на выходе
				B (13 + 14 = 27 = 16 + 11).
			</p>
			<p>
				Здесь также проявляется результат общего алгоритма восстановления
				после <span class="but">ВП</span>. Первый раз, как указано разделом выше,
				число восстанавливается как X + (0 + 1). Но второе <span class="but">ВП</span>,
				так получается, всё ещё использует тот же источник, что и первое
				<span class="but">ВП</span>. Например, если
				вместо <span class="but_k">К</span><span class="op_k">НОП</span>
				вставить <span class="but_f">F</span><span class="op_f">&pi;</span>,
				то всё равно как источник будет использован первый разряд
				нашего ввода, а не &pi;.
			</p>
			<p>
				Но запаздывание срабатывает и для флага ZF. ПМК всё ещё считает его
				установленным. Но первая <span class="but">ВП</span>
				меняет первый разряд в X2 на X + 1. Второе <span class="but">ВП</span>,
				в соответствии с общим алгоритмом, складывает его с тем, что видит (X).
				Дополнительного увеличения не происходит, потому что первый разряд уже не ноль.
				Вот и получается X + X + 1.
			</p>
			<p>
				Как подведение итогов сравним несколько вариантов с учётом того,
				что мы рассмотрели ранее. Возьмём
				ненормализованные числа, чтобы видеть изменения только
				первого разряда, которые и будем восстанавливать.
				<span class="code"> 00000073.   </span> в R7 (
				<span class="but">7</span>&ensp;
				<span class="but">3</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">7</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">7</span>)
				и <span class="code"> 00000000.   </span> в R0 (
				<span class="but">1</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">0</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">0</span>)
				и рассмотрим следующие последовательности.
			</p>
			1. Восстановление 00000073, первая цифра берётся из регистра X:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<br>
			2. Восстановление 00000000, первая цифра берётся из регистра X:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<br>
			3. Восстановление 00000000, первая цифра берётся из регистра X и ещё <q>сложение</q> при X2 = 0:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<br>
			4. Восстановление 00000073, первая цифра – <q>знакоцифра &minus; 1</q>:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<br>
			5. Восстановление 00000000, первая цифра – <q>знакоцифра &minus; 1</q>:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<br>
			6. Восстановление 00000000, первая цифра –
			<q>знакоцифра &minus; 1» и ещё «сложение</q> при X2 = 0:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<br>
			Сводная таблица по указанным выше последовательностям для двух разных чисел в X:
			<table>
				<tr>
					<th>№</th>
					<th>При X = 52</th>
					<th>При X = &minus;52</th>
					<th>Пояснение</th>
				</tr>
				<tr>
					<th>1</th>
					<td><span class="code"> 50000073.   </span></td>
					<td><span class="code"> 50000073.   </span></td>
					<td>
						Первая цифра 5 берётся из регистра X. Знак не важен.
					</td>
				</tr>
				<tr>
					<th>2</th>
					<td><span class="code"> 60000000.   </span></td>
					<td><span class="code"> 60000000.   </span></td>
					<td>
						Первая цифра 5 после восстановления увеличивается, т.&#8239;к.
						восстанавливается ноль.
					</td>
				</tr>
				<tr>
					<th>3</th>
					<td><span class="code"> L0000000.   </span></td>
					<td><span class="code"> L0000000.   </span></td>
					<td>
						Т.&#8239;к. ещё <q>сложение</q>, то к 5 прибавляется 6
						и получается 11 – цифра B.
					</td>
				</tr>
				<tr>
					<th>4</th>
					<td><span class="code"> 73.         </span></td>
					<td><span class="code"> 90000073.   </span></td>
					<td>
						Для неотрицательных <q>знакоцифра &minus; 1</q> равна нулю,
						первый ноль меняется на ноль, число не меняется.
						Для отрицательных <q>знакоцифра &minus; 1</q> равна 9.
					</td>
				</tr>
				<tr>
					<th>5</th>
					<td><span class="code"> 10000000.   </span></td>
					<td><span class="code"> -0000000.   </span></td>
					<td>
						Т.&#8239;к. восстанавливался ноль, то «знакоцифра
						&minus; 1» ещё увеличивается.
					</td>
				</tr>
				<tr>
					<th>6</th>
					<td><span class="code"> 10000000.   </span></td>
					<td><span class="code"> 30000000.   </span></td>
					<td>
						Тут тоже сложение, просто с другой последовательностью.
						Второе <span class="but">ВП</span> использует
						тот же источник для первого разряда, т.&#8239;е.
						<q>знакоцифра &minus; 1</q>. Поэтому
						проводит сложение с этой цифрой и резервом + 1.
						Для неотрицательных 0 (источник) + 0 (резерв) + 1 = 1,
						а для отрицательных 9 (источник) + 10 = 19.
						А по модулю 16, т.&#8239;к. только один разряд, равно 3.
					</td>
				</tr>
			</table>
			<p></p>
		</section>

		<hr>

		<section id="id_exp_goto">
			<header>
				<h3><span class="but">ВП</span> сразу после косвенного перехода</h3>
			</header>
			Т.&#8239;е. в программе делается переход через команду безусловного
			<span class="but_k">К</span><span class="but_b">БП</span><span class="but">R</span>,
			или условного перехода, например,
			<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">R</span>.
			И сразу в месте, куда выполнился переход, идёт команда
			<span class="but">ВП</span>.
			В этом случае так же идёт восстановление X2, но при этом
			<strong>первая цифра меняется на 7</strong>.
			Знак и порядок X2 сохраняются. Аналогично
			тому, что и ранее, если число в X2 не нормализовано,
			то всё равно идёт замена первой цифры, оставляя остальные как есть.
			В случае <strong>X2 = 0</strong> при восстановлении
			первая цифра будет <strong>восьмёркой</strong>.
			<p>
				Для косвенных условных переходов это работает, только если идёт переход на
				адрес. Если же условие выполняется, т.&#8239;е. без перехода,
				то поведение будет как указано выше другими правилами. Если первая после перехода не
				<span class="but">ВП</span>, то тоже по правилам для
				<span class="but">ВП</span> ранее. Пример.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">8</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">8</span></td>
					<td colspan="4">&hellip;</td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="8"></td>
				</tr>
			</table>
			<p>
				После остановке на экране будет
				<span class="code"> 70.         </span>,
				т.&#8239;е. восстановлено X2 = 10, вместо X = 100, и первая цифра заменена на 7.
				Ещё пример.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">4</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">5</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">5</span></td>
					<td><span class="but">ВП</span></td>
					<td colspan="3"><span class="but_b">С/П</span></td>
				</tr>
			</table>
			<p>
				По уже указанными правилам будет
				<span class="code"> 70000005.   </span>. Если
				заменить команду по адресу 05 на
				<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">5</span>,
				то ничего не изменится, т.&#8239;к. условие не выполнится и будет переход.
				Но если заменить на
				<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">5</span>,
				то уже условие выполнится, перехода не будет, и сработает старое
				правило, т.&#8239;е. будет использована первая цифра числа в X, т.&#8239;е.
				<span class="code"> 30000005.   </span>.
			</p>
			<p>
				Приведём пример для отличия нулевого X2. Пусть у нас R7 = 1, и есть короткая программа
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="7"></td>
				</tr>
			</table>
			<p>
				Тогда если ввести <span class="code"> 000.        </span> и
				нажать <span class="but_b">В/О</span>&emsp;
				<span class="but_b">С/П</span>, то получим на выходе
				<span class="code"> 800.         </span>. А если вначале ввести
				<span class="code"> 000.00123   </span>, то получим
				<span class="code"> 700.00123   </span>.
			</p>
			<p>
				Для <strong>не</strong> косвенных переходов работает правило
				<a href="#id_exp_combine">
					восстановление X2 с сохранением первой цифры числа в X</a
				>, при этом пустой оператор не нужен, т.&#8239;к.
				сам переход будет им. Пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">x&lt;0</span></td>
					<td><span class="but">04</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<p>
				Если на вход программе дать
				<span class="code"> 002.        </span>, то получим
				<span class="code"> 902.        </span>
				(9 от &pi;<sup>2</sup>), а если
				<span class="code"> 000.        </span>,
				то получим <span class="code"> -00.        </span>,
				где первый символ – это шестнадцатеричное A,
				т.&#8239;к. 9 + 1 = 10.
			</p>
			<p>
				Кстати, команды
				<span class="but_f">F</span><span class="op_f">Lx</span>
				тоже являются аналогом команд косвенного условного перехода,
				только	по регистрам R0&hellip;R3. И для них это правило
				тоже работает. Например, введём программу
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">В&uarr;</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_f">F</span><span class="op_f">L0</span></td>
					<td><span class="but">02</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<p>
				Если ввести 1 в R0 и выполнить программу, то всё будет
				как обычно и выдаст &pi;, поскольку оно запоминается в X2.
				Но если в R0 ввести 2 и выполнить программу, то будет уже
				<span class="code"> 7.1415926   </span>, т.&#8239;к.
				один раз <span class="but_f">F</span><span class="op_f">L0</span>
				успеет отбросить назад, как бы косвенный условный
				переход	по регистру R0 на наше <span class="but">ВП</span>, которое
				и заменит первую цифру на 7. Легко проверить, что если вставить
				по адресу 02 другую команду, например
				<span class="but_k">К</span><span class="op_k">НОП</span>, сдвинув
				остальную часть программы, то <q>фокус</q> уже не получится,
				потому что переход уже будет не на <span class="but">ВП</span>.
			</p>
			<p>
				Здесь также выполняется общий алгоритм восстановления после
				<span class="but">ВП</span>, где в качестве источника выступает цифра 7.
			</p>
		</section>

		<hr>

		<section id="id_exp_down">
			<header>
				<h3>Команда <span class="but">.</span> перед <span class="but">ВП</span>
				<q>сдвигает</q> захват X глубже на начало</h3>
			</header>
			<p>
				Обычно команда <span class="but">.</span> восстанавливает в X значение
				X2, но <span class="but">ВП</span> тоже пытается восстановить X2,
				но 1-ю цифру берёт ту, что было за 2 хода до нее в X. Рассмотрим
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">5</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">.</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Результат 55, потому что
				15.<sup>|+2</sup> = 225, 225.<sup>|+2</sup> = <strong>5</strong>0625 и <q>выигрывает</q>
				<span class="but">ВП</span>, который восстановит X2 = 15, с первой
				цифрой 5. Если убрать второй
				<span class="but_k">К</span><span class="op_k">НОП</span> по адресу 05, то
				результат будет 25, 2 от 225, т.&#8239;е. второй
				<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
				будет проигнорирован, как будто команда
				<span class="but">.</span> отодвинула
				<span class="but">ВП</span> вглубь.
				Если поменять
				<span class="but_k">К</span><span class="op_k">НОП</span> и
				<span class="but">.</span> местами, то будет 15, т.&#8239;к.
				<span class="but">.</span> восстановит 15 и уже с ним работает
				<span class="but">ВП</span>, поставляя ту же единицу.
				Другой пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">5</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">.</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Здесь <span class="but">.</span> отодвигает до
				<span class="but_b">x&rarr;П</span><span class="but">9</span>,
				т.&#8239;е. восстановится 15 с цифрой 3, т.&#8239;е. 35. Если убрать
				<span class="but_k">К</span><span class="op_k">НОП</span>, то
				поведение будет как у
				<span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
				<span class="but">ВП</span>, т.&#8239;е. 15 без первой цифры = 5.
			</p>
		</section>

		<hr>

		<section id="id_exp_dot">
			<header><h3><span class="but">ВП</span><span class="but">.</span></h3></header>
			<p>
				Известно, хотя не документировано, что для запрета ввода
				точки при вводе порядка, сочетание команд <span class="but">ВП</span> и
				<span class="but">.</span> вызывает ошибку. Более того, в отличие от
				остальных способов получения ошибки он отличается тем, что
			</p>
			<ol>
				<li>Он самый быстрый, действует мгновенно, а не <q>задумываясь</q>.</li>
				<li>
					Он не пропускает в программном режиме лишнюю команду, как делают
					все остальные операции, вызывающие ошибку. Ах да, это тоже не
					документировано.
				</li>
			</ol>
			<p>
				Но это сочетание также работает с X2, т.&#8239;е. игнорирует
				все не X2-влияющие команды между этими двумя командами.
				В связи с этим становится ясно, что следующий фрагмент:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but">В&uarr;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but">.</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				остановится по ошибке уже на команде <span class="but">.</span>, т.&#8239;е. следующим
				для исполнения будет адрес 06, и успеет возвести в квадрат только дважды, потому что
				первый квадрат, как не X2-влияющий будет отброшен по команде
				<span class="but">ВП</span>. Например, на вход 2.
				Появляется <span class="code"> ЕГГ0Г      </span>. И после
				<span class="but_k">К</span><span class="op_k">НОП</span> на экране
				будет 16, как (2.<sup>|+2</sup>)<sup>|+2</sup>. А при нажатии
				<span class="but_f">F</span><span class="op_f">ПРГ</span> мы
				увидим <span class="code"> 0- 22 22 06</span> – остановка на адресе 06.
			</p>
			<p>
				Тут возникает вопрос, а что если хочется использовать команду
				<span class="but">.</span> для восстановления, при условии
				что предыдущее восстановление было по <span class="but">ВП</span>,
				а между этими командами нет X2-влияющих команд. Тут поможет другое
				сочетание&hellip;
			</p>
		</section>

		<hr>

		<section id="id_exp_neg">
			<header><h3><span class="but">ВП</span><span class="but">/-/</span></h3></header>
			<p>
				Само по себе сочетание не интересно, обычная смена знака при
				вводе порядка, но между ними могут стоять не X2-влияющие
				команды, тогда <span class="but">/-/</span> восстановит
				содержимое X2 после команды <span class="but">ВП</span>. Пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				Дадим на вход число &minus;45, тогда в регистре Y будет
				<span class="code">-4500.       </span>, как результат
				возведения во вторую степень. В R9
				<span class="code"> 97.409083   </span>, как
				четвёртая степень <span class="pi">&pi;</span>. А в регистре X
				восстановиться число, но степень успеет стать отрицательной.
				<span class="code">-4.5      -01</span>,
				Обратите внимание на два момента:
			</p>
			<ol>
				<li>
					Ввод цифр после команды <span class="but">ВП</span>
					являются X2-влияющими, и в данном контексте
					относятся только к вводу порядка, поэтому в X2 сохранится
					число с изменённым порядком, а не 2.
				</li>
				<li>
					Команда <span class="but">/-/</span> кроме восстановления
					выполнит ещё свою основную функцию – сменит знак порядка.
				</li>
			</ol>
			<p>
				Если на вход этой программе дать
				<span class="code"> 00000.      </span>, то команда
				<span class="but">ВП</span> поставит на первом месте цифру
				1, т.&#8239;е. будет уже 10000 = 10.<sup>|+4</sup>,
				поэтому неудивительно, что после выполнения в X будет
				100 = 10.<sup>|(4 &minus; 2)</sup>, а в регистре
				Y число 1000000 = 10.<sup>|(4 + 2)</sup>.
			</p>
			<p>
				Интересно, что если отставить только
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<p>
				то промежуточное умножение на 100 сохраниться в R9, а в
				регистре X останется только результат деление на 100.
				Такой вот трюк.
			</p>
			<p>
				Именно из-за этого сочетания многие считают, что
				<span class="but">/-/</span> тоже <q>подозрительный</q>.
				На самом деле он ведёт себя так только при наличии
				<span class="but">ВП</span> и отсутствия X2-влияющих
				команд между ними.
			</p>
			<p>
				Узнать содержимое X2 можно только
				с помощью <span class="but">ВП</span>, потому что
				<span class="but">.</span> по прежнему не годится,
				т.&#8239;к. при таком сочетании остаётся контекст ввода
				порядка, где точка недопустима.
				Пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Здесь обычный случай. Полученная сначала сотня отодвинется
				не X2-влияющими командами в стеке до Z, а потом будет
				восстановлена, только уже с тройкой на первом месте:
				<span class="code"> 300.        </span>.
				Изменим 4-ю команду:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Теперь, благодаря <span class="but">/-/</span>
				порядок не только инвертируется, но ещё и сохранится
				в X2. Поэтому результат будет <span class="code"> 3.       -02</span>.
				Но если мы захотим восстановить X2 с помощью
				<span class="but">.</span>, заменим её 7-ю команду:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">.</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				То ничего не выйдет. Программа выдаст ошибку, потому
				что <span class="but">.</span> всё еще в контексте
				команды <span class="but">ВП</span>, который
				<span class="but">/-/</span> не меняет.
			</p>
		</section>
	</section>

	<hr>

	<section id="id_sum">
		<header><h2>Итог</h2></header>
		<p>
			В этом разделе подробно изложена самая <q>запутанная</q>
			часть недокументированных особенностей, которая ведёт себя
			так только в программном режиме, что значительно затрудняет
			отладку. Она же часто является причиной непонятных сбоев.
			Вкратце напомним:
		</p>
		<ul>
			<li>
				Есть отдельный регистр X2, который имеет смысл
				только в программном режиме.
			</li>
			<li>
				Есть X2-влияющие команды, которые с ним завязаны.
				Они сохраняют X&rarr;X2.
			</li>
			<li>
				Есть X2-восстанавливающие, которые делают обратное
				копирование X2&rarr;X, причём иногда не стандартно.
			</li>
			<li>
				Есть <q>остальные</q> команды, которые выполняются,
				но <q>игнорируются</q> классами команд выше.
			</li>
			<li>
				Некоторые команды бывают X2-влияющими или нет в
				зависимости от контекста исполнения.
			</li>
		</ul>
		<p>
			В то же время, благодаря знаниям об этом, можно использовать
			дополнительный регистр памяти X2, нестандартно сочетать числа
			и получать результаты быстрее, без вычислений.
			Благодаря этому у этих команд довольно широкое поле по
			использованию в процессе оптимизации программы.
		</p>
	</section>

	<footer>
		<a href="../Недокументированные%20возможности%20ПМК%20МК-61.html">К оглавлению</a>
	</footer>

</body>
</html>