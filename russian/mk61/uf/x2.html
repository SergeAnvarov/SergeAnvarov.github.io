<!DOCTYPE html>
<html lang="ru">
<head>
	<title>Таинственный регистр X2</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta content="true" name="HandheldFriendly">
	<meta content="width" name="MobileOptimized">
	<meta content="yes" name="apple-mobile-web-app-capable">
	<meta name="description" content="Недокументированные возможности программируемого микрокалькулятора МК-61. Таинственный регистр X2">
	<link rel="stylesheet" href="../styles/buttons.css">
	<link rel="stylesheet" href="../styles/tables.css">
	<link rel="stylesheet" href="../styles/other.css">
</head>

<body>
	<section>
		<header><h1>Таинственный регистр X2</h1></header>
		<p>
			Такой регистр действительно не упоминается в документации. В
			действительности этот тот регистр, содержимое которого отображается на
			дисплее при остановке ПМК. Поэтому его иногда называют <em>экранным</em> регистром.
		</p>
		<p>
			В документации указано, что таковым является регистр X, но это не так.
			В режиме вычислений после каждой команды содержимое регистра X сразу же
			копируется в X2. И поэтому разницы между ними нет.
			При таком копировании производятся дополнительные проверки,
			например, на предмет переполнения.
			В целях экономии в программном режиме при выполнении
			большинства (!) команд такое копировании не производится.
			Более того, а это и есть самое полезное, некоторые команды позволяют
			сделать и обратное копирование.
		</p>
	</section>

	<hr>

	<section id="id_affect">
		<header><h2>X2-влияющие команды</h2></header>
		<p>
			Для начала опишем список команд, которые копируют в программном режиме
			содержимое X в X2, после выполнения, конечно. Назовём такие команды
			<dfn>X2-влияющие</dfn>.
			<strong>Безусловно</strong> выполняют копирование X в X2 следующие команды:
		</p>
		<ul>
			<li>
				Ввод числа, после ввода каждой цифры. Разделитель <span class="but">.</span>
				сам по себе не является, но при вводе учитываетя как разделитель.
			</li>
			<li style="padding: 3px 0">
				<span class="but">/-/</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_cx">Сx</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but">В&uarr;</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">Вx</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_b">В/О</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_b">П&rarr;x</span><span class="but">R</span> (R = 0&hellip;F)
			</li>
			<li style="padding: 3px 0">
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>
				(R = 0&hellip;F)
			</li>
			<li style="padding: 3px 0">
				пустые операторы с кодами F0&hellip;FF
			</li>
			<li style="padding: 3px 0">
				все команды, генерирующие ошибку, в силу перехода в режим вычислений,
				например,
				27(<span class="but_k">К</span><span class="but">&minus;</span>),
				28(<span class="but_k">К</span><span class="but">&times;</span>),
				29(<span class="but_k">К</span><span class="but">&divide;</span>),
				2B&hellip;2E, 3C и стандартные операции при генерации ошибок.
			</li>
		</ul>
		Выполняют копирование только <strong>при НЕ переходе на адрес</strong>
		следующие команды:
		<ul>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">x&lt;0</span>,
				но команда <span class="but_k">К</span><span class="op_f">x&lt;0</span>
				не влияет на X2
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">x=0</span>, но команда
				<span class="but_k">К</span><span class="op_f">x=0</span>
				не влияет на X2
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">x&ge;0</span>, но команда
				<span class="but_k">К</span><span class="op_f">x&ge;0</span>
				не влияет на X2
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">x&ne;0</span>, но команда
				<span class="but_k">К</span><span class="op_f">x&ne;0</span>
				не влияет на X2
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">L0</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">L1</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">L2</span>
			</li>
			<li style="padding: 3px 0">
				<span class="but_f">F</span><span class="op_f">L3</span>
			</li>
		</ul>
		Для условных операторов это означает, что копирование X&rarr;X2
		производится, когда условие выполняется. Для циклов – когда
		цикл завершается.
		<p>
			Остальные операторы НЕ копируют X в X2. А это, например, означает, что
			регистр X во время таких операций может содержать
			<a href="glossary.html#id_super_num">сверхчисло</a>.
			При этом, конечно, нужно учитывать, чтобы команда сам по себе не делала
			такую проверку на переполнение.
			Например,
			<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span> делает
			проверку параметра перед выполнением, а
			<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
			– нет.
		</p>
		<p>
			Работая в режиме вычислений кажется, что ненормализованные числа,
			у которых есть ведущие нули, образующиеся при косвенной адресации, автоматически
			нормализуется при выполнении любой следующей команды.
			Так вот, это не так. Фактически, <dfn>когда команда является X2-влияющей,
			то перед её исполнением все (!) ячейки стека нормализутся, заодно проверяется
			переполнение в X, а после выполнения X копируется в X2</dfn>.
			При этом, в случае извлечения из памяти, в регистре X
			может оказаться и ненормализованное число.
			А не X2-влияющие команды так не делают: не выполняют нормализацию стека, не
			проверяют переполнения, не копируют X в X2.
			Именно поэтому они работают немного быстрее. Приблизительное
			время выполнения команд см. <a href="commands.html#id_times">в приложении</a>.
		</p>

		<p>
			Для пояснения работы условных операторов рассмотрим такую программу:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
				<td><span class="but">5</span></td>
				<td><span class="but">0</span></td>
				<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
				<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
				<td><span class="but_f">F</span><span class="op_f">x=0</span></td>
				<td><span class="but">07</span></td>
				<td><span class="but_cx">Cx</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="1"></td>
			</tr>
		</table>
		<p>
			Можно увидеть, что на шаге 04 в регистре X возникает сверхчисло.
			Причём оператор
			<span class="but_f">F</span><span class="op_f">x=0</span>
			не выполняется, т.&#8239;е. идёт переход на адрес 07, как адрес перехода.
			В соответствии с таблицей выше, в этом случае копирование X в X2
			не происходит, а значит, ошибки не должно возникать.
			В чем легко убедиться, запустив программ.
			Но если в программе заменить оператор на
			<span class="but_f">F</span><span class="op_f">x&ne;0</span>,
			то условие уже будет выполняться, и будет выполняться копирование
			X в X2, которое приведёт к ошибке.
			Что так же проверяется запуском программы.
		</p>
		<p>
			Хочу отметить, что команда <span class="but_b">В/О</span> также
			является X2-влияющей, т.&#8239;е. если перед возвратом из подпрограммы
			в регистре X будет сверхчисло, то произойдёт остановка по ошибке,
			причём возврат успеет отработать, т.&#8239;е. остановка будет на адресе
			сразу после вызова подпрограммы.
		</p>
		<p>
			Особенности.
		</p>
		<ul>
			<li>
				Команда <span class="but_b">С/П</span> не X2-влияющая, и нормализует
				только при остановке программы из-за выхода из программного режима.
				Можно считать, что в режиме вычислений все команды X2-влияющие.
				Более строго, нормализация осуществляется сразу после выполнения
				в этом режиме каждой команды. Это значит, что если вы извлекли ненормализованное
				число, то в регистре X2, т.&#8239;е. на экране, оно с ведущими нулями, а вот
				в регистре X уже без них!
				Для доказательства возьмём простенькую программу:
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="7"></td>
					</tr>
				</table>
				Если ввести 001, то в X2 будет 001, а в X уже 1. И после нажатия
				<span class="but_b">С/П</span> именно эта нормализованная
				единица подставится	в итог: <span class="code"> 101.        </span>.
				Почему вообще так, рассмотрим в других разделах подробнее.
			</li>
			<li>
				Для команд сохранение в регистр памяти число
				будет запомнено уже в нормализованном виде. Это уже работа самой
				команды сохранения, т.&#8239;к. в RX число останется ненормализованным.
				И в отличии от X2-нормализации переполнение НЕ проверяется.
			</li>
		</ul>
	</section>

	<hr>

	<section id="id_restore">
		<header><h2>X2-восстанавливающие</h2></header>
		<p>
			Некоторые команды синхронизируют в обратную
			сторону, т.&#8239;е. делают обратное копирование X2&rarr;X.
			Именно их мы и рассмотрим.
		</p>
		<p>
			А причиной нестандартного поведения этих команд
			является то, что подпрограммы ввода числа в ПМК, в том числе его порядка,
			работают напрямую с регистром X2, а после выполнения снова
			сохраняют его – обратное копирование в X.
		</p>
		<ul>
			<li>
				Команда	<span class="but">.</span> проверяет, что разделитель не введён
				повторно, поэтому после выполнения перезаписывает X новым X2.
			</li>
			<li>
				Команда <span class="but">ВП</span> проверяет, что
				значение не нулевое. А в случае нуля первый разряд <q>подправляет</q>.
				В программном режиме получаются разнообразные способы вычисления
				этого разряда в зависимости от истории команд.
			</li>
			<li>
				Команда <span class="but">/-/</span> после
				<span class="but">ВП</span> считает суммарный
				порядок, а значит X будет перезаписан вычисленным числом из X2
				с новым порядком.
			</li>
		</ul>
		<p>
			Чтобы выделить эти команды, назовём их <dfn>X2-восстанавливающими</dfn>.
			Они копируют X2&rarr;X, возможно нестандартным способом.
			Обратите внимание, что <span class="but">/-/</span> входит как в
			группу X2-влияющих, так и в группу X2-восстанавливающих.
			Теперь рассмотрим каждую команду более детально.
		</p>
	</section>

	<hr>

	<section id="id_point">
		<header><h2>Команда <span class="but">.</span> (код 0A)</h2></header>
		<p>
			Данная команда в программном режиме восстанавливает в регистре X
			значение X2 как есть, за исключением случая, когда идёт обычный ввод числа,
			например, 1.23, в этом случае поведение полностью соответствует
			документации и эквивалентно режиму вычислений. При этом содержимое
			стека не меняется. Также команда ничего не делает после X2-влияющей
			команды, но это и логично.
			На практике такую команду чаще всего используют для экономии регистров,
			реже – когда требуется ввод без изменения стека.
			<br>
			Пример: проверка битового флага и если его нет, то его установка.
			Пусть в R9 хранится некое число для работы с битами, а в R1 хранится бит
			для проверки, тогда следующий фрагмент сначала сделает проверку
			доступности бита, а при недоступности, сделает его установку:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">1</span></td>
				<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
				<td><span class="but">77</span></td>
				<td colspan="4"></td>
			</tr>
			<tr>
				<th colspan="11">&hellip;</th>
			</tr>
			<tr>
				<th>&#8202;70&#8202;|&#8202;</th>
				<td colspan="7"></td>
				<td><span class="but">.</span></td>
				<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
			</tr>
		</table>
		<p>
			Получается, что оператор <span class="but">.</span> по адресу 77
			восстановит R1 в X без сдвига стека, что позволит сразу выполнить
			бинарную операцию. Обычно само значение из R1 <q>вычислено</q>, а не
			хранится в регистре. Обратите внимание, что выбрана не X2-влияющая
			проверка с переходом.
		</p>
		<p>
			Ещё пример – использовать оператор <span class="but">.</span> как
			входной параметр подпрограммы, т.&#8239;е. эта команда стоит первым оператором.
			В этом случае например, после ввода пользователя
			и нажатия <span class="but_b">С/П</span> сначала выполняются некие вычисления,
			не затрагивающие X2, в том числе сохранение этих результатов в регистры,
			а затем вызов подпрограммы,	которая таким образом <q>видит</q> ввод пользователя.
		</p>
	</section>

	<hr>

	<section id="id_exp">
		<header>
			<h2>Команда <span class="but">ВП</span> (код 0C)</h2>
		</header>
		<p>
			Для этой команды существуют несколько условий и правил восстановления.
			Обращаю внимание, что после X2-влияющей команды она ведёт себя как
			обычно, как документировано. Причём даже если она используется
			нестандартно, и выполняет некое восстановление, то всё равно после её
			выполнения ввод цифр будет восприниматься как ввод порядка.
		</p>

		<hr>

		<section id="id_exp_SR">
			<header>
				<h3>Восстановление X2 с отбрасыванием первой цифры</h3>
			</header>
			<p>
				Это выполняется после последовательности операторов
				<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
				<span class="but">ВП</span>,
				где R – любой регистр памяти. При этом текущее содержимое
				регистра X теряется, без изменения стека. Вместо
				<span class="but_b">x&rarr;П</span><span class="but">R</span>
				может быть и команда
				<span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">R</span>.
			</p>
			<p>
				Пример. Пусть нам нужно обработать ввод выбора пользователя для
				перемещения в некоем трёхмерном лабиринте. Обычно используются клавиши
				2,4,6,8,&plusmn;5, что соответствует направлению движения.
				Рассмотрим такую последовательность, в предположении, что выбор
				пользователя хранится в регистре R9 и значение 0 имеет ещё
				какой-то дополнительный смысл:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">&divide;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">77</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_f">F</span><span class="op_f">x=0</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but">55</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td colspan="8"></td>
				</tr>
			</table>
			<p>
				Что здесь происходит? На шаге два мы получим одно из чисел
				1, 2, 3, 4, &plusmn;2.5 или 0. Условным оператором мы не только
				отсекаем вариант с нулём, но делаем X&rarr;X2. Далее к полученному
				числу сразу прибавляем <span class="pi">&pi;</span> и сохраняем в R9
				для дальнейшей косвенной
				адресации: пусть в R4&hellip;R7 хранятся коэффициенты умножения для
				выполнения движения. Обращаю внимание, что тут использованы не
				X2-влияющие команды. После команды <span class="but">ВП</span> мы
				<q>восстановим</q> в X то значение, что было после деления на шаге 02,
				только без первой цифры, т.&#8239;е. ноль для 1&hellip;4, или
				&plusmn;0.5 для &plusmn;5 как хвост 2.5.
				И использовать это для последующего ветвления программы:
				умножение на коэффициент деления, а для &plusmn;0.5 можно будет
				взять знак числа и т.&#8239;д. Без использования <span class="but">ВП</span>
				потребовалось бы использовать или дополнительный
				регистр, или дополнительные команды по манипуляции со стеком.
			</p>
			<p>
				Дополнительные условия. <strong>Если</strong> содержимое X2
				равно <strong>нулю</strong>,
				то будет восстановлена <strong>единица</strong>, точнее
				единица будет на месте первой цифры нулевого значения,
				т.&#8239;е. если X2 было ненормализованным нулём, то результат
				будет уже не 1. Пример ниже выдаст в результате
				<span class="code"> 10000000.   </span>:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
			<p>
				<strong>Если</strong> в момент восстановления, т.&#8239;е.
				выполнения команды <span class="but">ВП</span>, содержимое
				регистра <strong>X меньше нуля</strong>,
				то вместо удаления первой цифры у числа X2,
				она будет <strong>заменена на 9</strong>.
				<br>
				Например, после выполнения программы
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
			<p>
				на экране будет <span class="code">-9.1415926   </span>,
				потому что команда по адресу 01 X2-влияющая, а в
				R9 будет &minus;<span class="pi">&pi;</span><sup>2</sup>.
			</p>
			<p>
				С учётом знаний по <a href="glossary.html#zero_digit">знакоцифрам</a>
				приведём более точное правило: эта последовательность
				при восстановлении X2 первую цифру результата меняет на
				значение равное знакоцифре числа в регистре X минус 1.
				А если восстанавливаемое X2	равно нулю, то ещё и увеличивает
				первую цифру результата на 1.
				Тогда получается:
			</p>
			<ol>
				<li>
					X2 не ноль. Число X больше нуля, знакоцифра X равна единице,
					значит первая цифра X2 при восстановлении заменяется на ноль, т.&#8239;е.
					удаляется. За исключением случая, когда X2 было ненормализованным,
					т.&#8239;е. первая цифра и так была нулём.
				</li>
				<li>
					X2 не ноль. Число X меньше нуля, с минусом, знакоцифра
					X равна 10 (A), значит первая цифра X2 при
					восстановлении заменяется на 9.
				</li>
				<li>
					Число X2 равно нулю. В этом случае так же первая цифра
					заменяется на знакоцифру числа X минус один,
					но потом увеличивается на 1.
					Итого первой цифрой будет единица для X &ges; 0, или
					цифра А = 10, для X &lt; 0. Если X2 не было нормализовано, то
					остальные цифры восстановятся как было.
				</li>
			</ol>
			<p>
				Для последнего правила приведём пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Здесь на шаге 04 происходит не только уменьшение R0 до нуля,
				но и извлечение это ненормализованного нуля с помощью X2-влияющей команды.
				Команда по адресу 05 подгоняет в регистр X отрицательное
				значение &minus;1 и при восстановлении получится
				<span class="code"> -0000000.   </span>, где знакоцифра
				A, как минус, сначала уменьшается на один, а потом снова
				увеличивается и копируется в первый разряд. Это не минус ноль.
				Для наглядности можно ещё нажать
				<span class="but">/-/</span>, получится
				<span class="code">--0000000.   </span>, которое численно равно
				&minus;1.0<sup>|+08</sup>, что легко проверить, сложив с нулём.
				<br>
				<span class="code">--0000000.   </span> само по себе тоже
				интересно. Если провести
				его косвенное увеличение через R4&hellip;R6, то как уже
				указано в разделе по косвенной адресации,
				для этих регистров сначала пройдёт
				нормализация числа с переносом старшего разряда, здесь единицы,
				поскольку A = 10, в знакоцифру, которая была минусом, т.&#8239;е. число 10.
				А ещё плюс один сделает уже 11, что снова вызовет перенос лишней
				единицы, но уже в никуда, оставив только 1 на месте знакоцифры,
				т.&#8239;е. просто пусто, потому что неотрицательное число.
				А мантисса останется их одних нулей, значит она увеличится на один,
				что приведёт к содержимому R4&hellip;R6 в виде
				<span class="code"> 00000001.   </span>. Для R0&hellip;R3
				нормализации не будет, но при уменьшении &minus;1.0<sup>|+08</sup>
				превратиться в &minus;99999999. Для R7&hellip;Re ничего не
				произойдёт.
			</p>
			<p>
				Интересно, что можно сразу в X2 получить <q>минус ноль</q> и добиться
				сходного результата <span class="code">--.          </span>, но это уже
				из следующего раздела:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
			<p>
				Так же хочу напомнить, что команда
				<span class="but">ВП</span> X2-восстанавливающая, а это значит,
				что если второй раз сделать
				<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
				<span class="but">ВП</span>, то учитываться будет уже знак
				восстановленного значения X. В частности, для программы выше из
				8 команд, если в конце ещё добавить
				<span class="but_b">x&rarr;П</span><span class="but">8</span>&ensp;
				<span class="but">ВП</span>,
				то получим уже ноль, т.&#8239;к. в неотрицательном
				<span class="code"> -0000000.   </span> первая цифра
				заменится на ноль.
			</p>
			<p>
				Ещё интересный пример, использующий ненормализованность чисел
				в необычном контексте. Пусть вводом пользователя является
				некоторое двузначное число, как координаты, и вы
				последовательностью
				<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
				<span class="but">ВП</span> не только сохраняете
				ввод, а также сразу
				отбрасываете десятки. Но часто в таких случаях однозначное
				число подразумевает нулевой десяток, и эта
				последовательность уберёт эту единственную цифру. Что же
				делать? Оказывается, ввод пользователя с ведущим нулём
				оставляет X2 ненормализованным, с тем самым нулём. Т.&#8239;е.
				достаточно вместо числа 3, вводить 03 и всё снова заработает
				– будет отброшен незначащий ноль.
				Для примера приведём программу, которая входное положительное
				двузначное число разделит на десятки, которые будут в регистре Y,
				и единицы, которые будет в регистре X. Вводить нужно всегда две
				цифры, возможно с ведущим нулём.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but">&minus;</span></td>
					<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
		</section>

		<hr>

		<section id="id_exp_combine">
			<header>
				<h3>Восстановление X2 с сохранением первой цифры числа в X</h3>
			</header>
			<p>
				Как правило это наиболее интересная последовательность.
				Она позволяет нестандартно сочетать два числа.
			</p>
			<p>
				Рассмотрим последовательность
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but">ВП</span>.
				При этом <span class="but_k">К</span><span class="op_k">НОП</span> взята как
				более нейтральная, могут быть и другие не X2-влияющие команды.
				Назовём это первой командой. Тут важно учитывать:
			</p>
			<ol>
				<li>
					В качестве образца первой цифры берётся содержимое X до (!)
					начала данной последовательности.
				</li>
				<li>
					Если вместо <span class="but_k">К</span><span class="op_k">НОП</span>
					стоит другая не X2-влияющая команда, причём команда может быть даже
					X2-восстанавливающая, то она выполнится, но
					результат её выполнения, т.&#8239;е. содержимое X, будет потерян.
					При этом стек будет иметь состояние как после выполнения команды.
				</li>
				<li>
					Если первая команда – это переход на другой адрес, то она
					выполнится и последовательность с <span class="but">ВП</span>
					будет нарушена. Но если <span class="but">ВП</span> расположена
					по адресу, куда идёт переход, то сработает.
					Для косвенных переходов сложнее – см. ниже.
				</li>
				<li>
					Если первая команда генерит ошибку, то снова последовательность
					с <span class="but">ВП</span> будет нарушена.
				</li>
				<li>
					Если первая команда это
					<span class="but_b">x&rarr;П</span><span class="but">R</span>, то будет
					выполнено по правилу, описанному разделом выше, с отбрасыванием первой цифры.
				</li>
			</ol>
			<p>
				Пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
					<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				В результате получим <span class="code">1.ELE-6Г9   </span>.
				Тут дробная часть понятна – это инверсия числа <span class="pi">&pi;</span>
				которое
				сохраняется X2-влияющей командой по адресу 03. А интересна тут
				цифра 1 на первом месте, которая появилась в стеке по команде
				<span class="but_k">К</span><span class="op_k">ЗН</span>.
				Именно она подставляется вместо восьмерки при восстановлении.
			</p>
			<p>
				Интересно, что первой цифрой может быть и шестнадцатеричная, тем
				самым можно получить то, что в режиме вычислений трудно сделать.
				Например,
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">9</span></td>
					<td><span class="but_f">F</span><span class="op_f">1/x</span></td>
					<td><span class="but">5</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but">/-/</span></td>
					<td><span class="but">9</span></td>
					<td><span class="but">9</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="6"></td>
				</tr>
			</table>
			<p>
				Будет 10 (!) минусов.
				<span class="code">--.--------99</span>. Тут
				X2-влияющая команда по адресу 06, добавляя минус,
				запоминает в X2 число &minus;8.AAAAAAA.
				Потом оператор дробной части <q>продвигает</q> на
				первый разряд тоже цифру A. Последовательность с
				<span class="but">ВП</span> успешно объединяет X2
				с этой первой цифрой A, а порядок &minus;99 в конце
				дописывается для красоты. Хочу снова
				повторить, что даже восстанавливая, команда
				<span class="but">ВП</span> сохраняет контекст своего
				исполнения, т.&#8239;е. после неё ожидается ввод порядка.
				Это отличается, например, от команды <span class="but">.</span>,
				которая после восстановления не подразумевает ввод дробной
				части числа.
			</p>
			<p>
				Ещё пример. Пусть нужна подпрограмма, которая из первой цифры,
				целой части дробного числа в регистре X делает букву.
				Например, 1&rarr;E, 2&rarr;D, 3&rarr;C, 4&rarr;A.
				В режиме вычислений для этого подошла бы последовательность:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but_b">С/П</span></td>
				</tr>
			</table>
			<p>
				В реальной подпрограмме первый
				<span class="but_k">К</span><span class="op_k">НОП</span>
				не нужен, а вместо <span class="but_b">С/П</span> должно
				стоять <span class="but_b">В/О</span>, но в таком виде
				это можно сразу ввести и попробовать. С учётом специфики выполнения команды <span class="but">ВП</span> в
				программном режиме нужно ещё скопировать X&rarr;X2 после команды
				<span class="but_k">К</span><span class="op_k">{x}</span>, т.&#8239;е.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">В&uarr;</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but_b">С/П</span></td>
					<td colspan="9"></td>
				</tr>
			</table>
			<p>
				Это +1 команда, к тому же стек будет испорчен. Рассмотрим
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Здесь, благодаря восстановлению единицы с шага 01 на шаге 07,
				останется только одна шестнадцатеричная цифра.
				Так недокументированная последовательность сделала подпрограмму
				короче на два шага.
			</p>
			<p>
				Нужно понимать, что если число в X2 ненормализованное, то всё равно
				заменяется только первая цифра. Воспользуемся знаниями
				косвенной адресации:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">4</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">7</span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				В данном случае 4 после косвенного перехода становится 00000004,
				а значит замена первой цифры приведёт к
				<span class="code"> 40000004.   </span>,
				в чем легко убедиться, запустив программу.
			</p>
			<p>
				Теперь рассмотрим особенности. Если число <strong>X</strong>
				до начала последовательности <strong>было нулём</strong>, то
				вместо первой цифры
				устанавливается <strong>ноль</strong>.
				Обычно это значит, что число будет без первой
				цифры, потому что начальный ноль не значащий. Но если он уже и так там был
				например, как результат косвенной адресации с
				ведущими нулями, тогда никаких полезных действий не будет.
				Впрочем, иногда, именно это различие можно использовать, чтобы
				узнать, выполнялась ли косвенная адресация или нет.
			</p>
			<p>
				Если <strong>X2 нулевое</strong>, то тут как бы проявляется
				известный трюк с <span class="but">ВП</span>, которая 0
				автоматически превращает в 1 для ввода порядка.
				Фактически, в этом случае, первая цифра числа X увеличивается
				на 1. Вот фрагмент:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<p>
				Если на вход этой программе дать 5, то выдаст 6. А если 9, то
				выдаст&hellip; A (!), потом аналогично B, C, D, E, F. Впрочем,
				последнее лучше тут же заменить на 0 и прочистить стек –
				пустышки коварны. Во всяком случае, если на вход передать F, то
				программа однозначно будет перекручена во что-то неузнаваемое.
				Ещё пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">1/x</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="6"></td>
				</tr>
			</table>
			<p>
				На вход
				<span class="code">-9.          </span>,
				на выходе первая цифра от обратной величины
				<span class="code">-1.          </span>.
			</p>
		</section>

		<hr>

		<section id="id_exp_plus">
			<header>
				<h3>Использование <span class="but">ВП</span> как сложение</h3>
			</header>
			<p>
				Редкий случай, скорее для информации только. Последовательность
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">ВП</span> при <strong>нулевом значении X2</strong>,
				сначала, как и описывалось ранее, увеличит X
				на единицу, а второе <span class="but">ВП</span> уже на величину
				цифры, которая была до увеличения. Добавление ещё команд
				<span class="but">ВП</span> уже ничего не меняют. Пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
			<p>
				На вход 6, на выходе D (6 + 7 = 13). На вход D, на выходе
				B (13 + 14 = 27 = 16 + 11).
			</p>
			<p>
				Скорее всего внутренне работает так. Микропрограмма работы с
				<span class="but">ВП</span> первый знак вычисляет/хранит отдельно.
				Когда первый раз X2-влияющая команда заносит ноль в X2, то устанавливается
				признак корректировки первого разряда и он вычисляется как 0 + 1, и
				при этом сохраняется. В момент восстановления именно это добавляется
				к значению 6, которое микропрограмма берёт не у себя, и из очереди
				памяти, причём с запозданием по командам. При этом успевает у себя
				внутри обновить 1 на 6 + 1 = 7. При следующем востановлении в микропрограмме
				всё ещё остается признак необходимости корректировки, потому что
				сама команда <span class="but">ВП</span>
				не X2-влияющая, поэтому обновление X2 не было. А в очереди также
				с запозданием отстаётся 6.
				Поэтому и проводится корректировка первого разряда на 6 + 7.
			</p>
			<p>
				Как подведение итогов сравним несколько вариантов с учётом того,
				что мы рассмотрели ранее. Возьмём
				ненормализованные числа, чтобы видеть изменения только
				первого разряда, которые и будем восстанавливать.
				<span class="code"> 00000073.   </span> в R7 (
				<span class="but">7</span>&ensp;
				<span class="but">3</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">7</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">7</span>)
				и <span class="code"> 00000000.   </span> в R0 (
				<span class="but">1</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">0</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">0</span>)
				и рассмотрим следующие последовательности.
			</p>
			1. Восстановление 00000073, первая цифра берётся из регистра X:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<br>
			2. Восстановление 00000000, первая цифра берётся из регистра X:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<br>
			3. Восстановление 00000000, первая цифра берётся из регистра X и ещё <q>сложение</q> при X2 = 0:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<br>
			4. Восстановление 00000073, первая цифра – <q>знакоцифра &minus; 1</q>:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<br>
			5. Восстановление 00000000, первая цифра – <q>знакоцифра &minus; 1</q>:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<br>
			6. Восстановление 00000000, первая цифра –
			<q>знакоцифра &minus; 1» и ещё «сложение</q> при X2 = 0:
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<br>
			Сводная таблица по указанным выше последовательностям для двух разных чисел в X:
			<table>
				<tr>
					<th>№</th>
					<th>При X = 52</th>
					<th>При X = &minus;52</th>
					<th>Пояснение</th>
				</tr>
				<tr>
					<th>1</th>
					<td><span class="code"> 50000073.   </span></td>
					<td><span class="code"> 50000073.   </span></td>
					<td>
						Первая цифра 5 берётся из регистра X. Знак не важен.
					</td>
				</tr>
				<tr>
					<th>2</th>
					<td><span class="code"> 60000000.   </span></td>
					<td><span class="code"> 60000000.   </span></td>
					<td>
						Первая цифра 5 после восстановления увеличивается, т.&#8239;к.
						восстанавливается ноль.
					</td>
				</tr>
				<tr>
					<th>3</th>
					<td><span class="code"> L0000000.   </span></td>
					<td><span class="code"> L0000000.   </span></td>
					<td>
						Т.&#8239;к. ещё <q>сложение</q>, то к 5 прибавляется 6
						и получается 11 – цифра B.
					</td>
				</tr>
				<tr>
					<th>4</th>
					<td><span class="code"> 73.         </span></td>
					<td><span class="code"> 90000073.   </span></td>
					<td>
						Для неотрицательных <q>знакоцифра &minus; 1</q> равна нулю,
						первый ноль меняется на ноль, число не меняется.
						Для отрицательных <q>знакоцифра &minus; 1</q> равна 9.
					</td>
				</tr>
				<tr>
					<th>5</th>
					<td><span class="code"> 10000000.   </span></td>
					<td><span class="code"> -0000000.   </span></td>
					<td>
						Т.&#8239;к. восстанавливался ноль, то «знакоцифра
						&minus; 1» ещё увеличивается.
					</td>
				</tr>
				<tr>
					<th>6</th>
					<td><span class="code"> 10000000.   </span></td>
					<td><span class="code"> 30000000.   </span></td>
					<td>
						Тут сложнее. Второе <span class="but">ВП</span> видит
						<q>знакоцифру &minus; 1</q>, но ещё до увеличения. Поэтому
						проводит сложение с этой цифрой и ею же + 1.
						Для неотрицательных 0 + 1 = 1,
						а для отрицательных 9 + 10 = 19.
						А по модулю 16, т.&#8239;к. только один разряд, равно 3.
					</td>
				</tr>
			</table>
			<p></p>
		</section>

		<hr>

		<section id="id_exp_goto">
			<header>
				<h3><span class="but">ВП</span> сразу после косвенного перехода</h3>
			</header>
			Т.&#8239;е. в программе делается переход через команду безусловного
			<span class="but_k">К</span><span class="but_b">БП</span><span class="but">R</span>,
			или условного перехода, например,
			<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">R</span>.
			И сразу в месте, куда выполнился переход, идёт команда
			<span class="but">ВП</span>.
			В этом случае так же идёт восстановление X2, но при этом
			<strong>первая цифра меняется на 7</strong>.
			Знак и порядок X2 сохраняются. Аналогично
			тому, что и ранее, если число в X2 не нормализовано,
			то всё равно идёт замена первой цифры, оставляя остальные как есть.
			В случае <strong>X2 = 0</strong> при восстановлении
			первая цифра будет <strong>восьмёркой</strong>.
			<p>
				Для косвенных условных переходов это работает, только если идёт переход на
				адрес. Если же условие выполняется, т.&#8239;е. без перехода,
				то поведение будет как указано выше другими правилами. Если первая после перехода не
				<span class="but">ВП</span>, то тоже по правилам для
				<span class="but">ВП</span> ранее. Пример.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">8</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">8</span></td>
					<td colspan="4">&hellip;</td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="8"></td>
				</tr>
			</table>
			<p>
				После остановке на экране будет
				<span class="code"> 70.         </span>,
				т.&#8239;е. восстановлено X2 = 10, вместо X = 100, и первая цифра заменена на 7.
				Ещё пример.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">4</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">5</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">5</span></td>
					<td><span class="but">ВП</span></td>
					<td colspan="3"><span class="but_b">С/П</span></td>
				</tr>
			</table>
			<p>
				По уже указанными правилам будет
				<span class="code"> 70000005.   </span>. Если
				заменить команду по адресу 05 на
				<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">5</span>,
				то ничего не изменится, т.&#8239;к. условие не выполнится и будет переход.
				Но если заменить на
				<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">5</span>,
				то уже условие выполнится, перехода не будет, и сработает старое
				правило, т.&#8239;е. будет использована первая цифра числа в X, т.&#8239;е.
				<span class="code"> 30000005.   </span>.
			</p>
			<p>
				Приведём пример для отличия нулевого X2. Пусть у нас R7 = 1, и есть короткая программа
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="7"></td>
				</tr>
			</table>
			<p>
				Тогда если ввести <span class="code"> 000.        </span> и
				нажать <span class="but_b">В/О</span>&emsp;
				<span class="but_b">С/П</span>, то получим на выходе
				<span class="code"> 800.         </span>. А если вначале ввести
				<span class="code"> 000.00123   </span>, то получим
				<span class="code"> 700.00123   </span>.
			</p>
			<p>
				Для <strong>не</strong> косвенных переходов работает правило
				<a href="#id_exp_combine">
					восстановление X2 с сохранением первой цифры числа в X</a
				>, при этом пустой оператор не нужен, т.&#8239;к.
				сам переход будет им. Пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">x&lt;0</span></td>
					<td><span class="but">04</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<p>
				Если на вход программе дать
				<span class="code"> 002.        </span>, то получим
				<span class="code"> 902.        </span>
				(9 от &pi;<sup>2</sup>), а если
				<span class="code"> 000.        </span>,
				то получим <span class="code"> -00.        </span>,
				где первый символ – это шестнадцатеричное A,
				т.&#8239;к. 9 + 1 = 10.
			</p>
			<p>
				Кстати, команды
				<span class="but_f">F</span><span class="op_f">Lx</span>
				тоже являются аналогом команд косвенного условного перехода,
				только	по регистрам R0&hellip;R3. И для них это правило
				тоже работает. Например, введём программу
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">В&uarr;</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_f">F</span><span class="op_f">L0</span></td>
					<td><span class="but">02</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<p>
				Если ввести 1 в R0 и выполнить программу, то всё будет
				как обычно и выдаст &pi;, поскольку оно запоминается в X2.
				Но если в R0 ввести 2 и выполнить программу, то будет уже
				<span class="code"> 7.1415926   </span>, т.&#8239;к.
				один раз <span class="but_f">F</span><span class="op_f">L0</span>
				успеет отбросить назад, как бы косвенный условный
				переход	по регистру R0 на наше <span class="but">ВП</span>, которое
				и заменит первую цифру на 7. Легко проверить, что если вставить
				по адресу 02 другую команду, например
				<span class="but_k">К</span><span class="op_k">НОП</span>, сдвинув
				остальную часть программы, то <q>фокус</q> уже не получится,
				потому что переход уже будет не на <span class="but">ВП</span>.
			</p>
		</section>

		<hr>

		<section id="id_exp_down">
			<header>
				<h3>Команда <span class="but">.</span> перед <span class="but">ВП</span>
				<q>сдвигает</q> захват X глубже на начало</h3>
			</header>
			<p>
				Обычно команда <span class="but">.</span> восстанавливает в X значение
				X2, но <span class="but">ВП</span> тоже пытается восстановить X2,
				но 1-ю цифру берёт ту, что было за 2 хода до нее в X. Рассмотрим
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">5</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">.</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Результат 55, потому что
				15.<sup>|+2</sup> = 225, 225.<sup>|+2</sup> = <strong>5</strong>0625 и <q>выигрывает</q>
				<span class="but">ВП</span>, который восстановит X2 = 15, с первой
				цифрой 5. Если убрать второй
				<span class="but_k">К</span><span class="op_k">НОП</span> по адресу 05, то
				результат будет 25, 2 от 225, т.&#8239;е. второй
				<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
				будет проигнорирован, как будто команда
				<span class="but">.</span> отодвинула
				<span class="but">ВП</span> вглубь.
				Если поменять
				<span class="but_k">К</span><span class="op_k">НОП</span> и
				<span class="but">.</span> местами, то будет 15, т.&#8239;к.
				<span class="but">.</span> восстановит 15 и уже с ним работает
				<span class="but">ВП</span>, поставляя ту же единицу.
				Другой пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">5</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">.</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Здесь <span class="but">.</span> отодвигает до
				<span class="but_b">x&rarr;П</span><span class="but">9</span>,
				т.&#8239;е. восстановится 15 с цифрой 3, т.&#8239;е. 35. Если убрать
				<span class="but_k">К</span><span class="op_k">НОП</span>, то
				поведение будет как у
				<span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
				<span class="but">ВП</span>, т.&#8239;е. 15 без первой цифры = 5.
			</p>
		</section>

		<hr>

		<section id="id_exp_dot">
			<header><h3><span class="but">ВП</span><span class="but">.</span></h3></header>
			<p>
				Известно, хотя не документировано, что для запрета ввода
				точки при вводе порядка, сочетание команд <span class="but">ВП</span> и
				<span class="but">.</span> вызывает ошибку. Более того, в отличие от
				остальных способов получения ошибки он отличается тем, что
			</p>
			<ol>
				<li>Он самый быстрый, действует мгновенно, а не <q>задумываясь</q>.</li>
				<li>
					Он не пропускает в программном режиме лишнюю команду, как делают
					все остальные операции, вызывающие ошибку. Ах да, это тоже не
					документировано.
				</li>
			</ol>
			<p>
				Но это сочетание также работает с X2, т.&#8239;е. игнорирует
				все не X2-влияющие команды между этими двумя командами.
				В связи с этим становится ясно, что следующий фрагмент:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but">В&uarr;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but">.</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				остановится по ошибке уже на команде <span class="but">.</span>, т.&#8239;е. следующим
				для исполнения будет адрес 06, и успеет возвести в квадрат только дважды, потому что
				первый квадрат, как не X2-влияющий будет отброшен по команде
				<span class="but">ВП</span>. Например, на вход 2.
				Появляется <span class="code"> ЕГГ0Г      </span>. И после
				<span class="but_k">К</span><span class="op_k">НОП</span> на экране
				будет 16, как (2.<sup>|+2</sup>)<sup>|+2</sup>. А при нажатии
				<span class="but_f">F</span><span class="op_f">ПРГ</span> мы
				увидим <span class="code"> 0- 22 22 06</span> – остановка на адресе 06.
			</p>
			<p>
				Тут возникает вопрос, а что если хочется использовать команду
				<span class="but">.</span> для восстановления, при условии
				что предыдущее восстановление было по <span class="but">ВП</span>,
				а между этими командами нет X2-влияющих команд. Тут поможет другое
				сочетание&hellip;
			</p>
		</section>

		<hr>

		<section id="id_exp_neg">
			<header><h3><span class="but">ВП</span><span class="but">/-/</span></h3></header>
			<p>
				Само по себе сочетание не интересно, обычная смена знака при
				вводе порядка, но между ними могут стоять не X2-влияющие
				команды, тогда <span class="but">/-/</span> восстановит
				содержимое X2 после команды <span class="but">ВП</span>. Пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				Дадим на вход число &minus;45, тогда в регистре Y будет
				<span class="code">-4500.       </span>, как результат
				возведения во вторую степень. В R9
				<span class="code"> 97.409083   </span>, как
				четвёртая степень <span class="pi">&pi;</span>. А в регистре X
				восстановиться число, но степень успеет стать отрицательной.
				<span class="code">-4.5      -01</span>,
				Обратите внимание на два момента:
			</p>
			<ol>
				<li>
					Ввод цифр после команды <span class="but">ВП</span>
					являются X2-влияющими, и в данном контексте
					относятся только к вводу порядка, поэтому в X2 сохранится
					число с изменённым порядком, а не 2.
				</li>
				<li>
					Команда <span class="but">/-/</span> кроме восстановления
					выполнит ещё свою основную функцию – сменит знак порядка.
				</li>
			</ol>
			<p>
				Если на вход этой программе дать
				<span class="code"> 00000.      </span>, то команда
				<span class="but">ВП</span> поставит на первом месте цифру
				1, т.&#8239;е. будет уже 10000 = 10.<sup>|+4</sup>,
				поэтому неудивительно, что после выполнения в X будет
				100 = 10.<sup>|(4 &minus; 2)</sup>, а в регистре
				Y число 1000000 = 10.<sup>|(4 + 2)</sup>.
			</p>
			<p>
				Интересно, что если отставить только
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<p>
				то промежуточное умножение на 100 сохраниться в R9, а в
				регистре X останется только результат деление на 100.
				Такой вот трюк.
			</p>
			<p>
				Именно из-за этого сочетания многие считают, что
				<span class="but">/-/</span> тоже <q>подозрительный</q>.
				На самом деле он ведёт себя так только при наличии
				<span class="but">ВП</span> и отсутствия X2-влияющих
				команд между ними.
			</p>
			<p>
				Ещё особенность команды <span class="but">/-/</span> в том, что
				она безусловно копирует X&rarr;X2, в отличии от других
				X2-восстанавливающих команд. Но узнать это можно только
				с помощью <span class="but">ВП</span>, потому что
				<span class="but">.</span> по прежнему не годится,
				т.&#8239;к. при таком сочетании остаётся контекст ввода
				порядка, где точка недопустима.
				Пример:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Здесь обычный случай. Полученная сначала сотня отодвинется
				не X2-влияющими командами в стеке до Z, а потом будет
				восстановлена, только уже с тройкой на первом месте:
				<span class="code"> 300.        </span>.
				Изменим 4-ю команду:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Теперь, благодаря <span class="but">/-/</span>
				порядок не только инвертируется, но ещё и сохранится
				в X2. Поэтому результат будет <span class="code"> 3.       -02</span>.
				Но если мы захотим восстановить X2 с помощью
				<span class="but">.</span>, заменим её 7-ю команду:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">.</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				То ничего не выйдет. Программа выдаст ошибку, потому
				что <span class="but">.</span> всё еще в контексте
				команды <span class="but">ВП</span>, который
				<span class="but">/-/</span> не меняет.
			</p>
		</section>
	</section>

	<hr>

	<section id="id_sum">
		<header><h2>Итог</h2></header>
		<p>
			В этом разделе подробно изложена самая <q>запутанная</q>
			часть недокументированных особенностей, которая ведёт себя
			так только в программном режиме, что значительно затрудняет
			отладку. Она же часто является причиной непонятных сбоев.
			Вкратце напомним:
		</p>
		<ul>
			<li>
				Есть отдельный регистр X2, который имеет смысл
				только в программном режиме.
			</li>
			<li>
				Есть X2-влияющие команды, которые с ним завязаны.
				Они сохраняют X&rarr;X2.
			</li>
			<li>
				Есть X2-восстанавливающие, которые делают обратное
				копирование X2&rarr;X, причём иногда не стандартно.
			</li>
			<li>
				Есть <q>остальные</q> команды, которые выполняются,
				но <q>игнорируются</q> классами команд выше.
			</li>
			<li>
				Некоторые команды бывают X2-влияющими или нет в
				зависимости от контекста исполнения.
			</li>
		</ul>
		<p>
			В то же время, благодаря знаниям об этом, можно использовать
			дополнительный регистр памяти X2, нестандартно сочетать числа
			и получать результаты быстрее, без вычислений.
			Благодаря этому у этих команд довольно широкое поле по
			использованию в процессе оптимизации программы.
		</p>
	</section>

	<footer>
		<a href="../Недокументированные%20возможности%20ПМК%20МК-61.html">К оглавлению</a>
	</footer>

</body>
</html>