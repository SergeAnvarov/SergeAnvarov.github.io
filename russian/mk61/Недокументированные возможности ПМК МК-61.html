<!DOCTYPE html>
<html lang="ru">
<head>
	<title>Недокументированные возможности программируемого микрокалькулятора МК-61</title>
	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<meta content="true" name="HandheldFriendly"/>
	<meta content="width" name="MobileOptimized"/>
	<meta content="yes" name="apple-mobile-web-app-capable"/>
	<meta name="description" content="Недокументированные возможности программируемого микрокалькулятора МК-61"/>

	<style>

span.but, span.but_f, span.but_k, span.but_cx, span.but_b, span.reg, span.op_f, span.op_k {
	border:thin solid black;
	border-radius:4px;
	display:inline-block;
	font-size:1.1em;
	font-weight:bold;
	font-family:monospace;
/*	max-height:1.2em;
	vertical-align:text-top;*/
	text-align:center;
	min-width:2.3em;
	white-space:nowrap;
}

sup {
	line-height:0;
}

span.but {
	background-color:#CCCCCC;
	color:black;
}

span.but_f {
	background-color:#F5E345;
	color:black;
}

span.but_k {
	background-color:LightSkyBlue;
	color:white;
}

span.but_cx {
	background-color:#F00505;
	color:white;
}

span.but_b {
	background-color:black;
	color:white;
}

span.reg {
	background-color:black;
	color:white;
}

span.op_f {
	background-color:black;
	color:yellow;
}

span.op_k {
	background-color:black;
	color:#00BFFF;
}

.code {
	background-color:#103810;
	color:#77FF77;
	font-size:1.1em;
	font-family:monospace;
	font-weight:bold;
	padding:1px 2px 1px 2px;
	white-space:pre;
}

table {
	border-collapse:collapse;
}

table, th, td {
	border:1px solid black;
}

.center {
	text-align:center;
}

tr.trblack td {
	background:#E1E1E1;
}

tr.trblack_black td {
	background:#8E8E8E;
}

.wall_color {
	background-color:#8E8E8E;
}

td.nowrap {
	white-space:nowrap;
}

address.align_right {
	text-align:right;
}

li.li_change {
	list-style-type:none;
}
li.li_change::before {
	content:"*";
	margin-left:-1em;
	padding-right:0.2em;
}

li.li_add {
	list-style-type:none;
}
li.li_add::before {
	content:"+";
	margin-left:-1em;
	padding-right:0.2em;
}

details summary {
	cursor: pointer;
}
details summary > * {
	display: inline;
}

dt {
	margin-top:1em;
}

span.pi {
	font-size:large;
}

span.first_bold {
	display:inline-block;
}
span.first_bold::first-letter {
	font-weight:bold;
}

a[target="_blank"] {
	background: url(https://upload.wikimedia.org/wikipedia/commons/6/64/Icon_External_Link.png) center right no-repeat;
	padding-right: 0.8em;
}

	</style>
</head>

<body>
	<header>
		<h1>Недокументированные возможности программируемого микрокалькулятора МК-61</h1>
	</header>

	<details open="open">
		<summary><h2>Оглавление</h2></summary>
		<nav>
			<ul>
				<li>
					<a href="#id_preface">Предисловие</a>
				</li>
				<li>
					<a href="#id_addr_space">Программное адресное пространство</a>
					<ul>
						<li>
							<a href="#id_addr_space_using">Практическое применение</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#id_indirect_addr">Косвенная адресация</a>
					<ul>
						<li>
							<a href="#id_indirect_addr_gt1">Число больше или равно единицы</a>
						</li>
						<li>
							<a href="#id_indirect_addr_lt1">Число положительное, но меньше единицы</a>
						</li>
						<li>
							<a href="#id_indirect_addr_negative">Число отрицательное</a>
						</li>
						<li>
							<a href="#id_indirect_addr_R0">Регистры R0&hellip;R3</a>
						</li>
						<li>
							<a href="#id_indirect_addr_R4">Регистры R4&hellip;R6</a>
						</li>
						<li>
							<a href="#id_indirect_addr_FL0">Команды
								<span class="but_f">F</span><span class="op_f">L0</span><!--No space
								-->&hellip;<span class="but_f">F</span><span class="op_f">L3</span>
							</a>
						</li>
						<li>
							<a href="#id_indirect_addr_mantissa">Мантисса содержит шестнадцатеричные цифры</a>
						</li>
						<li>
							<a href="#id_indirect_addr_exponent">Порядок содержит шестнадцатеричные цифры</a>
						</li>
						<li>
							<a href="#id_indirect_addr_reg">Значение &ndash; номер регистра, а не адрес</a>
						</li>
						<li>
							<a href="#id_indirect_addr_using">Практическое использование</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#id_x2">Таинственный регистр X2</a>
					<ul>
						<li>
							<a href="#id_x2_affect">X2-влияющие команды</a>
						</li>
						<li>
							<a href="#id_x2_point">Команда <span class="but">.</span> (код 0A)</a>
						</li>
						<li>
							<a href="#id_x2_exp">Команда <span class="but">ВП</span> (код 0C)</a>
							<ul>
								<li>
									<a href="#id_x2_exp_SR">
										Восстановление X2 с отбрасыванием первой цифры
									</a>
								</li>
								<li>
									<a href="#id_x2_exp_combine">
										Восстановление X2 с заменой первой цифры на цифру
										из числа в X
									</a>
								</li>
								<li>
									<a href="#id_x2_exp_plus">Использование
										<span class="but">ВП</span> как сложение
									</a>
								</li>
								<li>
									<a href="#id_x2_exp_goto"><span class="but">ВП</span>
										сразу после косвенного перехода
									</a>
								</li>
								<li>
									<a href="#id_x2_exp_down">Команда
										<span class="but">.</span> перед
										<span class="but">ВП</span> <q>сдвигает</q> захват X
									</a>
								</li>
								<li>
									<a href="#id_x2_exp_dot">
										<span class="but">ВП</span><span class="but">.</span>
									</a>
								</li>
								<li>
									<a href="#id_x2_exp_neg">
										<span class="but">ВП</span><span class="but">/-/</span>
									</a>
								</li>
							</ul>
						</li>
						<li>
							<a href="#id_x2_sum">Итог</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#id_hex">Шестнадцатеричная арифметика</a>
					<ul>
						<li>
							<a href="#id_hex_h_plus_y">Операция H
								<span class="but">+</span> Y (сложение)
							</a>
						</li>
						<li>
							<a href="#id_hex_x_plus_h">Операция X
								<span class="but">+</span> H (сложение)
							</a>
						</li>
						<li>
							<a href="#id_hex_y_minus_h">Операция Y
								<span class="but">-</span> H (вычитание)
							</a>
						</li>
						<li>
							<a href="#id_hex_h_minus_x">Операция H
								<span class="but">-</span> X (вычитание)
							</a>
						</li>
						<li>
							<a href="#id_hex_h_mult_y">Операция H
								<span class="but">&times;</span> Y (умножение)
							</a>
						</li>
						<li>
							<a href="#id_hex_x_mult_h">Операция X
								<span class="but">&times;</span> H (умножение)
							</a>
						</li>
						<li>
							<a href="#id_hex_h_div_x">Операция H
								<span class="but">&divide;</span> X (деление)
							</a>
						</li>
						<li>
							<a href="#id_hex_y_div_h">Операция Y
								<span class="but">&divide;</span> H (деление)
							</a>
						</li>
						<li>
							<a href="#id_hex_func">Результат функций над
								шестнадцатеричными числами
							</a>
						</li>
						<li>
							<a href="#id_hex_using">Практическое применение</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#id_zero_digit">Числа, у которых вместо знака стоит цифра</a>
					<ul>
						<li>
							<a href="#id_zero_digit_get">Способы получения</a>
						</li>
						<li>
							<a href="#id_zero_digit_sign">Какой знак у числа?</a>
						</li>
						<li>
							<a href="#id_zero_digit_eval">Арифметика с этими числами</a>
						</li>
						<li>
							<a href="#id_zero_digit_sum">Произвольная мантисса и выводы</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#id_neg_zero_degree">Числа с отрицательной нулевой степенью</a>
					<ul>
						<li>
							<a href="#id_nzd_get">Способ получения</a>
						</li>
						<li>
							<a href="#id_nzd_plus">Сложение и вычитание</a>
						</li>
						<li>
							<a href="#id_nzd_mult">Умножение и деление</a>
						</li>
						<li>
							<a href="#id_nzd_func_F"><q>Жёлтые</q> функции</a>
						</li>
						<li>
							<a href="#id_nzd_func_K"><q>Синие</q> функции</a>
						</li>
						<li>
							<a href="#id_nzd_sum">Итог</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#id_tricks">Трюки по оптимизации</a>
				</li>
				<li>
					<a href="#id_demo">Демонстрационная программа</a>
					<ul>
						<li>
							<a href="#id_demo_preface">Описание интерфейса программы</a>
						</li>
					</ul>
					<ul>
						<li>
							<a href="#id_demo_detail">Разбор программы</a>
						</li>
					</ul>
					<ul>
						<li>
							<a href="#id_demo_full">Полный текст программы</a>
						</li>
					</ul>
					<ul>
						<li>
							<a href="#id_demo_tricks">
								Список трюков и недокументированных особенностей
								в программе
							</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#id_commands">Приложение. Все команды</a>
					<ul>
						<li>
							<a href="#id_F_commands">Команды с кодом F</a>
						</li>
					</ul>
				</li>
				<li>
					<a href="#id_glossary">Список терминов</a>
				</li>
			</ul>
		</nav>
	</details>

	<hr>

	<details id="id_preface" open="open">
		<summary><h2>Предисловие</h2></summary>
		<p>
			Предполагается, что читатель знаком с работой на программируемом
			микрокалькуляторе МК-61 (далее просто <a href="#id_glos_calculator">ПМК</a>),
			т.&#8239;е. с <em>документированными</em> возможностями (см.
			<a href="https://sergeanvarov.github.io/russian/mk61/elektronika%20MK-61.pdf" target="_blank">
				руководство по эксплуатации</a>).
		</p>
		<p>
			<strong>Целью</strong> использования недокументированных возможностей чаще всего
			является сокращение длины программы (самый <q>узкий</q> ресурс),
			реже &ndash; высвобождение дополнительных регистров памяти.
			<br>
			Большинство таких возможностей реализуется или используется только в
			контексте программного режима.
			<br>
			Иногда такие возможности используются для получения видео изображения,
			которое невозможно создать обычным способом.
			<br>
			Также знание недокументированных возможностей поможет понять, почему
			иногда программа ведёт себя не совсем так, или совсем не так, как ожидалось.
		</p>
		<p>
			В данной документе не рассматривается получение и исследование
			<a href="#id_glos_super_num">сверхчисел</a> и
			<a href="#id_glos_F">пустышек</a>, которые исторически
			уже рассмотрены <a href="#id_glos_errors">Еггогологией</a>.
			Но из указанной Еггогологии взяты термины
			<a href="#id_glos_err100">ЕГГ0Га</a> и
			<a href="#id_glos_err200">3Г0ГГа</a>, и кое-где
			используются для получения нестандартных чисел или результатов.
		</p>
		<p>
			Далее для обозначения старших шестнадцатеричных цифр используется
			стандартное обозначение <strong>ABCDEF</strong>, при этом в примерах
			отображения используются вид цифр ПМК.
			<br>
			Например, число <strong>8.FEDCBA9</strong> (как инверсия числа 8.0123456),
			будет выглядеть как
			<span class="code"> 8. EГCL-9   </span>.
			<br>
			Следует понимать, что в ПМК шестнадцатеричные только цифры, но не числа,
			то есть ПМК по-прежнему считает каждый разряд как десятичный.
			Т.&#8239;е. число FF, которое в обычном случае равно 255,
			будет интерпретироваться как F &times; 10 + F, т.&#8239;е. 150 + 15 = 165.
		</p>
		<p>
			Дробные числа или числа с большим порядком обычно записываются в научной
			нотации как &plusmn;m.mmmmmmmE&plusmn;pp. Чтобы не путать знак экспоненты
			с шестнадцатеричной цифрой E далее такие числа
			будем указывать в форме &plusmn;m.mmmmmmm<sup>|&plusmn;pp</sup>
			(надстрочная вертикальная черта | вместо E),
			причём знак порядка будем указывать всегда, а для надёжности и точку
			(десятичный разделить) для мантиссы. Например, 1.23<sup>|&minus;02</sup>
			будет выглядеть как <span class="code"> 1.23     -02</span>.
		</p>
		<p>
			Т.&#8239;к. ПМК может использовать
			<a href="#is_glos_unnormalize">ненормализованные числа</a>, то это важно
			отличать, пример: ненормализованное 0.005<sup>|&minus;03</sup> это
			<span class="code"> 0.005    -03</span>,
			а оно же нормализованное &ndash; это 5.<sup>|&minus;06</sup>
			<span class="code"> 5.       -06</span>.
			Ненормализованные числа в тексте так и будут записываться с ведущими нулями.
		</p>
	</details>

	<hr>

	<details id="id_addr_space" open="open">
		<summary><h2>Программное адресное пространство</h2></summary>
		<p>
			Документированное значение для адресов программы &ndash; 105 ячеек.
			Фактически всё немного сложнее.
			Напомним, что адресация ячеек использует только две цифры, поэтому для
			адресов более 99 используются шестнадцатеричные цифры.
		</p>
		<table class="center">
			<tr><th>Адрес формальный</th><th>Адрес фактический</th><th>Доп. адрес</th></tr>
			<tr><td>00</td><td>00</td><td></td></tr>
			<tr><td>01</td><td>01</td><td></td></tr>
			<tr><td colspan="3">&hellip;</td></tr>
			<tr><td>99</td><td>99</td><td></td></tr>
			<tr><td>A0</td><td>A0</td><td></td></tr>
			<tr><td>A1</td><td>A1</td><td></td></tr>
			<tr><td>A2</td><td>A2</td><td></td></tr>
			<tr><td>A3</td><td>A3</td><td></td></tr>
			<tr><td>A4</td><td>A4</td><td></td></tr>
			<tr><td colspan="3"></td></tr>
			<tr><td>A5</td><td>00</td><td></td></tr>
			<tr><td>A6</td><td>01</td><td></td></tr>
			<tr><td>A7</td><td>02</td><td></td></tr>
			<tr><td>A8</td><td>03</td><td></td></tr>
			<tr><td>A9</td><td>04</td><td></td></tr>
			<tr><td>B0</td><td>05</td><td></td></tr>
			<tr><td>B1</td><td>06</td><td></td></tr>
			<tr><td colspan="3"></td></tr>
			<tr><td>B2</td><td>00</td><td></td></tr>
			<tr><td>B3</td><td>01</td><td></td></tr>
			<tr><td>B4</td><td>02</td><td></td></tr>
			<tr><td>B5</td><td>03</td><td></td></tr>
			<tr><td>B6</td><td>04</td><td></td></tr>
			<tr><td>B7</td><td>05</td><td></td></tr>
			<tr><td>B8</td><td>06</td><td></td></tr>
			<tr><td>B9</td><td>07</td><td></td></tr>
			<tr class="trblack"><td>C0</td><td>08</td><td></td></tr>
			<tr class="trblack"><td>C1</td><td>09</td><td></td></tr>
			<tr class="trblack"><td>C2</td><td>10</td><td></td></tr>
			<tr class="trblack"><td>C3</td><td>11</td><td></td></tr>
			<tr class="trblack"><td>C4</td><td>12</td><td></td></tr>
			<tr class="trblack"><td>C5</td><td>13</td><td></td></tr>
			<tr class="trblack"><td>C6</td><td>14</td><td></td></tr>
			<tr class="trblack"><td>C7</td><td>15</td><td></td></tr>
			<tr class="trblack"><td>C8</td><td>16</td><td></td></tr>
			<tr class="trblack"><td>C9</td><td>17</td><td></td></tr>
			<tr class="trblack"><td>D0</td><td>18</td><td></td></tr>
			<tr class="trblack"><td>D1</td><td>19</td><td></td></tr>
			<tr class="trblack"><td>D2</td><td>20</td><td></td></tr>
			<tr class="trblack"><td>D3</td><td>21</td><td></td></tr>
			<tr class="trblack"><td>D4</td><td>22</td><td></td></tr>
			<tr class="trblack"><td>D5</td><td>23</td><td></td></tr>
			<tr class="trblack"><td>D6</td><td>24</td><td></td></tr>
			<tr class="trblack"><td>D7</td><td>25</td><td></td></tr>
			<tr class="trblack"><td>D8</td><td>26</td><td></td></tr>
			<tr class="trblack"><td>D9</td><td>27</td><td></td></tr>
			<tr class="trblack"><td>E0</td><td>28</td><td></td></tr>
			<tr class="trblack"><td>E1</td><td>29</td><td></td></tr>
			<tr class="trblack"><td>E2</td><td>30</td><td></td></tr>
			<tr class="trblack"><td>E3</td><td>31</td><td></td></tr>
			<tr class="trblack"><td>E4</td><td>32</td><td></td></tr>
			<tr class="trblack"><td>E5</td><td>33</td><td></td></tr>
			<tr class="trblack"><td>E6</td><td>34</td><td></td></tr>
			<tr class="trblack"><td>E7</td><td>35</td><td></td></tr>
			<tr class="trblack"><td>E8</td><td>36</td><td></td></tr>
			<tr class="trblack"><td>E9</td><td>37</td><td></td></tr>
			<tr class="trblack"><td>F0</td><td>38</td><td></td></tr>
			<tr class="trblack"><td>F1</td><td>39</td><td></td></tr>
			<tr class="trblack"><td>F2</td><td>40</td><td></td></tr>
			<tr class="trblack"><td>F3</td><td>41</td><td></td></tr>
			<tr class="trblack"><td>F4</td><td>42</td><td></td></tr>
			<tr class="trblack"><td>F5</td><td>43</td><td></td></tr>
			<tr class="trblack"><td>F6</td><td>44</td><td></td></tr>
			<tr class="trblack"><td>F7</td><td>45</td><td></td></tr>
			<tr class="trblack"><td>F8</td><td>46</td><td></td></tr>
			<tr class="trblack"><td>F9</td><td>47</td><td></td></tr>
			<tr><td colspan="3"></td></tr>
			<tr class="trblack_black"><td>FA</td><td>48</td><td>01</td></tr>
			<tr class="trblack_black"><td>FB</td><td>49</td><td>02</td></tr>
			<tr class="trblack_black"><td>FC</td><td>50</td><td>03</td></tr>
			<tr class="trblack_black"><td>FD</td><td>51</td><td>04</td></tr>
			<tr class="trblack_black"><td>FE</td><td>52</td><td>05</td></tr>
			<tr class="trblack_black"><td>FF</td><td>53</td><td>06</td></tr>
		</table>
		<p>
			Первая побочная ветвь (возврат на нулевой адрес) короткая &ndash;
			адреса A5&hellip;B1, которые отображаются на адреса 00&hellip;06.
		</p>
		<p>
			Вторая побочная ветвь длинней &ndash; адреса B2&hellip;F9, которые
			отображаются на адреса 00&hellip;47.
			Причём адреса C0&hellip;F9 являются <a href="#id_glos_shadow">тёмными</a>.
			Например, если выполнить
			<span class="but_b">БП</span>&ensp;
			<span class="but">10</span>&ensp;
			<span class="but_f">F</span><span class="op_f">ПРГ</span>, и
			по адресам 10&hellip;12 ввести команды
			<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
			<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
			<span class="but_k">К</span><span class="op_k">НОП</span>,
			то мы увидим
			<span class="code"> 54 54 54 13</span>.
			Но если затем перейти на адрес C5
			(<span class="but_f">F</span><span class="op_f">АВТ</span>&ensp;
			<span class="but_b">БП</span>&ensp;
			<span class="but">C5</span>&ensp;
			<span class="but_f">F</span><span class="op_f">ПРГ</span>),
			то визуально получим
			<span class="code">          C5</span>, как будто без кода,
			хотя фактически этот будет тот же программный код, просто он затенён.
		</p>
		<p>
			На <dfn>супертёмные</dfn> адреса FA&hellip;FF можно перейти
			только косвенно,
			т.&#8239;к. впрямую адрес, начинающийся с цифры F не вбить.
			Впрочем, некоторые нестандартные последовательности команд в ручном
			режиме, описанные в конце <a href="#id_commands">приложения</a>,
			позволяют вставлять команды,
			начинающиеся с F. А также для владельцев МК-52 есть штатный способ
			сделать <q>or</q> команд с отдельного модуля, с получением кодов с цифрой F.
			<br>
			Так вот, особенность супертёмных адресов такая, что после перехода на
			него выполняется только одна(!) команда, а затем идёт переход на
			дополнительный адрес, который указан в последней колонке.
		</p>
		<p>
			Если в адресе перехода вторая цифра тоже шестнадцатеричная, то как
			указано в предисловии, она прибавляется как есть (E = 14 и т.&#8239;п.).
			Таким образом переход на адреса 9F (90 + 15) или A5 (100 + 5) или
			AC (100 + 12 = 110 + 2 = B2) или B2, будет
			эквивалентно переходу на адрес 00, только потом порядок команд
			будет отличаться.
		</p>
		<p>
			Если сама команда двойная, т.&#8239;е. с адресом перехода (например,
			<span class="but_b">БП</span>,
			<span class="but_f">F</span><span class="op_f">x&lt;0</span>,
			<span class="but_f">F</span><span class="op_f">L1</span>),
			и при этом идёт <q>разрыв</q> адресации, то вторая часть команды
			(адрес перехода) считывается из нового места. Т.&#8239;е. если по адресу 06
			стоит команда <span class="but_b">БП</span>,
			то в обычном потоке адрес перехода будет по адресу 07, но если
			попали сюда как на адрес B1, то адрес перехода будет по адресу 00.
		</p>

		<hr>

		<details id="id_addr_space_using" open="open">
			<summary><h3>Практическое применение</h3></summary>
			<ul>
				<li>
					Расположения управляющих потоком выполнения команд по начальным
					адресам, а в конце программы (или в середине, в зависимости от
					побочной ветви) их не использовать (автоматический переход на начало
					основной ветви)
					для сокращения длины программы. Чаще всего в этом качестве выступает
					<span class="but_b">В/О</span>, но можно и условные переходы,
					<span class="but_b">С/П</span> и др.
				</li>
				<li>
					Использование разных значений для фактического перехода по одному и
					тому же адресу (указано выше). Нестандартное ветвление.
				</li>
				<li>
					Изменение адреса перехода сдвоенной команды, в зависимости от
					формального адреса (указано выше). Так же нестандартное ветвление.
				</li>
			</ul>
		</details>

	</details>

	<hr>

	<details id="id_indirect_addr" open="open">
		<summary><h2>Косвенная адресация</h2></summary>
		<p>
			Документированная возможность &ndash; регистр, используемый для косвенной
			адресации, содержит только целое неотрицательное число. Фактически
			значением его может быть любое число.
			Пусть число, которое содержится в регистре используемом для
			косвенной адресации, записано в виде
			&plusmn;M<sub>1</sub>.M<sub>2</sub>M<sub>3</sub>M<sub>4</sub>M<sub>5</sub>M<sub>6</sub>M<sub>7</sub>M<sub>8</sub><sup>|&plusmn;P<sub>1</sub>P<sub>2</sub></sup>,
			где M &ndash; цифры мантиссы, P &ndash; цифры порядка.
			При этом предполагается, что всегда 8 цифр мантиссы, просто последние
			могут быть нулевыми и обычно не отображаются.
		</p>
		<p>
			При косвенном обращении сначала исходное число преобразуется по
			правилам, описанным ниже, а затем записывается обратно
			(для команд <span class="but_f">F</span><span class="op_f">L0</span
			>&hellip;<span class="but_f">F</span><span class="op_f">L3</span>
			иногда нет).
			При этом всегда(!) цифры M<sub>7</sub>M<sub>8</sub> преобразованного
			числа определяют адрес перехода (или номер регистра).
			Обратите внимание, что преобразованное число не нормализуется перед
			сохранением обратно, тем самым могут быть числа с ведущими нулями.
			Обычно это используется или для генерации специальных изображений или
			в комбинации с другими недокументированными операциями, которым важны
			только цифры мантиссы
			(пример в разделе <a href="#id_x2_exp_combine">Таинственный регистр X2</a>).
		</p>

		<hr>

		<details id="id_indirect_addr_gt1" open="open">
			<summary><h3>
				Вариант
				+M<sub>1</sub>.M<sub>2</sub>M<sub>3</sub>M<sub>4</sub>M<sub>5</sub>M<sub>6</sub>M<sub>7</sub>M<sub>8</sub><sup>|+P<sub>1</sub>P<sub>2</sub></sup>,
				т.&#8239;е. число больше или равно единицы (1.0 &les; N)
			</h3></summary>
			<p>
				В этом случае к числу слева дописывается 7 &minus; P<sub>2</sub> нулей
				(только если результат положительный), <q>выталкивая</q> остальную часть
				мантиссы право. Порядок числа (в нормализованном виде) при этом
				не меняется.
				<br>
				Для наглядности приведём таблицу преобразования на основе простой
				мантиссы, чтобы было видно, какие разряды куда попадают:
			</p>
			<table class="center">
				<tr>
					<th>До</th>
					<th>P<sub>2</sub></th>
					<th>7 &minus; P<sub>2</sub></th>
					<th>Нулей</th>
					<th>После</th>
					<th>Оно же</th>
				</tr>
				<tr>
					<td class="code"> 1.2345678   </td>
					<td>0</td>
					<td>7</td>
					<td>7</td>
					<td class="code"> 00000001.   </td>
					<td class="code"> 1.          </td>
				</tr>
				<tr>
					<td class="code"> 12.345678   </td>
					<td>1</td>
					<td>6</td>
					<td>6</td>
					<td class="code"> 00000012.   </td>
					<td class="code"> 12.         </td>
				</tr>
				<tr>
					<td class="code"> 123.45678   </td>
					<td>2</td>
					<td>5</td>
					<td>5</td>
					<td class="code"> 00000123.   </td>
					<td class="code"> 123.        </td>
				</tr>
				<tr>
					<td class="code"> 1234.5678   </td>
					<td>3</td>
					<td>4</td>
					<td>4</td>
					<td class="code"> 00001234.   </td>
					<td class="code"> 1234.       </td>
				</tr>
				<tr>
					<td class="code"> 12345.678   </td>
					<td>4</td>
					<td>3</td>
					<td>3</td>
					<td class="code"> 00012345.   </td>
					<td class="code"> 12345.      </td>
				</tr>
				<tr>
					<td class="code"> 123456.78   </td>
					<td>5</td>
					<td>2</td>
					<td>2</td>
					<td class="code"> 00123456.   </td>
					<td class="code"> 123456.     </td>
				</tr>
				<tr>
					<td class="code"> 1234567.8   </td>
					<td>6</td>
					<td>1</td>
					<td>1</td>
					<td class="code"> 01234567.   </td>
					<td class="code"> 1234567.    </td>
				</tr>
				<tr>
					<td class="code"> 12345678.   </td>
					<td>7</td>
					<td>0</td>
					<td>0</td>
					<td class="code"> 12345678.   </td>
					<td class="code"> 12345678.   </td>
				</tr>
				<tr>
					<td class="code"> 1.2345678 08</td>
					<td>8</td>
					<td>&minus;1</td>
					<td>0</td>
					<td class="code"> 1.2345678 08</td>
					<td class="code"> 1.2345678 08</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678 09</td>
					<td>9</td>
					<td>&minus;2</td>
					<td>0</td>
					<td class="code"> 1.2345678 09</td>
					<td class="code"> 1.2345678 09</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678 10</td>
					<td>0</td>
					<td>7</td>
					<td>7</td>
					<td class="code"> 0.0000001 17</td>
					<td class="code"> 1.        10</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678 11</td>
					<td>1</td>
					<td>6</td>
					<td>6</td>
					<td class="code"> 0.0000012 17</td>
					<td class="code"> 1.2       11</td>
				</tr>
				<tr>
					<td colspan="6">&hellip;</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678 96</td>
					<td>6</td>
					<td>1</td>
					<td>1</td>
					<td class="code"> 0.1234567 97</td>
					<td class="code"> 1.234567  96</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678 97</td>
					<td>7</td>
					<td>0</td>
					<td>0</td>
					<td class="code"> 1.2345678 97</td>
					<td class="code"> 1.2345678 97</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678 98</td>
					<td>8</td>
					<td>&minus;1</td>
					<td>0</td>
					<td class="code"> 1.2345678 98</td>
					<td class="code"> 1.2345678 98</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678 99</td>
					<td>9</td>
					<td>&minus;2</td>
					<td>0</td>
					<td class="code"> 1.2345678 99</td>
					<td class="code"> 1.2345678 99</td>
				</tr>
			</table>
			<p>
				Кстати, это правило показывает, что для обычных целых чисел, порядок
				которых (от нуля) совпадает с числом цифр &minus; 1, слева
				дописывается такое число нулей, чтобы получилось 8 цифр.
				Т.&#8239;е. число остаётся тем, что есть, что и соответствует документации.
				В случае, если кроме целой части есть и ещё и дробная, то же правило
				показывает, что дописываемые нули <q>вытеснят</q> дробную часть совсем,
				что часто используется в программах для сокращения: нет необходимости
				убирать дробную часть, т.&#8239;к. косвенная адресация её сама уберёт.
			</p>
		</details>

		<hr>

		<details id="id_indirect_addr_lt1" open="open">
			<summary><h3>
				Вариант
				+M<sub>1</sub>.M<sub>2</sub>M<sub>3</sub>M<sub>4</sub>M<sub>5</sub>M<sub>6</sub>M<sub>7</sub>M<sub>8</sub><sup>|&minus;P<sub>1</sub>P<sub>2</sub></sup>,
				т.&#8239;е. само число неотрицательное, но меньше единицы (0.0 &les; N &lt; 1.0)
			</h3></summary>
			<p>
				В этом случае число дописываемых слева нулей определяется так. Вычисляется
				7 + P<sub>2</sub>, и если последняя цифра результата &lt; 8, то
				это и определяет число нулей. Иначе ничего не делается.
			</p>
			<table class="center">
				<tr>
					<th>До</th>
					<th>P<sub>2</sub></th>
					<th>7 + P<sub>2</sub></th>
					<th>Нулей</th>
					<th>После</th>
					<th>Оно же</th>
				</tr>
				<tr>
					<td class="code"> 1.2345678-01</td>
					<td>1</td>
					<td>8</td>
					<td>0</td>
					<td class="code"> 1.2345678-01</td>
					<td class="code"> 1.2345678-01</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-02</td>
					<td>2</td>
					<td>9</td>
					<td>0</td>
					<td class="code"> 1.2345678-02</td>
					<td class="code"> 1.2345678-02</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-03</td>
					<td>3</td>
					<td>10</td>
					<td>0</td>
					<td class="code"> 1.2345678-03</td>
					<td class="code"> 1.2345678-03</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-04</td>
					<td>4</td>
					<td>11</td>
					<td>1</td>
					<td class="code"> 0.1234567-03</td>
					<td class="code"> 1.234567 -04</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-05</td>
					<td>5</td>
					<td>12</td>
					<td>2</td>
					<td class="code"> 0.0123456-03</td>
					<td class="code"> 1.23456  -05</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-06</td>
					<td>6</td>
					<td>13</td>
					<td>3</td>
					<td class="code"> 0.0012345-03</td>
					<td class="code"> 1.2345   -06</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-07</td>
					<td>7</td>
					<td>14</td>
					<td>4</td>
					<td class="code"> 0.0001234-03</td>
					<td class="code"> 1.234    -07</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-08</td>
					<td>8</td>
					<td>15</td>
					<td>5</td>
					<td class="code"> 0.0000123-03</td>
					<td class="code"> 1.23     -08</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-09</td>
					<td>9</td>
					<td>16</td>
					<td>6</td>
					<td class="code"> 0.0000012-03</td>
					<td class="code"> 1.2      -09</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-10</td>
					<td>0</td>
					<td>7</td>
					<td>7</td>
					<td class="code"> 0.0000001-03</td>
					<td class="code"> 1.       -10</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-11</td>
					<td>1</td>
					<td>8</td>
					<td>0</td>
					<td class="code"> 1.2345678-11</td>
					<td class="code"> 1.2345678-11</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-12</td>
					<td>2</td>
					<td>9</td>
					<td>0</td>
					<td class="code"> 1.2345678-12</td>
					<td class="code"> 1.2345678-12</td>
				</tr>
				<tr>
					<td colspan="6">&hellip;</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-23</td>
					<td>3</td>
					<td>10</td>
					<td>0</td>
					<td class="code"> 1.2345678-23</td>
					<td class="code"> 1.2345678-23</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-24</td>
					<td>4</td>
					<td>11</td>
					<td>1</td>
					<td class="code"> 0.1234567-23</td>
					<td class="code"> 1.234567 -24</td>
				</tr>
				<tr>
					<td colspan="6">&hellip;</td>
				</tr>
				<tr>
					<td class="code"> 1.2345678-99</td>
					<td>9</td>
					<td>16</td>
					<td>6</td>
					<td class="code"> 0.0000012-93</td>
					<td class="code"> 1.2      -99</td>
				</tr>
			</table>
		</details>

		<hr>

		<details id="id_indirect_addr_negative" open="open">
			<summary><h3>
				Вариант
				&minus;M<sub>1</sub>.M<sub>2</sub>M<sub>3</sub>M<sub>4</sub>M<sub>5</sub>M<sub>6</sub>M<sub>7</sub>M<sub>8</sub><sup>|&plusmn;P<sub>1</sub>P<sub>2</sub></sup>,
				т.&#8239;е. само число отрицательное (N &lt; 0.0)
			</h3></summary>
			<p>
				В этом случае всё определяется как указано выше, только дописываются не нули, а
				девятки. Знак самого числа сохраняется.
				<br>
				Пример:
				<span class="code">-123.        </span>
				перейдёт в
				<span class="code">-99999123.   </span>,
				т.&#8239;е. адрес перехода = 23.
				<br>
				Пример:
				<span class="code">-1.23     -02</span>
				не изменится, т.&#8239;е. адрес перехода будет равен нулю.
				<br>
				Пример:
				<span class="code">-1.2345678-08</span>
				станет как
				<span class="code">-9.9999123-03</span>, т.&#8239;е. адрес перехода = 23.
			</p>
			<p>
				Тут нужно сделать <strong>замечание</strong>. Есть предположение,
				что девятки не
				случайны, а равны 10 &minus; 1, где 10 это знак минус (как
				шестнадцатеричная цифра A).
				Для проверки такого предположения возьмём число с цифрой вместо знака
				(см. <a href="#id_zero_digit">Числа, у которых вместо знака стоит цифра</a>
				для алгоритма получения).
				Например <span class="code">2E.          </span>,
				где двойка стоит на месте знака. При косвенной адресации:
				<span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">9</span>.
				Двойка уменьшается на единицу и становится
				<span class="code">21111111E.   </span>.
				Аналогично для других чисел, например, если для
				<span class="code">9E.          </span>
				(которое после <span class="but">/-/</span>) выполнить косвенную адресацию,
				то получим <span class="code">98888888E.   </span>.
			</p>
			<p>
				Теперь рассмотрим ситуацию, когда само значение регистра ещё и меняется
				как описано в документации. Обращаю внимание, что изменения происходят
				не при любом косвенном обращении, а только когда значение адреса для
				перехода вычисляется. Например, в условном операторе
				<span class="but_k">К</span><span class="op_f">x&lt;0</span><span
				class="but">4</span> регистр R4 будет модифицирован только когда x&ges;0,
				т.&#8239;е. когда понадобится вычислить адрес перехода.
			</p>
		</details>

		<hr>

		<details id="id_indirect_addr_R0" open="open">
			<summary><h3>Регистры R0&hellip;R3</h3></summary>
			<p>
				Для них преобразованное(!) значение
				предварительно уменьшается на 1 без(!) учёта порядка и знака.
				В расчёт берутся только (но все) цифры мантиссы. При этом, если
				был ноль, то преобразуется в &minus;99999999.
				Из того, что знак не учитывается, выходит, что для отрицательных чисел
				получается увеличение числа (в арифметическом смысле),
				а не уменьшение. Примеры:
			</p>
			<p>
				<span class="code"> 123.        </span>,
				что представляется как 1.23<sup>|+02</sup>,
				перейдёт в 0.0000123<sup>|+07</sup>,
				затем уменьшится до 0.000012<strong>2</strong><sup>|+07</sup> и
				превратится в <span class="code"> 00000122.   </span>,
				т.&#8239;е. адрес перехода = 22.
				<br>
				<span class="code"> 1.23     -02</span>,
				что представляется как 1.2300000<sup>|&minus;02</sup> уменьшится до
				1.2<strong>299999</strong><sup>|&minus;02</sup>,
				превратится в <span class="code"> 1.2299999-02</span>,
				т.&#8239;е. адрес перехода = 99.
				<br>
				<span class="code">-123.        </span>,
				что представляется как &minus;1.23<sup>|+02</sup>,
				преобразуется в &minus;9.9999123<sup>|+07</sup>,
				затем уменьшится до &minus;9.999912<strong>2</strong><sup>|+07</sup>,
				превратится в <span class="code">-99999122.   </span>,
				т.&#8239;е. адрес перехода = 22.
				<br>
				<span class="code">-1.2345678-08</span>,
				преобразуется в &minus;9.9999123<sup>|&minus;03</sup>,
				затем уменьшится до &minus;9.999912<strong>2</strong><sup>|&minus;03</sup>,
				превратится в <span class="code">-9.9999122-03</span>, т.&#8239;е.
				адрес перехода = 22.
			</p>
			<p>
				Обратите внимание, что при уменьшении мантиссы до нуля порядок числа
				сохраняется. Например, если исходно было 1.<sup>|&minus;20</sup>, то после
				преобразования будет 0.0000001<sup>|&minus;13</sup>, а после уменьшения
				станет 0.000000<strong>0</strong><sup>|&minus;13</sup>, т.&#8239;е.
				<span class="code"> 0.      -13</span>.
				Правда такой ноль, кроме необычного вида, в операциях ничем от
				простого нуля не отличается. Но в сочетании с другими
				недокументированными возможностями, которые могут объединить
				мантиссу и порядок от разных чисел
				(см. <a href="#id_x2_exp_combine">Таинственный регистр X2</a>)
				это может пригодится.
				Таким же образом из 1.<sup>|+90</sup> получается
				<span class="code"> 0.        97</span>.
			</p>
		</details>

		<hr>

		<details id="id_indirect_addr_R4" open="open">
			<summary><h3>Регистры R4&hellip;R6</h3></summary>
			<p>
				Для них преобразованное значение
				предварительно увеличивается на 1, так же без учёта порядка и знака.
				При этом, если было &minus;99999999 (все девятки), то преобразуется в ноль.
				Например, &minus;9, или &minus;99 преобразуется в 00000000.
				По аналогии с замечания для отрицательных чисел, число
				+99999999 (все девятки) преобразуется в число с цифрой на месте знака:
				<span class="code">200000000.   </span> (на месте знака
				стоит 2). Оно ведёт себя как обычный ноль. Примеры:
			</p>
			<p>
				<span class="code"> 123.        </span>,
				что представляется как 1.23<sup>|+02</sup>,
				перейдёт в 0.0000123<sup>|+07</sup>, затем
				увеличится до 0.000012<strong>4</strong><sup>|+07</sup> и превратится в
				<span class="code"> 00000124.   </span>, т.&#8239;е.
				адрес перехода = 24.
				<br>
				<span class="code"> 1.23     -02</span>,
				что представляется как 1.2300000<sup>|&minus;02</sup>, увеличится до
				1.230000<strong>1</strong><sup>|+02</sup> превратится в
				<span class="code"> 1.2300001-02</span>, т.&#8239;е. адрес перехода = 01.
				<br>
				<span class="code">-123.        </span>,
				что представляется как &minus;1.23<sup>|+02</sup>
				преобразуется в &minus;9.9999123<sup>|+07</sup>,
				затем увеличится до &minus;9.999912<strong>4</strong><sup>|+07</sup>,
				превратится в <span class="code">-99999124.   </span>,
				т.&#8239;е. адрес перехода = 24.
				<br>
				<span class="code">-1.2345678-08</span>,
				преобразуется в &minus;9.9999123<sup>|&minus;03</sup>,
				затем увеличится до &minus;9.999912<strong>4</strong><sup>|&minus;03</sup>,
				превратится в
				<span class="code">-9.9999124-03</span>, т.&#8239;е. адрес перехода = 24.
			</p>
		</details>

		<hr>

		<details id="id_indirect_addr_FL0" open="open">
			<summary><h3>
				Команды <span class="but_f">F</span><span class="op_f">L0</span><!--No space
				-->&hellip;<span class="but_f">F</span><span class="op_f">L3</span>
			</h3></summary>
			<p>
				Для них действуют те же правила, что для
				регистров R0&hellip;R3, только перед уменьшением проверяется, что
				полученное число не равно единице (опять же без учёта знака и порядка).
				В случае, если получится единица, происходит завершение цикла и
				преобразованное значение НЕ записывается обратно в регистр. Примеры:
			</p>
			<p>
				<span class="code"> 123.        </span>,
				что представляется как 1.23<sup>|+02</sup>,
				перейдёт в 0.0000123<sup>|+07</sup>,
				затем уменьшится до 0.000012<strong>2</strong><sup>|+07</sup> и
				превратится в <span class="code"> 00000122.   </span>,
				цикл продолжается.
				<br>
				<span class="code"> 1.23     -02</span>,
				что представляется как 1.2300000<sup>|&minus;02</sup>
				уменьшится до 1.2<strong>299999</strong><sup>|&minus;02</sup>,
				превратится в <span class="code"> 1.2299999-02</span>,
				цикл продолжается.
				<br>
				<span class="code"> 1.23        </span>,
				преобразуется в 00000001, равно единице &ndash; цикл завершится, а
				исходное число не изменится, т.&#8239;е. останется
				<span class="code"> 1.23        </span>.
				<br>
				<span class="code"> 1.23     -10</span>,
				что представляется как 1.23<sup>|&minus;10</sup>,
				преобразуется до 0.0000001<sup>|&minus;03</sup>,
				равно единице &ndash; цикл завершится, а исходное число не изменится.
			</p>
			<p>
				Проверить <q>на единицу</q> исходное можно через регистры R7&hellip;Re.
				Если после
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">R</span>
				на экране мантисса будет 00000001 (и где-то точка), то значит
				цикл прервётся на исходном числе.
			</p>
		</details>

		<hr>

		<details id="id_indirect_addr_mantissa" open="open">
			<summary><h3>Мантисса содержит шестнадцатеричные цифры</h3></summary>
			<p>
				В этом случае <strong>уменьшение</strong> шестнадцатеричной цифры
				идёт до 9, а затем, как обычно. При уменьшении ниже 0 идёт заём
				(уменьшение на 1 предыдущей, возможно шестнадцатеричной цифры),
				при это текущая цифра будет не F, а, как обычно, 9.
			</p>
			<p>
				Переход так же будет на шестнадцатеричный адрес, но с этим мы уже
				знакомы
				(см. <a href="#id_addr_space">Программное адресное пространство</a>).
			</p>
			<p>
				К сожалению, если идёт <strong>увеличение</strong>, то число с
				шестнадцатеричными цифрами предварительно подвергается
				<a href="#is_glos_normalization">нормализации</a> (справа налево,
				смысл как указано в списке терминов):
				буквы считаются как двузначные, с переносом лишней единицы в
				старший разряд. Например, сложение числа 9AE и 1 будет так: E = 14,
				значит последняя цифра 4 + 1 = 5 и 1 <q>в уме</q>;
				затем A = 10 + 1 в уме, будет 11, т.&#8239;е. 1 и 1 в уме;
				далее 9 + 1 = 10. Итого 1015. Это значит, что косвенная адресация
				через R4&hellip;R6 всегда уберёт шестнадцатеричные цифры из числа.
				При этом нестандартный знак числа (см. замечание в варианте для
				отрицательных чисел) остаётся.
			</p>
		</details>

		<hr>

		<details id="id_indirect_addr_exponent" open="open">
			<summary><h3>Порядок содержит шестнадцатеричные цифры</h3></summary>
			<p>
				На самом деле без Еггогологии можно получить только 1.<sup>|&plusmn;HH</sup>,
				используя оператор
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>.
			</p>
			<p>
				Для чисел вида 1.<sup>|+0H</sup> (одна цифра) никаких преобразований не
				производится, а значит адрес перехода всегда будет нулевым.
				Если идёт увеличение или уменьшение (через выбор регистра),
				то мантисса увеличивается или уменьшается в соответствии с правилами выше,
				а знак и порядок не меняется.
				Пример: если в регистр R0 записать
				<span class="code"> 1.        0E</span>
				и выполнить
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">0</span>,
				то результатом станет уменьшение мантиссы 100000000 до 09999999,
				т.&#8239;е. <span class="code"> 0.9999999 0E</span>.
			</p>
				Для чисел вида 1.<sup>|&minus;0H</sup> (тоже одна цифра) так же никаких
				преобразований не производится. Единственное, хочу заострить внимание
				на значении такого числа. В этом случае порядок подразумевается
				по модулю 16, т.&#8239;е. &minus;E, это &minus;14 или 2. Получается, что
				1.<sup>|&minus;0E</sup> = 100, 1.<sup>|&minus;0D</sup> = 1000,
				1.<sup>|&minus;0C</sup> = 10000, 1.<sup>|&minus;0B</sup> = 100000,
				а&hellip; 	1.<sup>|&minus;0A</sup> не
				получается (будет сразу 1.<sup>|&minus;10</sup>, им и останется).
			<p>
			</p>
			<p>
				Для двузначных чисел порядка ситуация похожая. Возьмём,
				для примера, 1.<sup>|+B0</sup>
				(<span class="code"> 1.       L0</span>).
				Кстати, 1.<sup>|+AA</sup> будет автоматически переведено в 1.<sup>|+B0</sup>,
				как и 1.<sup>|+0A</sup> будет автоматически переведено в 1.<sup>|+10</sup>
				(чем-то именно A не нравиться, для остальных цифр такого не замечено,
				хотя и тут можно обмануть, если для 1.<sup>|&minus;BB</sup> набрать
				<span class="but">ВП</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">5</span>).
				Здесь, как и для обычных положительных порядков, будет дописано
				7 &minus; 0 = семь нулей, число должно превратиться в
				0.0000001<sup>|+B7</sup>, но фактически при изменении порядка он (порядок)
				будет нормализован и станет +117, что приведёт к 0.0000001<sup>|+117</sup>.
				Т.&#8239;е. в качестве адреса перехода будет 01, но само число из регистра
				уже лучше не извлекать, т.&#8239;к. оно будет сверхчислом и на экране
				отображаться как <span class="code"> ЕГГ0Г      </span>.
				Аналогично у числа 1.<sup>|+B1</sup> допишется 7 &minus; 1 = 6 нулей,
				число станет 0.0000010<sup>|+117</sup>, т.&#8239;е. адрес перехода = 10 и число
				по-прежнему не стоит извлекать.
			</p>
			<p>
				Если у двузначных чисел порядок отрицательный, то срабатывает
				<dfn>правило <q>сумма = 160</q></dfn>, это значит, что внутренне
				порядок меняется на
				число по модулю 160. Для примера, возьмём 1.<sup>|&minus;C0</sup>
				(<span class="code"> 1.       -C0</span>).
				Это эквивалентно 1.<sup>|&minus;120</sup>, а по правилу <q>сумма = 160</q>,
				как 1.<sup>|+40</sup>.
				Используя правило преобразования для чисел больше единицы, получаем,
				что число будет преобразовано в 0.0000001<sup>|+47</sup>, соответственно
				адрес перехода 01, а полученное после косвенной адресации число можно
				просто извлечь из регистра: будет
				<span class="code"> 0.0000001 47</span>
				Для сравнения, если взять 1.<sup>|&minus;C1</sup>, то
				правило <q>сумма = 160</q>,
				приведёт к 1.<sup>|+39</sup>, что не поддаётся преобразованию (9 &gt; 7),
				а значит само число после косвенной адресации не изменится и останется
				<span class="code"> 1.       -C1</span>
				(адрес перехода равен 00). И, да, к этому числу можно прибавить 0,
				чтобы увидеть
				<span class="code"> 1.        39</span>.
				Да, для 1.<sup>|&minus;C1</sup> можно применить правила косвенной адресации
				для отрицательных степеней, и понять, что преобразования не будет, т.&#8239;к.
				7 + 1 не меньше восьми. И для 1.<sup>|&minus;C0</sup> это правило так
				же укажет на необходимость дописать 7 + 0 = 7 нулей, но вот
				порядок будет преобразован по выше указанному правилу =160.
			</p>
			<p>
				У правила <q>сумма = 160</q> возникает ещё один интересный побочный эффект.
				Детали см. в разделе
				<a href="#id_neg_zero_degree">Числа с отрицательной нулевой степенью</a>.
			</p>
			<p>
				Если идёт увеличение или уменьшение (через выбор регистра), то мантисса
				увеличивается или уменьшается в соответствии с правилами,
				уже описанными разделами выше.
			</p>
		</details>

		<hr>

		<details id="id_indirect_addr_reg" open="open">
			<summary><h3>Значение &ndash; номер регистра, а не адрес</h3></summary>
			<p>
				Если косвенное значение используется для вычисления регистра,
				то его номер так же определятся двумя последними
				цифрами, разбиваясь на два варианта,
				когда первая цифра нулевая, и когда нет:
			</p>
			<table class="center">
				<tr><th>Первая ноль</th><th>Первая НЕ ноль</th></tr>
				<tr><td>00&rarr;R0</td><td>#0&rarr;Ra</td></tr>
				<tr><td>01&rarr;R1</td><td>#1&rarr;Rb</td></tr>
				<tr><td>02&rarr;R2</td><td>#2&rarr;Rc</td></tr>
				<tr><td>03&rarr;R3</td><td>#3&rarr;Rd</td></tr>
				<tr><td>04&rarr;R4</td><td>#4&rarr;Re</td></tr>
				<tr><td>05&rarr;R5</td><td>#5&rarr;R0</td></tr>
				<tr><td>06&rarr;R6</td><td>#6&rarr;R0</td></tr>
				<tr><td>07&rarr;R7</td><td>#7&rarr;R1</td></tr>
				<tr><td>08&rarr;R8</td><td>#8&rarr;R2</td></tr>
				<tr><td>09&rarr;R9</td><td>#9&rarr;R3</td></tr>
				<tr><td>0A&rarr;Ra</td><td>#A&rarr;R4</td></tr>
				<tr><td>0B&rarr;Rb</td><td>#B&rarr;R5</td></tr>
				<tr><td>0C&rarr;Rc</td><td>#C&rarr;R6</td></tr>
				<tr><td>0D&rarr;Rd</td><td>#D&rarr;R7</td></tr>
				<tr><td>0E&rarr;Re</td><td>#E&rarr;R8</td></tr>
				<tr><td>0F&rarr;R0</td><td>#F&rarr;R9</td></tr>
			</table>
		</details>

		<hr>

		<details id="id_indirect_addr_using" open="open">
			<summary><h3>Практическое использование</h3></summary>
			<p>
				Вот пример использования знаний косвенной адресации для
				номеров регистров: программа заполняет регистры R0&hellip;R3
				инвертированными случайными числами, при этом используется
				только один регистр R0.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
					<td><span class="but">02</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Ещё практических советов. Уменьшение шестнадцатеричной цифры для БЗ-34
				было единственным способом из цифры E получить остальные цифры.
				В МК-61 с приходом бинарных операций стало проще, но т.&#8239;к. первая цифра
				всё ещё не во власти этих операций, то через косвенную адресацию
				получается быстрее, чем через дробную часть и ввод порядка.
			</p>
			<p>
				Особенность не уменьшения числа по окончании цикла, с учётом того,
				что фактически число может сильно отличаться от единицы
				(см. пример выше) позволяет использовать команды FLx для быстрой
				проверки значения регистра с одновременным переходом при удаче/неудаче.
			</p>
		</details>

	</details>

	<hr>

	<details id="id_x2" open="open">
		<summary><h2>Таинственный регистр X2</h2></summary>
		<p>
			Такой регистр действительно не упоминается в документации. В
			действительности этот тот регистр, содержимое которого отображается на
			дисплее при остановке ПМК. Поэтому его иногда называют <em>экранным</em> регистром.
		</p>
		<p>
			В документации указано, что таковым является регистр X, но это не так.
			В режиме вычислений после каждой команды содержимое регистра X сразу же
			копируется в X2. И поэтому разницы между ними нет.
			При таком копировании производятся дополнительные проверки
			(например, на предмет переполнения).
			Видимо в целях экономии в программном режиме при выполнении
			большинства(!) команд такое копировании не производится.
			Более того (а это и есть самое полезное), некоторые команды позволяют
			сделать и обратное копирование.
		</p>

		<hr>

		<details id="id_x2_affect" open="open">
			<summary><h3>X2-влияющие команды</h3></summary>
			<p>
				Для начала опишем список команд, которые копируют в программном режиме
				содержимое X в X2 (после выполнения, конечно). Назовём такие команды
				<dfn>X2-влияющие</dfn>.
				<strong>Безусловно</strong> выполняют копирование X&rarr;X2 следующие команды:
			</p>
			<ul>
				<li>
					ввод числа (после ввода каждой цифры, в том числе и разделителя
					<span class="but">.</span>), а также команды
					<span class="but">ВП</span> и <span class="but">/-/</span>.
				</li>
				<li style="padding: 3px 0">
					<span class="but_cx">Сx</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but">В&uarr;</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">Вx</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_b">С/П</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_b">В/О</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_b">П&rarr;x</span><span class="but">R</span> (R = 0&hellip;F)
				</li>
				<li style="padding: 3px 0">
					<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>
					(R = 0&hellip;F)
				</li>
				<li style="padding: 3px 0">
					пустые операторы с кодами F0&hellip;FF
				</li>
				<li style="padding: 3px 0">
					все команды, генерирующие ошибку (в силу перехода в режим вычислений),
					например,
					27(<span class="but_k">К</span><span class="but">-</span>),
					28(<span class="but_k">К</span><span class="but">&times;</span>),
					29(<span class="but_k">К</span><span class="but">&divide;</span>),
					2B&hellip;2E, 3C и стандартные операции при генерации ошибок.
				</li>
			</ul>
			Выполняют копирование только <strong>при НЕ переходе на адрес</strong>
			следующие команды:
			<ul>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x&lt;0</span>
					(команда <span class="but_k">К</span><span class="op_f">x&lt;0</span>
				 &ndash; никогда НЕ влияет на X2)
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x=0</span> (команда
					<span class="but_k">К</span><span class="op_f">x=0</span> &ndash;
					никогда НЕ влияет на X2)
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x&ge;0</span> (команда
					<span class="but_k">К</span><span class="op_f">x&ge;0</span> &ndash;
					никогда НЕ влияет на X2)
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">x&ne;0</span> (команда
					<span class="but_k">К</span><span class="op_f">x&ne;0</span> &ndash;
					никогда НЕ влияет на X2)
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L0</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L1</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L2</span>
				</li>
				<li style="padding: 3px 0">
					<span class="but_f">F</span><span class="op_f">L3</span>
				</li>
			</ul>
			Для условных операторов это означает, что копирование X&rarr;X2
			производится, когда условие выполняется. Для циклов &ndash; когда
			цикл завершается.
			<p>
				Остальные операторы НЕ копируют X в X2. А это, например, означает, что
				регистр X во время таких операций может содержать сверхчисло
				(больше или равно 10.<sup>|+100</sup>).
				При этом, конечно, нужно учитывать, чтобы команда сам по себе не делала
				такую проверку на переполнение.
				Например,
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span> делает
				проверку параметра перед выполнением, а
				<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
				&ndash; нет.
				Для пояснения рассмотрим такую программу:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">5</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">x=0</span></td>
					<td><span class="but">07</span></td>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				Можно увидеть, что на шаге 04 в регистре X возникает сверхчисло.
				Причём оператор
				<span class="but_f">F</span><span class="op_f">x=0</span>
				не выполняется, т.&#8239;е. идёт переход на адрес 07 (как адрес перехода).
				В соответствии с таблицей выше, в этом случае копирование X в X2
				не происходит, а значит, ошибки не должно возникать.
				В чем легко убедиться, запустив программ.
				Но если в программе заменить оператор на
				<span class="but_f">F</span><span class="op_f">x&ne;0</span>,
				то условие уже будет выполняться, и будет выполняться копирование
				X в X2, которое приведёт к ошибке.
				Что так же проверяется запуском программы.
			</p>
			<p>
				Хочу отметить, что команда <span class="but_b">В/О</span> также
				является X2-влияющей, т.&#8239;е. если перед возвратом из подпрограммы
				в регистре X будет сверхчисло, то произойдёт остановка по ошибке,
				причём возврат успеет отработать, т.&#8239;е. остановка будет на адресе
				сразу после вызова подпрограммы.
			</p>
			<p>
				Многие считают, что ненормализованное число (у которого ведущие нули,
				образующиеся при косвенной адресации) автоматически
				нормализуется при выполнении любой следующей команды.
				Так вот, это не так. Если команда не меняет число
				(переходы, стековые операции и т.&#8239;п.), то нормализация
				происходит только если команда является X2-влияющей.
				Если идёт сохранение в регистр памяти, то там конечно, число
				будет в нормализованном виде, но это уже особенность самой
				команды сохранения, т.&#8239;к. в RX число останется ненормализованным.
				К тому же сказывается ещё и то, что при остановке
				(выхода из режима выполнения программы)
				ячейки стека автоматически нормализуются. Это значит,
				что даже если вы видите на экране
				<span class="code"> 00000001.   </span>, то фактически в регистре X
				уже нормализованная единица.
			</p>
			<p>
				Всё это не имело бы практического смысла, если бы не было команд,
				которые делают обратное копирование X2&rarr;X.
			</p>
		</details>

		<hr>

		<details id="id_x2_point" open="open">
			<summary><h3>Команда <span class="but">.</span> (код 0A)</h3></summary>
			<p>
				Данная команда в программном режиме восстанавливает в регистре X
				значение X2 (за исключением случая, когда идёт обычный ввод числа,
				например, 1.23, в этом случае поведение полностью соответствует
				документации и эквивалентно режиму вычислений). При этом содержимое
				стека не меняется. Также команда ничего не делает после X2-влияющей
				команды, но это и логично.
				На практике такую команду чаще всего используют для экономии регистров,
				реже &ndash; когда требуется ввод без изменения стека.
				<br>
				Пример: проверка битового флага и если его нет, то его установка.
				Пусть в R9 хранится некое число для работы с битами, а в R1 хранится бит
				для проверки, тогда следующий фрагмент сначала сделает проверку
				доступности бита, а при недоступности, сделает его установку:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">1</span></td>
					<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">77</span></td>
					<td colspan="4"></td>
				</tr>
				<tr>
					<th colspan="11">&hellip;</th>
				</tr>
				<tr>
					<th>&#8202;70&#8202;|&#8202;</th>
					<td colspan="7"></td>
					<td><span class="but">.</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
				</tr>
			</table>
			<p>
				Получается, что оператор <span class="but">.</span> по адресу 77
				восстановит R1 в X без сдвига стека, что позволит сразу выполнить
				бинарную операцию. Обычно само значение из R1 <q>вычислено</q>, а не
				хранится в регистре. Обратите внимание, что выбрана не X2-влияющая
				проверка с переходом.
			</p>
			<p>
				Ещё пример &ndash; использовать оператор <span class="but">.</span> как
				входной параметр подпрограммы, т.&#8239;е. эта команда стоит первым оператором.
				В этом случае например, учитывая что команда
				<span class="but_b">С/П</span> всегда копирует X в X2,
				после ввода пользователя сначала выполняются некие вычисления,
				не затрагивающие X2 (в том числе
				сохранение этих результатов в регистры), а затем вызов подпрограммы,
				которая таким образом <q>видит</q> ввод пользователя.
			</p>
			<p>
				Обращаю внимание, что сама команда <span class="but">.</span>
				является X2-влияющей, т.е. если X2 было ненормализованным, то
				после восстановления число автоматически нормализуется.
				Т.&#8239;е. в отличие от
				<span class="but_b">П&rarr;x</span><span class="but">R</span>
				восстановленное число будет безусловно нормализованным, а значит,
				формально это будет уже другое X2.
			</p>
		</details>

		<hr>

		<details id="id_x2_exp" open="open">
			<summary>
				<h3>Команда <span class="but">ВП</span> (код 0C)</h3>
			</summary>
			<p>
				Для этой команды существуют несколько условий и правил восстановления.
				Обращаю внимание, что после X2-влияющей команды она ведёт себя как
				обычно (как документировано). Причём даже если она используется
				нестандартно (и выполнит некое восстановление), то всё равно после её
				выполнения ввод цифр будет восприниматься как ввод порядка.
			</p>

			<hr>

			<details id="id_x2_exp_SR" open="open">
				<summary>
					<h4>Восстановление X2 с отбрасыванием первой цифры</h4>
				</summary>
				<p>
					Это выполняется после последовательности операторов
					<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
					<span class="but">ВП</span>,
					где R &ndash; любой регистр памяти. При этом текущее содержимое
					регистра X теряется, без изменения стека. Вместо
					<span class="but_b">x&rarr;П</span><span class="but">R</span>
					может быть и команда
					<span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">R</span>.
				</p>
				<p>
					Пример. Пусть нам нужно обработать ввод выбора пользователя для
					перемещения в некоем трёхмерном лабиринте. Обычно используются клавиши
					2,4,6,8,&plusmn;5 (что соответствует направлению движения).
					Рассмотрим такую последовательность (в предположении, что выбор
					пользователя хранится в регистре R9 и значение 0 имеет ещё
					какой-то дополнительный смысл):
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td><span class="but">2</span></td>
						<td><span class="but">&divide;</span></td>
						<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
						<td><span class="but">77</span></td>
						<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
						<td><span class="but">+</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_f">F</span><span class="op_f">x=0</span></td>
					</tr>
					<tr>
						<th>&#8202;10&#8202;|&#8202;</th>
						<td><span class="but">55</span></td>
						<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td colspan="8"></td>
					</tr>
				</table>
				<p>
					Что здесь происходит? На шаге два мы получим одно из чисел
					1, 2, 3, 4, &plusmn;2.5 или 0. Условным оператором мы не только
					отсекаем вариант с нулём, но делаем X&rarr;X2. Далее к полученному
					числу сразу прибавляем <span class="pi">&pi;</span> и сохраняем в R9
					для дальнейшей косвенной
					адресации (пусть в R4&hellip;R7 хранятся коэффициенты умножения для
					выполнения движения). Обращаю внимание, что тут использованы не
					X2-влияющие команды. После команды <span class="but">ВП</span> мы
					<q>восстановим</q> в X то значение, что было после деления на шаге 02,
					только без первой цифры, т.&#8239;е. ноль (для 1&hellip;4) или &plusmn;0.5,
					чтобы использовать это для последующего ветвления программы
					(умножение на коэффициент деления, а для &plusmn;0.5 можно будет
					взять знак числа и т.&#8239;д.). Без использования <span class="but">ВП</span>
					потребовалось бы использовать или дополнительный
					регистр, или дополнительные команды по манипуляции со стеком.
				</p>
				<p>
					Дополнительные условия. <strong>Если</strong> содержимое X2
					равно <strong>нулю</strong>,
					то будет восстановлена <strong>единица</strong>, точнее
					единица будет на месте первой цифры нулевого значения,
					т.&#8239;е. если X2 было ненормализованным нулём, то результат
					будет уже не 1. Пример ниже выдаст в результате
					<span class="code"> 10000000.   </span>:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_cx">Cx</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="3"></td>
					</tr>
				</table>
				<p>
					<strong>Если</strong> в момент восстановления (выполнения команды
					<span class="but">ВП</span>) содержимое
					регистра <strong>X меньше нуля</strong>,
					то вместо удаления первой цифры у числа X2,
					она будет <strong>заменена на 9</strong>.
					<br>
					Например, после выполнения программы
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
						<td><span class="but">/-/</span></td>
						<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
						<td><span class="but">&times;</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="3"></td>
					</tr>
				</table>
				<p>
					на экране будет <span class="code">-9.1415926   </span> в
					R9 будет &minus;<span class="pi">&pi;</span> &times; <span class="pi">&pi;</span>
					(команда по адресу 01 X2-влияющая).
				</p>
				<p>
					С учётом знаний по <a href="#id_glos_zero_digit">знакоцифрам</a>
					можно провести более точное правило: эта последовательность
					при восстановлении X2 первую цифру меняет на
					знакоцифру числа в регистре X минус 1, а если исходное X2
					равно нулю, то ещё и увеличивает первую цифру на 1.
					Тогда получается:
				</p>
				<ol>
					<li>
						X2 не ноль. Число X больше нуля, знакоцифра X равна единице,
						значит первая цифра X2 при восстановлении заменяется на ноль, т.&#8239;е.
						удаляется. За исключением случая, когда X2 было ненормализованным,
						т.&#8239;е. первая цифра и так была нулём.
					</li>
					<li>
						X2 не ноль. Число X меньше нуля, с минусом, знакоцифра
						X равна 10 (A), значит первая цифра X2 при
						восстановлении заменяется на 9.
					</li>
					<li>
						Число X2 равно нулю. В этом случае так же первая цифра
						заменяется на знакоцифру числа X минус один, но
						потом увеличивается на 1.
						Итого первой цифрой будет единица для X &gt;= 0, или
						цифра А = 10, для X &lt; 0. Если X2 не было нормализовано, то
						остальные цифры восстановятся как было.
					</li>
				</ol>
				<p>
					Для последнего правила приведём пример:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
						<td><span class="but">/-/</span></td>
						<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="1"></td>
					</tr>
				</table>
				<p>
					Здесь на шаге 04 происходит не только уменьшение R0 до нуля,
					но и извлечение это ненормализованного нуля (X2-влияющая команда).
					Команда по адресу 05 подгоняет в регистр X отрицательное
					значение и при восстановлении получится
					<span class="code"> -0000000.   </span>, где знакоцифра
					A (минус) сначала уменьшается на один, а потом снова
					увеличивается и копируется в первый разряд. Это число численно равно
					1.0<sup>|&plus;08</sup> (см. раздел с шестнадцатеричной
					арифметикой). Для наглядности можно ещё нажать
					<span class="but">/-/</span>, получится
					<span class="code">--0000000.   </span>.
					<br>
					Последнее само по себе тоже интересно. Если провести
					его косвенное увеличение через R4&hellip;R6, то как уже
					указано в разделе по косвенной адресации,
					для этих регистров сначала пройдёт
					нормализация числа с переносом старшего разряда (единицы,
					поскольку A = 10) в знакоцифру, которая была минусом (число 10),
					а ещё плюс один сделает уже 11, что снова вызовет перенос лишней
					единицы (уже в никуда), оставив только 1 на месте знакоцифры,
					т.&#8239;е. просто пусто (неотрицательное число).
					А мантисса останется их одних нулей, значит она увеличится на один,
					что приведёт к содержимому R4&hellip;R6 в виде
					<span class="code"> 00000001.   </span>. Для R0&hellip;R3
					нормализации не будет, но при уменьшении &minus;1.0<sup>|&plus;08</sup>
					превратиться в -99999999. Для R7&hellip;Re ничего не
					произойдёт.
				</p>
				<p>
					Интересно, что для последнего примера может подойти только
					ненормализованное число, потому что нормализованный
					"минус ноль" не удастся получить в регистре X2,
					т.&#8239;к. X2-влияющие команды  нормализуют числа, и при
					сохранении в регистры числа тоже нормализуются.
				</p>
				<p>
					Так же хочу напомнить, что команда
					<span class="but">ВП</span> X2-влияющая, а это значит,
					что если второй раз сделать
					<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
					<span class="but">ВП</span>, то учитываться будет уже знак
					восстановленного значения X. В частности, для программы выше,
					если в конце ещё добавить
					<span class="but_b">x&rarr;П</span><span class="but">8</span>&ensp;
					<span class="but">ВП</span>,
					то получим уже ноль, т.&#8239;к. в неотрицательном
					<span class="code"> -0000000.   </span> первая цифра
					заменится на ноль.
				</p>
				<p>
					Ещё интересный пример, использующий ненормализованность чисел
					в необычном контексте. Пусть вводом пользователя является
					некоторое двузначное число (координаты) и вы
					последовательностью
					<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
					<span class="but">ВП</span> не только сохраняете
					ввод, а также сразу
					отбрасываете десятки. Но часто в таких случаях однозначное
					число подразумевает нулевой десяток, и эта
					последовательность уберёт эту единственную цифру. Что же
					делать? Оказывается, ввод пользователя с ведущим нулём
					оставляет X2 ненормализованным, с тем самым нулём. Т.&#8239;е.
					достаточно вместо числа 3, вводить 03 и всё снова заработает
					&ndash; будет отброшен незначащий ноль.
					Для примера приведём программу, которая входное положительное
					двузначное число разделит на десятки (будет в регистре Y)
					и единицы (будет в регистре X). Вводить нужно всегда две
					цифры, возможно с ведущим нулём.
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but">-</span></td>
						<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="3"></td>
					</tr>
				</table>
			</details>

			<hr>

			<details id="id_x2_exp_combine" open="open">
				<summary>
					<h4>Восстановление X2 с заменой первой цифры на цифру из числа в X</h4>
				</summary>
				<p>
					Как правило это наиболее интересная последовательность.
					Она позволяет нестандартно сочетать два числа.
				</p>
				<p>
					Рассмотрим последовательность
					<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
					<span class="but">ВП</span>.
					При этом <span class="but_k">К</span><span class="op_k">НОП</span> взята как
					более нейтральная, могут быть и другие не X2-влияющие команды,
					назовём это первой командой. Тут важно учитывать:
				</p>
				<ol>
					<li>
						В качестве образца первой цифры берётся содержимое X до(!)
						начала данной последовательности.
					</li>
					<li>
						Если вместо <span class="but_k">К</span><span class="op_k">НОП</span>
						стоит другая не X2-влияющая команда, то она выполняется, но
						результат её выполнения (содержимое X) будет потерян. При этом стек
						будет иметь состояние как после выполнения команды.
					</li>
					<li>
						Если первая команда &ndash; это переход на другой адрес, то она
						выполнится и последовательность с <span class="but">ВП</span>
						будет нарушена. Но если <span class="but">ВП</span> расположена
						по адресу, куда идёт переход, то сработает, при условии, что
						переход не X2-влияющий. Для косвенных переходов сложнее - см. ниже.
					</li>
					<li>
						Если первая команда генерит ошибку, то снова последовательность
						с <span class="but">ВП</span> будет нарушена.
					</li>
					<li>
						Если первая команда это
						<span class="but_b">x&rarr;П</span><span class="but">R</span>, то будет
						выполнено по правилу, описанному выше, с отбрасыванием первой цифры.
					</li>
				</ol>
				<p>
					Пример:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
						<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
						<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
						<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="2"></td>
					</tr>
				</table>
				<p>
					В результате получим <span class="code">1.ELE-6Г9   </span>.
					Тут дробная часть понятна &ndash; это инверсия числа <span class="pi">&pi;</span>
					которое
					сохраняется X2-влияющей командой по адресу 03. А интересна тут
					цифра 1 на первом месте, которая появилась в стеке по команде
					<span class="but_k">К</span><span class="op_k">ЗН</span>.
					Именно она подставляется вместо восьмерки при восстановлении.
				</p>
				<p>
					Интересно, что первой цифрой может быть и шестнадцатеричная, тем
					самым можно получить то, что в режиме вычислений трудно сделать.
					Например,
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">9</span></td>
						<td><span class="but_f">F</span><span class="op_f">1/x</span></td>
						<td><span class="but">5</span></td>
						<td><span class="but">&times;</span></td>
						<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
						<td><span class="but">/-/</span></td>
						<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
					</tr>
					<tr>
						<th>&#8202;10&#8202;|&#8202;</th>
						<td><span class="but">/-/</span></td>
						<td><span class="but">9</span></td>
						<td><span class="but">9</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="6"></td>
					</tr>
				</table>
				<p>
					Будет 10(!) минусов.
					<span class="code">--.--------99</span>. Тут
					X2-влияющая команда по адресу 06 <q>фиксирует</q> 8.AAAAAAA
					(заодно добавляя минус), а оператор дробной части оставляет на
					первом месте тоже цифру A. Всё это последовательность с
					<span class="but">ВП</span> успешно объединяет, а
					порядок &minus;99 в конце дописывается для красоты. Хочу снова
					повторить, что даже восстанавливая, команда
					<span class="but">ВП</span> сохраняет контекст своего
					исполнения, т.&#8239;е. после неё ожидается ввод порядка.
					Это отличается, например, от команды <span class="but">.</span>,
					которая после восстановления не подразумевает ввод дробной
					части числа.
				</p>
				<p>
					Ещё пример. Пусть нужна подпрограмма, которая из первой цифры
					(целой части) дробного числа в регистре X делает букву.
					Например, 1&rarr;E, 2&rarr;D, &hellip; 4&rarr;A.
					В режиме вычислений для этого подошла бы последовательность
					(в реальной подпрограмме первый
					<span class="but_k">К</span><span class="op_k">НОП</span>
					не нужен, а вместо <span class="but_b">С/П</span> должно
					стоять <span class="but_b">В/О</span>, но в таком виде
					это можно сразу ввести и попробовать).
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but">0</span></td>
						<td><span class="but">+</span></td>
						<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
						<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
						<td><span class="but_b">С/П</span></td>
					</tr>
				</table>
				<p>
					С учётом специфики выполнения команды <span class="but">ВП</span> в
					программном режиме нужно ещё скопировать X&rarr;X2 после команды
					<span class="but_k">К</span><span class="op_k">{x}</span>, т.&#8239;е.
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but">0</span></td>
						<td><span class="but">+</span></td>
						<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
						<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
						<td><span class="but">В&uarr;</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					</tr>
					<tr>
						<th>&#8202;10&#8202;|&#8202;</th>
						<td><span class="but_b">С/П</span></td>
						<td colspan="9"></td>
					</tr>
				</table>
				<p>
					Это +1 команда, к тому же стек будет испорчен. Рассмотрим
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
						<td><span class="but">+</span></td>
						<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
						<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="1"></td>
					</tr>
				</table>
				<p>
					Здесь, благодаря восстановлению единицы (шаг 01), на шаге 07,
					останется только одна шестнадцатеричная цифра.
					Так недокументированная последовательность сделала подпрограмму
					короче на два шага.
				</p>
				<p>
					Нужно понимать, что если число в X2 ненормализованное, то всё равно
					заменяется только первая цифра. Воспользуемся знаниями
					косвенной адресации:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">4</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">7</span></td>
						<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span></td>
						<td><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="2"></td>
					</tr>
				</table>
				<p>
					В данном случае 4 после косвенного перехода становится 00000004,
					а значит замена первой цифры приведёт к
					<span class="code"> 40000004.   </span>,
					в чем легко убедиться, запустив программу.
				</p>
				<p>
					Теперь рассмотрим особенности. Если число <strong>X</strong>
					до начала последовательности <strong>было нулём</strong>, то
					вместо первой цифры
					устанавливается <strong>ноль</strong>.
					Обычно это значит, что число будет без первой
					цифры (начальный ноль не значащий). Но если он уже и так там был
					(например, число &ndash; это результат косвенной адресации с
					ведущими нулями), тогда никаких полезных действий не будет.
					Впрочем, иногда, именно это различие можно использовать, чтобы
					узнать, выполнялась ли косвенная адресация или нет.
				</p>
				<p>
					Если <strong>X2 нулевое</strong>, то тут как бы проявляется
					известный трюк с <span class="but">ВП</span>, которая 0
					автоматически превращает в 1 (для ввода порядка).
					Фактически, в этом случае, первая цифра числа X увеличивается
					на 1. Вот фрагмент:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">0</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="4"></td>
					</tr>
				</table>
				<p>
					Если на вход этой программе дать 5, то выдаст 6. А если 9, то
					выдаст&hellip; A(!), потом аналогично B, C, D, E, F. Впрочем,
					последнее лучше тут же заменить на 0 и прочистить стек &ndash;
					пустышки коварны (во всяком случае, если на вход передать F, то
					программа однозначно будет перекручена во что-то неузнаваемое).
					Ещё пример:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_f">F</span><span class="op_f">1/x</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="6"></td>
					</tr>
				</table>
				<p>
					На вход
					<span class="code">-9.          </span>,
					на выходе первая цифра от обратной величины
					<span class="code">-1.          </span>.
				</p>
			</details>

			<hr>

			<details id="id_x2_exp_plus" open="open">
				<summary>
					<h4>Использование <span class="but">ВП</span> как сложение</h4>
				</summary>
				<p>
					Редкий случай, скорее для информации только. Последовательность
					<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
					<span class="but">ВП</span>&ensp;
					<span class="but">ВП</span> при <strong>нулевом значении X2</strong>,
					сначала, как и описывалось ранее, увеличит X
					на единицу, а второе <span class="but">ВП</span> уже на величину
					цифры, которая была до увеличения. Добавление ещё команд
					<span class="but">ВП</span> уже ничего не меняют. Пример:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">0</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="3"></td>
					</tr>
				</table>
				<p>
					На вход 6, на выходе D (6 + 7 = 13). На вход D, на выходе
					B (13 + 14 = 27 = 16 + 11).
				</p>
				<p>
					Для наглядности сравним несколько вариантов с учётом того,
					что мы рассмотрели ранее. Возьмём
					ненормализованные числа, чтобы видеть изменения только
					первого разряда (которые и будем восстанавливать).
					<span class="code"> 00000073.   </span> в R7 (
					<span class="but">7</span>&ensp;
					<span class="but">3</span>&ensp;
					<span class="but_b">x&rarr;П</span><span class="but">7</span>&ensp;
					<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">7</span>)
					и <span class="code"> 00000000.   </span> в R0 (
					<span class="but">1</span>&ensp;
					<span class="but_b">x&rarr;П</span><span class="but">0</span>&ensp;
					<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">0</span>)
					и рассмотрим некоторые последовательности.
				</p>
				1. Восстановление 00000073, первая цифра из RX:
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="5"></td>
					</tr>
				</table>
				<br>
				2. Восстановление 00000000, первая цифра из RX:
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="5"></td>
					</tr>
				</table>
				<br>
				3. Восстановление 00000000, первая цифра из RX и ещё <q>сложение</q> при X2 = 0:
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="4"></td>
					</tr>
				</table>
				<br>
				4. Восстановление 00000073, первая цифра &ndash; <q>знакоцифра &minus; 1</q>:
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="5"></td>
					</tr>
				</table>
				<br>
				5. Восстановление 00000000, первая цифра &ndash; <q>знакоцифра &minus; 1</q>:
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="5"></td>
					</tr>
				</table>
				<br>
				6. Восстановление 00000000, первая цифра &ndash;
				<q>знакоцифра &minus; 1» и ещё «сложение</q> при X2 = 0:
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="4"></td>
					</tr>
				</table>
				<br>
				Сводная таблица по указанным выше последовательностям:
				<table>
					<tr>
						<th>№</th>
						<th>При X = 52</th>
						<th>При X = &minus;52</th>
						<th>Пояснение</th>
					</tr>
					<tr>
						<th>1</th>
						<td><span class="code"> 50000073.   </span></td>
						<td><span class="code"> 50000073.   </span></td>
						<td>
							Цифра 5 берётся из RX. Знак не важен.
						</td>
					</tr>
					<tr>
						<th>2</th>
						<td><span class="code"> 60000000.   </span></td>
						<td><span class="code"> 60000000.   </span></td>
						<td>
							Цифра 5 после восстановления увеличивается, т.к.
							восстанавливается ноль.
						</td>
					</tr>
					<tr>
						<th>3</th>
						<td><span class="code"> L0000000.   </span></td>
						<td><span class="code"> L0000000.   </span></td>
						<td>
							Т.&#8239;к. ещё <q>сложение</q>, то к 5 прибавляется 6
							и получается 11 (цифра B).
						</td>
					</tr>
					<tr>
						<th>4</th>
						<td><span class="code"> 73.         </span></td>
						<td><span class="code"> 90000073.   </span></td>
						<td>
							Для неотрицательных <q>знакоцифра &minus; 1</q> равна нулю,
							первый ноль меняется на ноль, число не меняется.
							Для отрицательных <q>знакоцифра &minus; 1</q> равна 9.
						</td>
					</tr>
					<tr>
						<th>5</th>
						<td><span class="code"> 10000000.   </span></td>
						<td><span class="code"> -0000000.   </span></td>
						<td>
							Т.&#8239;к. восстанавливался ноль, то «знакоцифра
							&minus; 1» ещё увеличивается.
						</td>
					</tr>
					<tr>
						<th>6</th>
						<td><span class="code"> 10000000.   </span></td>
						<td><span class="code"> 30000000.   </span></td>
						<td>
							Тут сложнее. Второе <span class="but">ВП</span> видит
							<q>знакоцифру &minus; 1</q>, но ещё до увеличения. Поэтому
							проводит сложение с этой цифрой и ею же + 1.
							Для неотрицательных 0 + 1 = 1,
							а для отрицательных 9 + 10 = 19.
							А по модулю 16 (т.&#8239;к. только один разряд) = 3.
						</td>
					</tr>
				</table>
				<p></p>
			</details>

			<hr>

			<details id="id_x2_exp_goto" open="open">
				<summary>
					<h4><span class="but">ВП</span> сразу после косвенного перехода</h4>
				</summary>
				Т.&#8239;е. в программе делается переход через команду
				<span class="but_k">К</span><span class="but_b">БП</span><span class="but">R</span>
				или переход при проверке условия, например,
				<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">R</span>
				и сразу в месте, куда выполнился переход, идёт команда
				<span class="but">ВП</span>.
				В этом случае так же идёт восстановление X2, но при этом
				<strong>первая цифра меняется на 7</strong>.
				Знак и порядок сохраняются. Аналогично
				тому, что и ранее, если число в X2 не нормализовано,
				то всё равно идёт замена первой цифры, оставляя остальные как есть.
				В случае <strong>X2 = 0</strong> при восстановлении
				первая цифра будет <strong>восьмёркой</strong>.
				<p>
					Для косвенных условных переходов это работает, только если идёт переход на
					адрес. Если же условие выполняется (т.&#8239;е. без перехода),
					то поведение будет как указано выше. Если первая после перехода не
					<span class="but">ВП</span>, то тоже по правилам для
					<span class="but">ВП</span> ранее. Пример.
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but">0</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">8</span></td>
						<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
						<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">8</span></td>
						<td colspan="4"></td>
					</tr>
					<tr>
						<th>&#8202;10&#8202;|&#8202;</th>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="8"></td>
					</tr>
				</table>
				<p>
					После остановке на экране будет
					<span class="code"> 70.         </span>,
					т.&#8239;е. восстановлено X2 = 10 (вместо 100), и первая цифра заменена на 7.
					Ещё пример.
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">4</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">5</span></td>
						<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
						<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
						<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">5</span></td>
						<td><span class="but">ВП</span></td>
						<td colspan="3"><span class="but_b">С/П</span></td>
					</tr>
				</table>
				<p>
					По уже указанными правилам будет
					<span class="code"> 70000005.   </span>. Если
					заменить команду по адресу 05 на
					<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">5</span>,
					то ничего не изменится, т.&#8239;к. условие не выполнится и будет переход.
					Но если заменить на
					<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">5</span>,
					то уже условие выполнится, перехода не будет, и сработает старое
					правило, т.&#8239;е. будет использована первая цифра числа в X, т.&#8239;е.
					<span class="code"> 30000005.   </span>.
				</p>
				<p>
					Приведём пример для отличия нулевого X2. Пусть у нас R7 = 1, и есть короткая программа
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">7</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="7"></td>
					</tr>
				</table>
				<p>
					Тогда если ввести <span class="code"> 000.        </span> и
					нажать <span class="but_b">В/О</span>&emsp;
					<span class="but_b">С/П</span>, то получим на выходе
					<span class="code"> 800.         </span>. Но если вначале ввести
					<span class="code"> 000.00123   </span>, то получим
					<span class="code"> 700.00123   </span>.
				</p>
				<p>
					Для <strong>не</strong> косвенных переходов работает правило
					<a href="#id_x2_exp_combine">
						восстановление X2 с заменой первой цифры на цифру из числа в X</a
					>, при этом пустой оператор не нужен, т.&#8239;к.
					сам переход будет им. Пример:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
						<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
						<td><span class="but_f">F</span><span class="op_f">x&lt;0</span></td>
						<td><span class="but">04</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="4"></td>
					</tr>
				</table>
				<p>
					Если на вход программе дать
					<span class="code"> 002        </span>, то получим
					<span class="code"> 902        </span>
					(9 от &pi;<sup>2</sup>), а если
					<span class="code"> 000        </span>,
					то получим <span class="code"> -00        </span>,
					где первый символ - это шестнадцатеричное A,
					т.&#8239;к. 9 + 1 = 10.
				</p>
			</details>

			<hr>

			<details id="id_x2_exp_down" open="open">
				<summary>
					<h4>Команда <span class="but">.</span> перед <span class="but">ВП</span>
					<q>сдвигает</q> захват X глубже на начало</h4>
				</summary>
				<p>
					Обычно команда <span class="but">.</span> восстанавливает в X значение
					X2, но <span class="but">ВП</span> тоже пытается восстановить X2,
					но 1-ю цифру берёт ту, что было за 2 хода до нее в X. Рассмотрим
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but">5</span></td>
						<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
						<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">.</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="1"></td>
					</tr>
				</table>
				<p>
					Результат 55, потому что
					15<sup>2</sup> = 225, 225<sup>2</sup> = <strong>5</strong>0625 и <q>выигрывает</q>
					<span class="but">ВП</span>, который восстановит X2(15), с первой
					цифрой 5. Если убрать второй
					<span class="but_k">К</span><span class="op_k">НОП</span>, то
					результат будет 25 (2 от 225), т.&#8239;е. второй
					<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
					будет проигнорирован, как будто команда
					<span class="but">.</span> отодвинула
					<span class="but">ВП</span> вглубь.
					Если поменять
					<span class="but_k">К</span><span class="op_k">НОП</span> и
					<span class="but">.</span> местами, то будет 15, т.&#8239;к.
					<span class="but">.</span> восстановит 15 и уже с ним работает
					<span class="but">ВП</span>, как в ручном режиме.
					Другой пример:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but">5</span></td>
						<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
						<td><span class="but">.</span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="1"></td>
					</tr>
				</table>
				<p>
					Здесь <span class="but">.</span> отодвигает до
					<span class="but_b">x&rarr;П</span><span class="but">9</span>,
					т.&#8239;е. восстановится 15 с цифрой 3, т.&#8239;е. 35. Если убрать
					<span class="but_k">К</span><span class="op_k">НОП</span>, то
					поведение будет как у
					<span class="but_b">x&rarr;П</span><span class="but">9</span>&ensp;
					<span class="but">ВП</span>, т.&#8239;е. 15 без первой цифры (5).
				</p>
			</details>

			<hr>

			<details id="id_x2_exp_dot" open="open">
				<summary><h4><span class="but">ВП</span><span class="but">.</span></h4></summary>
				<p>
					Известно (хотя не документировано), что для запрета ввода
					точки при вводе порядка, сочетание команд <span class="but">ВП</span> и
					<span class="but">.</span> вызывает ошибку. Более того, в отличие от
					остальных способов получения ошибки он отличается тем, что
				</p>
				<ol>
					<li>Он самый быстрый, действует мгновенно, а не <q>задумываясь</q>.</li>
					<li>
						Он не пропускает в программном режиме лишнюю команду, как делают
						все остальные операции, вызывающие ошибку (ах да, это тоже не
						документировано).
					</li>
				</ol>
				<p>
					Но это сочетание также работает с X2, т.&#8239;е. игнорирует
					все не X2-влияющие команды между этими двумя командами.
					В связи с этим становится ясно, что следующий фрагмент:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but">В&uarr;</span></td>
						<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
						<td><span class="but">ВП</span></td>
						<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
						<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
						<td><span class="but">.</span></td>
						<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="2"></td>
					</tr>
				</table>
				<p>
					остановится по ошибке уже на команде <span class="but">.</span> (т.&#8239;е. следующим
					для исполнения будет адрес 06) и успеет возвести в квадрат только дважды
					(первый квадрат, как не X2-влияющий будет отброшен по команде
					<span class="but">ВП</span>).
				</p>
				<p>
					Тут возникает вопрос, а что если хочется использовать команду
					<span class="but">.</span> для восстановления, при условии
					что предыдущее восстановление было по <span class="but">ВП</span>,
					а между этими командами нет X2-влияющих команд. Тут поможет другое
					сочетание&hellip;
				</p>
			</details>

			<hr>

			<details id="id_x2_exp_neg" open="open">
				<summary><h4><span class="but">ВП</span><span class="but">/-/</span></h4></summary>
				<p>
					Само по себе сочетание не интересно, обычная смена знака при
					вводе порядка, но между ними могут стоять не X2-влияющие
					команды, тогда <span class="but">/-/</span> восстановит
					содержимое X2 после команды <span class="but">ВП</span>. Пример:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but">ВП</span></td>
						<td><span class="but">2</span></td>
						<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
						<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
						<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but">/-/</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="2"></td>
					</tr>
				</table>
				<p>
					Дадим на вход число -45, тогда на выходе будет
					<span class="code">-4.5      -01</span>, в регистре Y
					<span class="code">-4500.       </span>, как результат
					возведения во вторую степень, а в R9
					<span class="code"> 97.409083   </span>, как
					квадрат от <span class="pi">&pi;</span>.
					Обратите внимание на два момента:
				</p>
				<ol>
					<li>
						Ввод цифр после команды <span class="but">ВП</span>,
						хотя и являются X2-влияющими, но в данном контексте
						относятся только к вводу порядка и восстановится
						число в момент выполнения команды ВП.
					</li>
					<li>
						Команда <span class="but">/-/</span> кроме восстановления
						выполнит ещё свою основную функцию &ndash; сменит знак порядка.
					</li>
				</ol>
				<p>
					Если на вход этой программе дать
					<span class="code"> 00000.      </span>, то команда
					<span class="but">ВП</span> поставит на первом месте цифру
					1, т.&#8239;е. будет уже 10000, поэтому неудивительно, что
					после выполнения в X будет 100, а в регистре Y 1000000.
				</p>
				<p>
					Интересно, что если отставить только
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but">ВП</span></td>
						<td><span class="but">2</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td><span class="but">/-/</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="5"></td>
					</tr>
				</table>
				<p>
					то промежуточное умножение на 100 сохраниться в R9, а в
					регистре X останется только результат деление на 100.
					Такой вот трюк.
				</p>
			</details>
		</details>

		<hr>

		<details id="id_x2_sum" open="open">
			<summary><h3>Итог</h3></summary>
			<p>
				Причиной нестандартного поведения команд
				<span class="but">ВП</span> и <span class="but">.</span> является то, что
				подпрограммы ввода числа в ПМК, в том числе его порядка,
				работают напрямую с регистром X2, а для анализа некоторых проверок
				неявно подтягивают (обратное копирование) это число.
			</p>
			<p>
				Команда	<span class="but">.</span> проверяет, что она не введена
				повторно, поэтому нужно <q>подтянуть</q> X2.
			</p>
			<p>
				Команде <span class="but">ВП</span> нужно проверить, что
				значение не нулевое, чтобы <q>пошаманить</q> с первым разрядом.
			</p>
			<p>
				А команде <span class="but">/-/</span> после
				<span class="but">ВП</span> нужно посчитать суммарный
				порядок, а значит нужно исходное X2.
			</p>
		</details>

	</details>

	<hr>

	<details id="id_hex" open="open">
		<summary><h2>Шестнадцатеричная арифметика</h2></summary>
		<p>
			Речь идёт об обычных арифметических операциях, но в ситуации, когда
			операнд представляет собой число, содержащее шестнадцатеричные цифры
			A&hellip;E (F убрано из рассмотрения как опасное, по крайней мере в качестве
			первой цифры).
		</p>
		<p>
			Для простоты рассмотрим ситуации, когда число состоит из одной
			шестнадцатеричной цифры. Далее будем её обозначать буквой H. Для более
			ясного порядка операндов будем использовать стандартные обозначения X и Y.
		</p>

		<hr>

		<details id="id_hex_h_plus_y" open="open">
			<summary><h3>Операция H <span class="but">+</span> Y</h3></summary>
			<table class="center">
				<tr>
					<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>1</th>
					<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
				</tr>
				<tr>
					<th>2</th>
					<td>2</td><td>3</td><td>4</td><td>5</td><td>0</td>
				</tr>
				<tr>
					<th>3</th>
					<td>3</td><td>4</td><td>5</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>4</th>
					<td>4</td><td>5</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>5</th>
					<td>5</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>6</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>7</th>
					<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
				</tr>
				<tr>
					<th>8</th>
					<td>2</td><td>3</td><td>4</td><td>5</td><td>6</td>
				</tr>
				<tr>
					<th>9</th>
					<td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
				</tr>
				<tr>
					<th>A</th>
					<td>4</td><td>5</td><td>6</td><td>7</td><td>8</td>
				</tr>
				<tr>
					<th>B</th>
					<td>5</td><td>6</td><td>7</td><td>8</td><td>9</td>
				</tr>
				<tr>
					<th>C</th>
					<td>6</td><td>7</td><td>8</td><td>9</td><td>10</td>
				</tr>
				<tr>
					<th>D</th>
					<td>7</td><td>8</td><td>9</td><td>10</td><td>11</td>
				</tr>
				<tr>
					<th>E</th>
					<td>8</td><td>9</td><td>10</td><td>11</td><td>12</td>
				</tr>
				<tr>
					<td colspan="6"></td>
				</tr>
				<tr>
					<th>10</th>
					<td>10</td><td>21</td><td>22</td><td>24</td><td>24</td>
				</tr>
				<tr>
					<th>11</th>
					<td>21</td><td>22</td><td>23</td><td>24</td><td>25</td>
				</tr>
				<tr>
					<th>12</th>
					<td>22</td><td>23</td><td>24</td><td>25</td><td>26</td>
				</tr>
				<tr>
					<th>13</th>
					<td>23</td><td>24</td><td>25</td><td>26</td><td>27</td>
				</tr>
				<tr>
					<th>14</th>
					<td>24</td><td>25</td><td>26</td><td>27</td><td>28</td>
				</tr>
				<tr>
					<th>15</th>
					<td>25</td><td>26</td><td>27</td><td>28</td><td>29</td>
				</tr>
				<tr>
					<th>16</th>
					<td>26</td><td>27</td><td>28</td><td>29</td><td>30</td>
				</tr>
				<tr>
					<th>17</th>
					<td>27</td><td>28</td><td>29</td><td>30</td><td>31</td>
				</tr>
				<tr>
					<th>18</th>
					<td>28</td><td>29</td><td>30</td><td>31</td><td>32</td>
				</tr>
				<tr>
					<th>19</th>
					<td>29</td><td>30</td><td>31</td><td>32</td><td>33</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>30</td><td>31</td><td>32</td><td>33</td><td>34</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>31</td><td>32</td><td>33</td><td>34</td><td>35</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>32</td><td>33</td><td>34</td><td>35</td><td>20</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>33</td><td>34</td><td>35</td><td>20</td><td>21</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>34</td><td>35</td><td>20</td><td>21</td><td>22</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>35</td><td>20</td><td>21</td><td>22</td><td>23</td>
				</tr>
			</table>
			<p>
				Вычисление идёт как шестнадцатеричное, остаток по модулю 16, а от
				него берётся последняя цифра (чтобы осталась одна).
				X = ((X + Y) mod 16) mod 10.
				<br>
				Если <strong>Y двузначное</strong>, то уже две цифры X = ((X + Y) mod 256)
				mod 100, а значит получается <strong>как
				обычное сложение</strong>, если число двузначное.
				<br>
				Если <strong>Y дробное</strong>, то целая часть как выше,
				а дробная сохраняется.
			</p>
		</details>

		<hr>

		<details id="id_hex_x_plus_h" open="open">
			<summary><h3>Операция X <span class="but">+</span> H</h3></summary>
			<p>
				В этом случае осуществляется обычное сложение, только результат
				нормализуется. Например: 0 + A = 10, 9 + E = 23. В случае
				шестнадцатеричного X см. таблицу выше.
			</p>
		</details>

		<hr>

		<details id="id_hex_y_minus_h" open="open">
			<summary><h3>Операция Y <span class="but">-</span> H</h3></summary>
			<table class="center">
				<tr>
					<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>&minus;10</td><td>&minus;1</td><td>&minus;2</td><td>&minus;3</td><td>&minus;4</td>
				</tr>
				<tr>
					<th>1</th>
					<td>&minus;9</td><td>&minus;10</td><td>&minus;1</td><td>&minus;2</td><td>&minus;3</td>
				</tr>
				<tr>
					<th>2</th>
					<td>&minus;8</td><td>&minus;9</td><td>&minus;10</td><td>&minus;1</td><td>&minus;2</td>
				</tr>
				<tr>
					<th>3</th>
					<td>&minus;7</td><td>&minus;8</td><td>&minus;9</td><td>&minus;10</td><td>&minus;1</td>
				</tr>
				<tr>
					<th>4</th>
					<td>&minus;6</td><td>&minus;7</td><td>&minus;8</td><td>&minus;9</td><td>&minus;10</td>
				</tr>
				<tr>
					<th>5</th>
					<td>&minus;5</td><td>&minus;6</td><td>&minus;7</td><td>&minus;8</td><td>&minus;9</td>
				</tr>
				<tr>
					<th>6</th>
					<td>&minus;4</td><td>&minus;5</td><td>&minus;6</td><td>&minus;7</td><td>&minus;8</td>
				</tr>
				<tr>
					<th>7</th>
					<td>&minus;3</td><td>&minus;4</td><td>&minus;5</td><td>&minus;6</td><td>&minus;7</td>
				</tr>
				<tr>
					<th>8</th>
					<td>&minus;2</td><td>&minus;3</td><td>&minus;4</td><td>&minus;5</td><td>&minus;6</td>
				</tr>
				<tr>
					<th>9</th>
					<td>&minus;1</td><td>&minus;2</td><td>&minus;3</td><td>&minus;4</td><td>&minus;5</td>
				</tr>
				<tr>
					<th>A</th>
					<td>0</td><td>&minus;1</td><td>&minus;2</td><td>&minus;3</td><td>&minus;4</td>
				</tr>
				<tr>
					<th>B</th>
					<td>1</td><td>0</td><td>&minus;1</td><td>&minus;2</td><td>&minus;3</td>
				</tr>
				<tr>
					<th>C</th>
					<td>2</td><td>1</td><td>0</td><td>&minus;1</td><td>&minus;2</td>
				</tr>
				<tr>
					<th>D</th>
					<td>3</td><td>2</td><td>1</td><td>0</td><td>&minus;1</td>
				</tr>
				<tr>
					<th>E</th>
					<td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>
				</tr>
				<tr>
					<td colspan="6"></td>
				</tr>
				<tr>
					<th>10</th>
					<td>0</td><td>15</td><td>14</td><td>13</td><td>12</td>
				</tr>
				<tr>
					<th>11</th>
					<td>1</td><td>16</td><td>15</td><td>14</td><td>13</td>
				</tr>
				<tr>
					<th>12</th>
					<td>2</td><td>17</td><td>16</td><td>15</td><td>14</td>
				</tr>
				<tr>
					<th>13</th>
					<td>3</td><td>18</td><td>17</td><td>16</td><td>15</td>
				</tr>
				<tr>
					<th>14</th>
					<td>4</td><td>19</td><td>18</td><td>17</td><td>16</td>
				</tr>
				<tr>
					<th>15</th>
					<td>5</td><td>20</td><td>19</td><td>18</td><td>17</td>
				</tr>
				<tr>
					<th>16</th>
					<td>6</td><td>21</td><td>20</td><td>19</td><td>18</td>
				</tr>
				<tr>
					<th>17</th>
					<td>7</td><td>22</td><td>21</td><td>20</td><td>19</td>
				</tr>
				<tr>
					<th>18</th>
					<td>8</td><td>23</td><td>22</td><td>21</td><td>20</td>
				</tr>
				<tr>
					<th>19</th>
					<td>9</td><td>24</td><td>23</td><td>22</td><td>21</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>0</td><td>25</td><td>24</td><td>23</td><td>22</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>1</td><td>10</td><td>25</td><td>24</td><td>23</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>2</td><td>11</td><td>10</td><td>25</td><td>24</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>3</td><td>12</td><td>11</td><td>10</td><td>25</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>4</td><td>13</td><td>12</td><td>11</td><td>10</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>5</td><td>14</td><td>13</td><td>12</td><td>11</td>
				</tr>
			</table>
			<p>
				Выглядит похоже на X = (Y &minus; X) mod 16, но не всегда понятно,
				когда
				берётся заём, а когда нет. Число A какое-то особенное для двузначных,
				для него повторяется как для однозначных, т.&#8239;е. только с последней
				цифрой идёт операция, а потом складывается.
				<br>
				Для трёх- и выше значных повторяется как для двузначных,
				т.&#8239;е. 100 &minus; A = 90, т.&#8239;е. 90 + (10 &minus; A) + 0,
				100 &minus; B = 105, т.&#8239;е. 90 + (10 &minus; B) + 0,&hellip;,
				109 &minus; E = 111, т.&#8239;е. 90 + (10 &minus; E) + 9.
			</p>
		</details>

		<hr>

		<details id="id_hex_h_minus_x" open="open">
			<summary><h3>Операция H <span class="but">-</span> X</h3></summary>
			<table class="center">
				<tr>
					<td><sub>X</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>10</td><td>11</td><td>12</td><td>13</td><td>14</td>
				</tr>
				<tr>
					<th>1</th>
					<td>9</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>2</th>
					<td>8</td><td>9</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>3</th>
					<td>7</td><td>8</td><td>9</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>4</th>
					<td>6</td><td>7</td><td>8</td><td>9</td><td>0</td>
				</tr>
				<tr>
					<th>5</th>
					<td>5</td><td>6</td><td>7</td><td>8</td><td>9</td>
				</tr>
				<tr>
					<th>6</th>
					<td>4</td><td>5</td><td>6</td><td>7</td><td>8</td>
				</tr>
				<tr>
					<th>7</th>
					<td>3</td><td>4</td><td>5</td><td>6</td><td>7</td>
				</tr>
				<tr>
					<th>8</th>
					<td>2</td><td>3</td><td>4</td><td>5</td><td>6</td>
				</tr>
				<tr>
					<th>9</th>
					<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
				</tr>
				<tr>
					<th>A</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>B</th>
					<td>&minus;1</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>C</th>
					<td>&minus;2</td><td>&minus;1</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>D</th>
					<td>&minus;3</td><td>&minus;2</td><td>&minus;1</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>E</th>
					<td>&minus;4</td><td>&minus;3</td><td>&minus;2</td><td>&minus;1</td><td>0</td>
				</tr>
				<tr>
					<td colspan="6"></td>
				</tr>
				<tr>
					<th>10</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>11</th>
					<td>&minus;1</td><td>0</td><td>1</td><td>2</td><td>3</td>
				</tr>
				<tr>
					<th>12</th>
					<td>&minus;2</td><td>&minus;1</td><td>0</td><td>1</td><td>2</td>
				</tr>
				<tr>
					<th>13</th>
					<td>&minus;3</td><td>&minus;2</td><td>&minus;1</td><td>0</td><td>1</td>
				</tr>
				<tr>
					<th>14</th>
					<td>&minus;4</td><td>&minus;3</td><td>&minus;2</td><td>&minus;1</td><td>0</td>
				</tr>
				<tr>
					<th>15</th>
					<td>&minus;5</td><td>&minus;4</td><td>&minus;3</td><td>&minus;2</td><td>&minus;1</td>
				</tr>
				<tr>
					<th>16</th>
					<td>&minus;6</td><td>&minus;5</td><td>&minus;4</td><td>&minus;3</td><td>&minus;2</td>
				</tr>
				<tr>
					<th>17</th>
					<td>&minus;7</td><td>&minus;6</td><td>&minus;5</td><td>&minus;4</td><td>&minus;3</td>
				</tr>
				<tr>
					<th>18</th>
					<td>&minus;8</td><td>&minus;7</td><td>&minus;6</td><td>&minus;5</td><td>&minus;4</td>
				</tr>
				<tr>
					<th>19</th>
					<td>&minus;9</td><td>&minus;8</td><td>&minus;7</td><td>&minus;6</td><td>&minus;5</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>&minus;10</td><td>&minus;9</td><td>&minus;8</td><td>&minus;7</td><td>&minus;6</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>&minus;1</td><td>&minus;10</td><td>&minus;9</td><td>&minus;8</td><td>&minus;7</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>&minus;2</td><td>&minus;1</td><td>&minus;10</td><td>&minus;9</td><td>&minus;8</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>&minus;3</td><td>&minus;2</td><td>&minus;1</td><td>&minus;10</td><td>&minus;9</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>&minus;4</td><td>&minus;3</td><td>&minus;2</td><td>&minus;1</td><td>&minus;10</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>&minus;5</td><td>&minus;4</td><td>&minus;3</td><td>&minus;2</td><td>&minus;1</td>
				</tr>
			</table>
			<p>
				Нарушения обычного вычитания только для нескольких чисел (выше и
				правее, начиная с B &minus; 1, для двузначных ниже и левее A &minus; 1B).
				<br>
				Кстати, особенность: когда из шестнадцатеричного числа вычитается
				его десятичный аналог, то ноль, на самом деле, ненормализованный
				(т.&#8239;е. из 4-х значного будет 0000), и это можно использовать
				для получения нуля в любой степени. Пример (в ручном режиме):
			</p>
			<ol>
				<li>
					Получим цифру E документированным образом:
					<span class="but">1</span>&ensp;
					<span class="but">1</span>&ensp;
					<span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
					<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
					<span class="but">ВП</span>&ensp;
					<span class="but">1</span>&ensp;
					<span class="but_k">К</span><span class="op_k">[x]</span>,
					или можно нестандартным:
					<span class="but">1</span>&ensp;
					<span class="but_k">К</span><span class="op_k">&times;</span>&ensp;
					<span class="but">ВП</span>
				</li>
				<li>
					Добавим порядок, который хотим получить:
					<span class="but">ВП</span>&ensp;
					<span class="but">9</span>&ensp;
					<span class="but">9</span>
				</li>
				<li>
					Затем скопируем в стек:
					<span class="but">В&uarr;</span>&ensp;
					<span class="but">В&uarr;</span>&ensp;
					<span class="but_cx">СX</span>
				</li>
				<li>
					Выполним сложение <span class="but">+</span>
					(с нулём, что по правилу X + H будет обычным сложением,
					т.&#8239;е. получится десятичный аналог) и вычитание:
					<span class="but">-</span>
				</li>
			</ol>
			<p>
				И вот мы получили
				<span class="code"> 0.        99</span>.
			</p>
		</details>

		<hr>

		<details id="id_hex_h_mult_y" open="open">
			<summary><h3>Операция H <span class="but">&times;</span> Y</h3></summary>
			<table class="center">
				<tr>
					<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
				</tr>
				<tr>
					<th>1</th>
					<td>10</td><td>10</td><td>10</td><td>10</td><td>0</td>
				</tr>
				<tr>
					<th>2</th>
					<td>20</td><td>20</td><td>20</td><td>20</td><td>0</td>
				</tr>
				<tr>
					<th>3</th>
					<td>30</td><td>30</td><td>30</td><td>30</td><td>0</td>
				</tr>
				<tr>
					<th>4</th>
					<td>40</td><td>40</td><td>40</td><td>40</td><td>0</td>
				</tr>
				<tr>
					<th>5</th>
					<td>50</td><td>50</td><td>50</td><td>50</td><td>0</td>
				</tr>
				<tr>
					<th>6</th>
					<td>60</td><td>60</td><td>60</td><td>60</td><td>0</td>
				</tr>
				<tr>
					<th>7</th>
					<td>70</td><td>70</td><td>70</td><td>70</td><td>0</td>
				</tr>
				<tr>
					<th>8</th>
					<td>80</td><td>80</td><td>80</td><td>80</td><td>0</td>
				</tr>
				<tr>
					<th>9</th>
					<td>90</td><td>90</td><td>90</td><td>90</td><td>0</td>
				</tr>
				<tr>
					<th>A</th>
					<td>00</td><td>00</td><td>00</td><td>00</td><td>0</td>
				</tr>
				<tr>
					<th>B</th>
					<td>10</td><td>10</td><td>10</td><td>10</td><td>0</td>
				</tr>
				<tr>
					<th>C</th>
					<td>20</td><td>20</td><td>20</td><td>20</td><td>0</td>
				</tr>
				<tr>
					<th>D</th>
					<td>30</td><td>30</td><td>30</td><td>30</td><td>0</td>
				</tr>
				<tr>
					<th>E</th>
					<td>40</td><td>40</td><td>40</td><td>40</td><td>0</td>
				</tr>
				<tr>
					<td colspan="6"></td>
				</tr>
				<tr>
					<th>10</th>
					<td>100</td><td>100</td><td>100</td><td>100</td><td>0</td>
				</tr>
				<tr>
					<th>11</th>
					<td>110</td><td>110</td><td>110</td><td>110</td><td>0</td>
				</tr>
				<tr>
					<th>12</th>
					<td>120</td><td>120</td><td>120</td><td>120</td><td>0</td>
				</tr>
				<tr>
					<th>13</th>
					<td>130</td><td>130</td><td>130</td><td>130</td><td>0</td>
				</tr>
				<tr>
					<th>14</th>
					<td>140</td><td>140</td><td>140</td><td>140</td><td>0</td>
				</tr>
				<tr>
					<th>15</th>
					<td>150</td><td>150</td><td>150</td><td>150</td><td>0</td>
				</tr>
				<tr>
					<th>16</th>
					<td>160</td><td>160</td><td>160</td><td>160</td><td>0</td>
				</tr>
				<tr>
					<th>17</th>
					<td>170</td><td>170</td><td>170</td><td>170</td><td>0</td>
				</tr>
				<tr>
					<th>18</th>
					<td>180</td><td>180</td><td>180</td><td>180</td><td>0</td>
				</tr>
				<tr>
					<th>19</th>
					<td>190</td><td>190</td><td>190</td><td>190</td><td>0</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>200</td><td>200</td><td>200</td><td>200</td><td>0</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>210</td><td>210</td><td>210</td><td>210</td><td>0</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>220</td><td>220</td><td>220</td><td>220</td><td>0</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>230</td><td>230</td><td>230</td><td>230</td><td>0</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>240</td><td>240</td><td>240</td><td>240</td><td>0</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>250</td><td>250</td><td>250</td><td>250</td><td>0</td>
				</tr>
			</table>
			<p>
				Поразительное однообразие, почти все ведут себя как 10. Не ясно, чем
				так отличается E, но ноль получается и для многозначных чисел.
				<br>
				Для двузначных соответственно, т.&#8239;е. C &times; 20 = 200,
				но E &times; 20 = 0.
			</p>
		</details>

		<hr>

		<details id="id_hex_x_mult_h" open="open">
			<summary><h3>Операция X <span class="but">&times;</span> H</h3></summary>
			<table class="center">
				<tr>
					<td><sub>X</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
				</tr>
				<tr>
					<th>1</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>2</th>
					<td>4</td><td>6</td><td>8</td><td>10</td><td>12</td>
				</tr>
				<tr>
					<th>3</th>
					<td>4</td><td>1</td><td>4</td><td>23</td><td>10</td>
				</tr>
				<tr>
					<th>4</th>
					<td>8</td><td>2</td><td>0</td><td>20</td><td>24</td>
				</tr>
				<tr>
					<th>5</th>
					<td>50</td><td>11</td><td>32</td><td>53</td><td>42</td>
				</tr>
				<tr>
					<th>6</th>
					<td>0</td><td>22</td><td>44</td><td>50</td><td>40</td>
				</tr>
				<tr>
					<th>7</th>
					<td>10</td><td>33</td><td>40</td><td>63</td><td>54</td>
				</tr>
				<tr>
					<th>8</th>
					<td>20</td><td>44</td><td>52</td><td>60</td><td>68</td>
				</tr>
				<tr>
					<th>9</th>
					<td>30</td><td>55</td><td>64</td><td>73</td><td>82</td>
				</tr>
				<tr>
					<th>A</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>B</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>C</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>D</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>E</th>
					<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
				</tr>
				<tr>
					<td colspan="6"></td>
				</tr>
				<tr>
					<th>10</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>11</th>
					<td>10</td><td>21</td><td>32</td><td>43</td><td>54</td>
				</tr>
				<tr>
					<th>12</th>
					<td>04</td><td>16</td><td>28</td><td>40</td><td>52</td>
				</tr>
				<tr>
					<th>13</th>
					<td>14</td><td>11</td><td>24</td><td>53</td><td>50</td>
				</tr>
				<tr>
					<th>14</th>
					<td>08</td><td>22</td><td>20</td><td>50</td><td>4</td>
				</tr>
				<tr>
					<th>15</th>
					<td>990</td><td>021</td><td>052</td><td>923</td><td>922</td>
				</tr>
				<tr>
					<th>16</th>
					<td>000</td><td>032</td><td>904</td><td>920</td><td>920</td>
				</tr>
				<tr>
					<th>17</th>
					<td>010</td><td>043</td><td>900</td><td>933</td><td>934</td>
				</tr>
				<tr>
					<th>18</th>
					<td>020</td><td>054</td><td>912</td><td>930</td><td>948</td>
				</tr>
				<tr>
					<th>19</th>
					<td>030</td><td>905</td><td>924</td><td>943</td><td>962</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>940</td><td>960</td><td>980</td><td>0</td><td>20</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>40</td>
				</tr>
			</table>
			<p>
				Тут уже трудно поддаётся логике.
				На практике автор как-то использовал D. С одной стороны, это
				изображение, с другой &ndash; коэффициент 10 (см. таблицу H &times; Y),
				а самое основное &ndash; это проверка битового сдвига. При умножении
				дробной части, содержащей 1, 2, 4, 8 (как бы биты) возможен выход
				за диапазон, т.&#8239;е. 0.5 или 1.6. Так вот, при умножении на D по
				указанной таблице, результат из одной цифры получался, если всё
				нормально, или из двух, при выходе за диапазон.
			</p>
			<p>
				Для двухзначных результат бывает ненормализованным: обратите
				внимание на ведущие нули в некоторых случаях. На этом фоне
				14 &times; E выглядит как белая ворона.
			</p>
		</details>

		<hr>

		<details id="id_hex_h_div_x" open="open">
			<summary><h3>Операция H <span class="but">&divide;</span> X</h3></summary>
			<table class="center">
				<tr>
					<td><sub>X</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>ЕГГ0Г</td>
				</tr>
				<tr>
					<th>1</th>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
				<tr>
					<th>2</th>
					<td>5</td><td>5.5</td><td>6</td><td>6.5</td><td>7</td>
				</tr>
				<tr>
					<th>3</th>
					<td>3.3333333</td><td>3.6666666</td><td>4</td><td>4.3333333</td><td>4.6666666</td>
				</tr>
				<tr>
					<th>4</th>
					<td>2.5</td><td>2.75</td><td>3</td><td>3.25</td><td>3.5</td>
				</tr>
				<tr>
					<th>5</th>
					<td>2</td><td>2.2</td><td>2.4</td><td>2.6</td><td>2.8</td>
				</tr>
				<tr>
					<th>6</th>
					<td>1.6666666</td><td>1.8333333</td><td>2</td><td>2.1666666</td><td>2.3333333</td>
				</tr>
				<tr>
					<th>7</th>
					<td>1.4285714</td><td>1.5714285</td><td>1.7142857</td><td>1.8571428</td><td>2</td>
				</tr>
				<tr>
					<th>8</th>
					<td>1.25</td><td>1.375</td><td>1.5</td><td>1.625</td><td>1.75</td>
				</tr>
				<tr>
					<th>9</th>
					<td>1.1111111</td><td>1.2222222</td><td>1.3333333</td><td>1.4444444</td><td>1.5555555</td>
				</tr>
				<tr>
					<th>A</th>
					<td>1</td><td>1.1</td><td>1.2</td><td>1.3</td><td>1.4</td>
				</tr>
				<tr>
					<th>B</th>
					<td>8.4444443<sup>|&minus;01</sup></td><td>1</td><td>1.2525252</td><td>1.3434343</td><td>1.4343434</td>
				</tr>
				<tr>
					<th>C</th>
					<td>ЕГГ0Г</td><td>ЕГГ0Г</td><td>1</td><td>1.23</td><td>1.3</td>
				</tr>
				<tr>
					<th>D</th>
					<td>4.<sup>|&minus;01</sup></td><td>6.<sup>|&minus;01</sup></td><td>8.<sup>|&minus;01</sup></td><td>1</td><td>1.2</td>
				</tr>
				<tr>
					<th>E</th>
					<td>5.2929292<sup>|&minus;01</sup></td><td>2.2929292<sup>|&minus;01</sup></td><td>5.2929292<sup>|&minus;0</sup></td><td>8.2929292<sup>|&minus;01</sup></td><td>1</td>
				</tr>
				<tr>
					<td colspan="6"></td>
				</tr>
				<tr>
					<th>10</th>
					<td>0.<sup>|&minus;01</sup></td><td>1.<sup>|&minus;01</sup></td><td>2.<sup>|&minus;01</sup></td><td>3.<sup>|&minus;01</sup></td><td>4.<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>11</th>
					<td>9.090909<sup>|&minus;01</sup></td><td>0.<sup>|&minus;01</sup></td><td>0.9090909<sup>|&minus;01</sup></td><td>1.8181818<sup>|&minus;01</sup></td><td>2.7272727<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>12</th>
					<td>8.3333333<sup>|&minus;01</sup></td><td>9.1666666<sup>|&minus;01</sup></td><td>0.<sup>|&minus;01</sup></td><td>0.8333333<sup>|&minus;01</sup></td><td>1.6666666<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>13</th>
					<td>7.6923076<sup>|&minus;01</sup></td><td>8.4615384<sup>|&minus;01</sup></td><td>9.2307692<sup>|&minus;01</sup></td><td>0.<sup>|&minus;01</sup></td><td>0.7692307<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>14</th>
					<td>7.1428571<sup>|&minus;01</sup></td><td>7.8571428<sup>|&minus;01</sup></td><td>8.5714285<sup>|&minus;01</sup></td><td>9.2857142<sup>|&minus;01</sup></td><td>0.<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>15</th>
					<td>6.6666666<sup>|&minus;01</sup></td><td>7.3333333<sup>|&minus;01</sup></td><td>8.<sup>|&minus;01</sup></td><td>8.6666666<sup>|&minus;01</sup></td><td>9.3333333<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>16</th>
					<td>6.25<sup>|&minus;01</sup></td><td>6.875<sup>|&minus;01</sup></td><td>7.5<sup>|&minus;01</sup></td><td>8.125<sup>|&minus;01</sup></td><td>8.75<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>17</th>
					<td>5.8823529<sup>|&minus;01</sup></td><td>6.4705882<sup>|&minus;01</sup></td><td>7.0588235<sup>|&minus;01</sup></td><td>7.6470588<sup>|&minus;01</sup></td><td>8.2352941<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>18</th>
					<td>5.5555555<sup>|&minus;01</sup></td><td>6.1111111<sup>|&minus;01</sup></td><td>6.6666666<sup>|&minus;01</sup></td><td>7.2222222<sup>|&minus;01</sup></td><td>7.7777777<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>19</th>
					<td>5.2631578<sup>|&minus;01</sup></td><td>5.7894736<sup>|&minus;01</sup></td><td>6.3157894<sup>|&minus;01</sup></td><td>6.8421052<sup>|&minus;01</sup></td><td>7.368421<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>1A</th>
					<td>5.<sup>|&minus;01</sup></td><td>5.1<sup>|&minus;01</sup></td><td>6.3157894<sup>|&minus;01</sup></td><td>6.1<sup>|&minus;01</sup></td><td>7.<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>1B</th>
					<td>5.0330001<sup>|&minus;01</sup></td><td>6.<sup>|&minus;01</sup></td><td>7.0001032<sup>|&minus;01</sup></td><td>7.8330001<sup>|&minus;01</sup></td><td>8.2330001<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>1C</th>
					<td>6.<sup>|&minus;01</sup></td><td>7.0003809<sup>|&minus;01</sup></td><td>7.8100038<sup>|&minus;01</sup></td><td>8.1810003<sup>|&minus;01</sup></td><td>8.100038<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>1D</th>
					<td>7.0005899<sup>|&minus;01</sup></td><td>7.9000589<sup>|&minus;01</sup></td><td>8.<sup>|&minus;01</sup></td><td>9.0005899<sup>|&minus;01</sup></td><td>9.9000589<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>1E</th>
					<td>5.64<sup>|&minus;01</sup></td><td>5.90002<sup>|&minus;01</sup></td><td>6.4<sup>|&minus;01</sup></td><td>6.60002<sup>|&minus;01</sup></td><td>7.24<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>1F</th>
					<td>5.4000299<sup>|&minus;01</sup></td><td>5.3223099<sup>|&minus;01</sup></td><td>6.153223<sup>|&minus;01</sup></td><td>7.0002999<sup>|&minus;01</sup></td><td>7.7000299<sup>|&minus;01</sup></td>
				</tr>
			</table>
			<p>
				Здесь кроме случая X = 1, и некоторых двузначных это обычное
				деление нормализованного шестнадцатеричного числа. Пример:
				E &divide; 7 = 14 &divide; 7 = 2.
				<br>
				Правда и здесь встречаются ненормализованные числа
				(пример D &divide; 12, или C &divide; 11, которое на порядок меньше,
				чем A &divide; 11).
				<br>
				Встречаются и ненормализованные нули, пример: С &divide; 12, и
				выглядит, как указано:
				<span class="code"> 0.       -01</span>.
				Впрочем, <a href="#id_indirect_addr_R0">в косвенной адресации</a> мы
				уже встречались с подобными нулями.
			</p>
		</details>

		<hr>

		<details id="id_hex_y_div_h" open="open">
			<summary><h3>Операция Y <span class="but">&divide;</span> H</h3></summary>
			<table class="center">
				<tr>
					<td><sub>Y</sub>&Backslash;<sup>H</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<th>0</th>
					<td>9.090909<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td><td>4.4444443</td><td>9.9099099<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>1</th>
					<td>ЕГГ0Г</td><td>9.099099<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>2</th>
					<td>ЕГГ0Г</td><td>8.4444443<sup>|&minus;01</sup></td><td>9.099099<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>3</th>
					<td>ЕГГ0Г</td><td>6.4444443<sup>|&minus;01</sup></td><td>ЕГГ0Г</td><td>9.099099<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>4</th>
					<td>ЕГГ0Г</td><td>4.4444443<sup>|&minus;01</sup></td><td>ЕГГ0Г</td><td>8.<sup>|&minus;01</sup></td><td>9.099099<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>5</th>
					<td>ЕГГ0Г</td><td>2.4444443<sup>|&minus;01</sup></td><td>ЕГГ0Г</td><td>0.<sup>|&minus;01</sup></td><td>2.929292<sup>|&minus;02</sup></td>
				</tr>
				<tr>
					<th>6</th>
					<td>ЕГГ0Г</td><td>6.4444443<sup>|&minus;01</sup></td><td>ЕГГ0Г</td><td>2.<sup>|&minus;01</sup></td><td>3.2929292<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>7</th>
					<td>ЕГГ0Г</td><td>4.4444443<sup>|&minus;01</sup></td><td>ЕГГ0Г</td><td>4.<sup>|&minus;01</sup></td><td>6.2929292<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>8</th>
					<td>ЕГГ0Г</td><td>2.4444443<sup>|&minus;01</sup></td><td>ЕГГ0Г</td><td>0</td><td>9.2929292<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>9</th>
					<td>ЕГГ0Г</td><td>0.4444443<sup>|&minus;01</sup></td><td>ЕГГ0Г</td><td>2.<sup>|&minus;01</sup></td><td>2.2929292<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>A</th>
					<td>1</td><td>8.4444443<sup>|&minus;01</sup></td><td>ЕГГ0Г</td><td>4.<sup>|&minus;01</sup></td><td>5.2929292<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>B</th>
					<td>1.1</td><td>1</td><td>ЕГГ0Г</td><td>6.<sup>|&minus;01</sup></td><td>2.2929292<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>C</th>
					<td>1.2</td><td>1.2525252</td><td>1</td><td>8.<sup>|&minus;01</sup></td><td>5.2929292<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>D</th>
					<td>1.3</td><td>1.3434343</td><td>1.23</td><td>1</td><td>8.2929292<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<th>E</th>
					<td>1.4</td><td>1.4343434</td><td>1.3</td><td>1.2</td><td>1</td>
				</tr>
				<tr>
					<td colspan="6"></td>
				</tr>
				<tr>
					<th>10</th>
					<td>ЕГГ0Г</td><td>9.09909</td><td>9.9099099</td><td>9.9099099</td><td>9.9099099</td>
				</tr>
				<tr>
					<th>11</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>9.8</td><td>9.0292929</td>
				</tr>
				<tr>
					<th>12</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>0</td><td>9.3292929</td>
				</tr>
				<tr>
					<th>13</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>0.2</td><td>9.6292929</td>
				</tr>
				<tr>
					<th>14</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>ЕГГ0Г</td><td>0.4</td><td>9.9292929</td>
				</tr>
				<tr>
					<th>15</th>
					<td>ЕГГ0Г</td><td>9</td><td>ЕГГ0Г</td><td>9</td><td>0.22922929</td>
				</tr>
				<tr>
					<th>16</th>
					<td>ЕГГ0Г</td><td>9.2525252</td><td>ЕГГ0Г</td><td>9.2</td><td>0.5292929</td>
				</tr>
				<tr>
					<th>17</th>
					<td>ЕГГ0Г</td><td>9.3434343</td><td>ЕГГ0Г</td><td>9.4</td><td>9.2292929</td>
				</tr>
				<tr>
					<th>18</th>
					<td>ЕГГ0Г</td><td>9.4343434</td><td>ЕГГ0Г</td><td>9.6</td><td>9.5292929</td>
				</tr>
				<tr>
					<th>19</th>
					<td>ЕГГ0Г</td><td>9.5252525</td><td>ЕГГ0Г</td><td>9.8</td><td>9.8292929</td>
				</tr>
				<tr>
					<th>1A</th>
					<td>ЕГГ0Г</td><td>9.6</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1B</th>
					<td>ЕГГ0Г</td><td>9.8525252</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1C</th>
					<td>ЕГГ0Г</td><td>9.9434343</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1D</th>
					<td>ЕГГ0Г</td><td>0.0343434</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1E</th>
					<td>ЕГГ0Г</td><td>9.099099</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
				<tr>
					<th>1F</th>
					<td>ЕГГ0Г</td><td>7.4444443</td><td>9.9909909</td><td>9.9909909</td><td>9.9909909</td>
				</tr>
			</table>
			<p>
				Тут логики не наблюдается. Очень похожие, но разные числа:
				9.099099<sup>|&minus;01</sup> и 9.9099099<sup>|&minus;01</sup> (или 9.099099 и 9.9099099).
				<br>
				Также интересно, что при делении нуля на шестнадцатеричную цифру получается вовсе не ноль.
				<br>
				А самое главное, тут не просто ЕГГ0Г, а <dfn>плохой ЕГГ0Г</dfn>,
				который ранее не встречался. После его появления ПМК в дальнейшем
				(до выключения ПМК) при выполнении многих операций
				всегда выдаёт ЕГГ0Г. Вот список таких операций.
			</p>
				<span class="but">+</span>,
				<span class="but">-</span>,
				<span class="but">&times;</span>,
				<span class="but">&divide;</span>,
				<span class="but">&larr;&rarr;</span>,
				<span class="but_f">F</span><span class="op_f">sin</span>,
				<span class="but_f">F</span><span class="op_f">cos</span>,
				<span class="but_f">F</span><span class="op_f">tg</span>,
				<span class="but_f">F</span><span class="op_f">&radic;</span>,
				<span class="but_f">F</span><span class="op_f">1/x</span>,
				<span class="but_f">F</span><span class="op_f">sin<sup>-1</sup></span>,
				<span class="but_f">F</span><span class="op_f">cos<sup>-1</sup></span>,
				<span class="but_f">F</span><span class="op_f">tg<sup>-1</sup></span>,
				<span class="but_f">F</span><span class="op_f">&pi;</span>,
				<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>,
				<span class="but_f">F</span><span class="op_f">e<sup>x</sup></span>,
				<span class="but_f">F</span><span class="op_f">lg</span>,
				<span class="but_f">F</span><span class="op_f">ln</span>,
				<span class="but_f">F</span><span class="op_f">x<sup>y</sup></span>,
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>,
				<span class="but_f">F</span><span class="op_f">&orarr;</span>.
			<p>
				Ошибка возникает как в режиме вычислений, так и в программном
				режиме. Интересно, что
				<span class="but_f">F</span><span class="op_f">&orarr;</span> выдаёт ошибку,
				а <span class="but_f">F</span><span class="op_f">Вx</span> &ndash; нет.
			</p>
			<p>
				<q>Синие</q> функции работают нормально.
				Видимо такой ЕГГ0Г <q>сводит с ума</q> только один микроконтроллер.
			</p>
		</details>

		<hr>

		<details id="id_hex_func" open="open">
			<summary><h3>Результат функций над шестнадцатеричными числами</h3></summary>
			<p></p>
			<table class="center">
				<tr>
					<td><sub>H</sub>&Backslash;<sup>F(H)</sup></td>
					<th>A</th><th>B</th><th>C</th><th>D</th><th>E</th>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td>00</td><td>10</td><td>20</td><td>30</td><td>0</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">&radic;</span></td>
					<td>3.1622776</td><td>3.3166247</td><td>3.4641016</td><td>3.6055512</td><td>3.7416573</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">1/x</span></td>
					<td>ЕГГ0Г</td><td>9.099099<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td><td>9.9099099<sup>|&minus;01</sup></td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">e<sup>x</sup></span></td>
					<td>22026.467</td><td>59874.133</td><td>162754.78</td><td>442413.37</td><td>1202604.3</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
					<td>1.<sup>|+10</sup></td><td>1.<sup>|+0B</sup></td><td>1.<sup>|+0C</sup></td><td>1.<sup>|+0D</sup></td><td>1.<sup>|+0E</sup></td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">lg</span></td>
					<td>1</td><td>41.823681</td><td>42.40274</td><td>42.816354</td><td>43.126564</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">ln</span></td>
					<td>2.3025851</td><td>96.302585</td><td>97.635918</td><td>98.588299</td><td>99.302585</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&sup1;</span></td>
					<td>10</td><td>6.6631773<sup>|+41</sup></td><td>2.5277867<sup>|+42</sup></td><td>6.551706<sup>|+42</sup></td><td>1.3383338<sup>|+43</sup></td>
				</tr>
				<tr>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td>0</td><td>1</td><td>2</td><td>3</td><td>4</td>
				</tr>
			</table>
			<ul>
				<li>
					Результат возведения в квадрат согласуется с таблицей
					умножения, приведённой выше.
				</li>
				<li>
					Излечение корня вообще по правилам &ndash; как корень из
					нормализованного числа.
				</li>
				<li>
					Обратная величина так же согласуется с таблицей деления, причём
					здесь опять плохой ЕГГ0Г.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">e<sup>x</sup></span>
					тоже как корень &ndash; всё по правилам.</li>
				<li>
					<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>
					отображает шестнадцатеричную степень, только цифра A не любит светиться.
				</li>
				<li>Результаты логарифмов уже не понятны.</li>
				<li>
					<span class="but_f">F</span><span class="op_f">x&sup1;</span>
					это <span class="but_f">F</span><span class="op_f">x<sup>y</sup></span>,
					для случая Y = 1. Впрочем, результат от этого не становится более ясным.
					Кроме числа A, остальные возводятся в первую степень как какие-то
					суперчисла.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">[x]</span> похож на
					сложение с нулём. Причём если бы число было ещё с дробной частью,
					то целая часть осталась бы без изменений, даже если она
					шестнадцатеричная.
				</li>
			</ul>
			<p>
				Про более редкие операции переводов градусов/часов сказано
				<a href="#id_commands">в приложении по командам</a>.
				Числа, где порядок содержит шестнадцатеричные значения, рассмотрены
				в разделе косвенной адресации
				<a href="#id_indirect_addr_exponent">
					порядок содержит шестнадцатеричные цифры</a
				>.
			</p>
		</details>

		<hr>

		<details id="id_hex_using" open="open">
			<summary><h3>Практическое применение</h3></summary>
			<p>
				Практическое применение &ndash; это получение нестандартного
				результата (как отличие от обычной цифры). Или получение нестандартной
				последовательности. Или как был приведен выше по умножению.
			</p>
			<p>
				Случаи с двойными и более шестнадцатеричными числами (в том числе в
				дробной части) не рассмотрены, как очень редко встречающиеся.
				Там тоже можно построить подобные таблицы, но проще посмотреть
				результат под конкретное число.
			</p>
		</details>

	</details>

	<hr>

	<details id="id_zero_digit" open="open">
		<summary><h2>Числа, у которых вместо знака стоит цифра</h2></summary>
		<p>
			Рассматривается работа с числами, у которых вместо знака стоит цифра.
			В дальнейшем будем её называть знакоцифра.
			Автору известны только способы получения чисел, где знакоцифра получается
			из диапазона 2&hellip;9. Более того, есть основание думать, что кроме них
			допустимы только ещё только две цифры: A = минус, представляет
			отрицательные числа, и 1, которая отображается
			как пустое место и представляет положительные числа.
			Для ПМК БЗ-34 было возможно отображение и других цифр, но в МК-61 это не работает.
		</p>
		<p>
			Напомню, что знакоцифра успешно <q>выживает</q> при косвенной адресации.
			Обратите внимание, что далее в этом разделе очень часто в примерах у чисел
			вначале указывается именно знакоцифра.
		</p>

		<hr>

		<details id="id_zero_digit_get" open="open">
			<summary><h3>Способы получения</h3></summary>
			<ol>
				<li>
					<p>
						<strong>Хвосты 0C-оборотней</strong>. В этом случае используются знания
						Еггогологии. 0С-оборотни &ndash; это числа в диапазоне
						1.<sup>|+400</sup>&hellip;9.9999999<sup>|+499</sup>.
						Для получения таких чисел (точнее <q>хвостов</q>) воспользуемся программой:
					</p>
					<table class="center">
						<tr>
							<th>&#8202;#&#8202;|&#8202;</th>
							<th>00</th>
							<th>01</th>
							<th>02</th>
							<th>03</th>
							<th>04</th>
							<th>05</th>
							<th>06</th>
							<th>07</th>
							<th>08</th>
							<th>09</th>
						</tr>
						<tr>
							<th>&#8202;00&#8202;|&#8202;</th>
							<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
							<td><span class="but">5</span></td>
							<td><span class="but">0</span></td>
							<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
							<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
							<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
							<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
							<td><span class="but">&times;</span></td>
							<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
							<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						</tr>
						<tr>
							<th>&#8202;10&#8202;|&#8202;</th>
							<td><span class="but_b">П&rarr;x</span><span class="reg">c</span></td>
							<td><span class="but">ВП</span></td>
							<td><span class="but">7</span></td>
							<td><span class="but_b">С/П</span></td>
							<td colspan="6"></td>
						</tr>
					</table>
					<p>
						На вход ей передаётся число (0&hellip;8.9999999], на выходе получаем
						<q>хвост</q> оборотня из регистра Rc. Поэтому их
						и называют 0C-оборотни, что сами они на экран дают ноль, а <q>хвост</q>
						сбрасывают в регистр Rc. Передавать на вход
						девятку неинтересно, т.&#8239;к. на выходе получим 10, точнее цифру А,
						т.&#8239;е. обычный минус.
						<br>
						Пример, передав 1, получим
						<span class="code">2E.          </span>,
						передав 6, получим
						<span class="code">7E.          </span>,
						и т.&#8239;д. Нажав <span class="but">/-/</span> получим другую знакоцифру
						(вычислить какую именно легко, т.&#8239;к. сумма таких парных знакоцифр = 11).
						Кстати, если мантисса нулевая, то после <span class="but">/-/</span>
						будет &minus;0 для любой знакоцифры.
					</p>
					<p>
						Этот способ получения знакоцифры не очень удобен, тем более, что
						для получения других цифр мантиссы нужно сильно <q>напрячься</q>,
						например многократно прокрутив счётчик косвенной адресации.
						Есть способ лучше.
					</p>
				</li>
				<li>
					<strong>Использование косвенной адресации регистров R4&hellip;R6</strong>.
					О том, что при использовании шестнадцатеричных чисел в косвенной
					адресации для R4&hellip;R6 идёт их нормализация уже было
					упомянуто в
					<a href="#id_indirect_addr_mantissa">
						мантисса содержит шестнадцатеричные цифры</a
					>.
					<p>
						Так вот, если первая цифра 8-значного числа тоже шестнадцатеричная, то
						перенос из старшего разряда происходит в знаковый разряд, т.&#8239;е.
						появляется знакоцифра.
					</p>
					<p>
						Для начала возьмём обычную цифру E (для краткости
						нестандартным способом), которая потом пригодится:
						<span class="but">1</span>&ensp;
						<span class="but_k">К</span><span class="but">-</span>&ensp;
						<span class="but">ВП</span>&ensp;
						<span class="but_b">x&rarr;П</span><span class="reg">e</span>.
						Затем сделаем её первой (число 8-значным):
						<span class="but">ВП</span>&ensp;
						<span class="but">7</span>&ensp;
						<span class="but_b">x&rarr;П</span><span class="but">4</span>.
						Получили <span class="code"> E0000000.   </span>.
						Если теперь использовать косвенное увеличение:
						<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>,
						то получим <span class="code">240000001.   </span>.
						Тут из цифры E сделан перенос единицы в знаковый разряд.
						В отличии от 0С-оборотней мы пока получили только знакоцифру два
						(или 9, если нажать <span class="but">/-/</span>), зато остальные
						цифры мантиссы легко выбрать нужные (кроме шестнадцатеричных,
						которые косвенной адресацией нормализуются), а с помощью
						<a href="#id_x2_exp_combine">
							восстановление X2 с заменой первой цифры на цифру из числа в X
						</a>
						можно и первую цифру сделать шестнадцатеричной.
						Введем простую программу:
					</p>
					<table class="center">
						<tr>
							<th>&#8202;#&#8202;|&#8202;</th>
							<th>00</th>
							<th>01</th>
							<th>02</th>
							<th>03</th>
							<th>04</th>
							<th>05</th>
							<th>06</th>
							<th>07</th>
							<th>08</th>
							<th>09</th>
						</tr>
						<tr>
							<th>&#8202;00&#8202;|&#8202;</th>
							<td><span class="but">&larr;&rarr;</span></td>
							<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
							<td><span class="but">ВП</span></td>
							<td><span class="but_b">С/П</span></td>
							<td colspan="6"></td>
						</tr>
					</table>
					<p>
						Эта программа меняет у числа в X первую цифру на первую
						цифру из числа в Y.
						Соответственно, возьмём цифру E и наше новое число со знакоцифрой два
						и объединим их:
						<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">В/О</span>&ensp;
						<span class="but_b">С/П</span>.
						Получили
						<span class="code">2E0000001.   </span>.
						Если такое число провести через косвенную адресацию:
						<span class="but_b">x&rarr;П</span><span class="but">4</span>&ensp;
						<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_b">П&rarr;x</span><span class="but">4</span>,
						то получим <span class="code">340000002.   </span>.
						Таким же образом можно получить остальные знакоцифры
						(до 9 включительно). Кому эстетически не нравится хвостик
						(в данном случае 2), его можно сбросить до нуля, уже через
						косвенную адресацию с использованием R0&hellip;R3.
					</p>
				</li>
			</ol>
		</details>

		<hr>

		<details id="id_zero_digit_sign" open="open">
			<summary><h3>Какой знак у числа?</h3></summary>
			<p>
				Первый вопрос, который приходит на ум, глядя на такие числа, а они
				положительные или отрицательные? В дальнейшем для обозначения
				будем использовать <span class="first_bold">2N</span>,
				<span class="first_bold">3N</span>,
				&hellip; <span class="first_bold">9N</span>, где знакоцифра
				указана явно, а мантисса (может + порядок) обозначена буквой N.
			</p>
			<table class="center">
				<tr>
					<td></td>
					<td><span class="first_bold">2N</span></td>
					<td><span class="first_bold">3N</span></td>
					<td><span class="first_bold">4N</span></td>
					<td><span class="first_bold">5N</span></td>
					<td><span class="first_bold">6N</span></td>
					<td><span class="first_bold">7N</span></td>
					<td><span class="first_bold">8N</span></td>
					<td><span class="first_bold">9N</span></td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&lt;0</span></td>
					<td>Нет</td><td>Нет</td><td>Нет</td><td>Да</td><td>Да</td><td>Да</td><td>Да</td><td>Да</td>
				</tr>
				<tr>
					<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
					<td>Да</td><td>Да</td><td>Да</td><td>Да</td><td>Да</td><td>Нет</td><td>Нет</td><td>Нет</td>
				</tr>
			</table>
			<p>
				Как видно, далеко не всё так прозрачно. <span class="first_bold">5N</span> и
				<span class="first_bold">6N</span> получаются и отрицательные и положительные.
				Сравнения с нулём, кстати, для всех проходят корректно (не ноль, если
				N не ноль).
				<br>
				Рассмотрим другие функции, для косвенного определения знака числа.
			</p>
			<ul>
				<li>
					<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>
					выдаёт положительный порядок только для <span class="first_bold">9N</span>.
					Кстати, из <span class="first_bold">222</span> число 1.<sup>|+222</sup> не
					получится. ПМК посчитает число отрицательным и даст 1.<sup>|&minus;22</sup>.
					Для <span class="first_bold">922</span> соответственно 1.<sup>|+22</sup>.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">1/x</span>
					наоборот считает <span class="first_bold">9N</span> отрицательным,
					а остальные положительными.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">e<sup>x</sup></span>
					тоже только <span class="first_bold">9N</span> считает отрицательным.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">&radic;</span>
					все считает отрицательными, т.&#8239;е. даёт ошибку.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">lg</span> и
					<span class="but_f">F</span><span class="op_f">ln</span>
					все считает отрицательными, т.&#8239;е. дают ошибку.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">sin</span>
					все считает отрицательными, т.&#8239;е. результат отрицательный.
					Остальные тригонометрические функции ведут себя аналогично.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>
					или
					<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>
					считают их отрицательными, а
					<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;</span>
					и <span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
					не меняют знакоцифру.
				</li>
				<li>
					Парадоксально, но функция
					<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
					для чисел <span class="first_bold">5N</span>&hellip;<span class="first_bold">8N</span>
					результат делает отрицательным, хоть и правильным по модулю.
				</li>
				<li>
					<span class="but_f">F</span><span class="op_f">x<sup>y</sup></span>
					все считает отрицательными, если числа являются основанием
					(т.&#8239;е. даёт ошибку), но в качестве показателя различает,
					считая <span class="first_bold">9N</span> отрицательным, а остальные положительными.
				</li>
			</ul>
		</details>

		<hr>

		<details id="id_zero_digit_eval" open="open">
			<summary><h3>Арифметика с этими числами</h3></summary>
			<p>
				Нужно понимать, что <q>по модулю</q> функции считают правильно, обычно только
				знак результата бывает не очевиден.
				Часть функций уже была рассмотрена выше, где мы пытались определить знак числа.
				Рассмотрим другие:
			</p>
			<ul>
				<li>
					<span class="but_k">К</span><span class="op_k">ЗН</span> заменяет
					мантиссу на 1, оставляя знакоцифру, т.&#8239;е. от
					<span class="first_bold">8N</span>,
					получится <span class="first_bold">81</span>.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">&mid;x&mid;</span>
					отбрасывает знакоцифру, как и ожидалось.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">[x]</span>
					оставляет целую часть и ставит знак минус.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">{x}</span>,
					оставляет дробную часть вместе со знакоцифрой, если
					число по модулю &lt; 1.<sup>|+7</sup> (точнее число, которому нужно
					меньше восьми знакомест). Для больших чисел знакоцифра удаляется.
				</li>
				<li>
					<span class="but">+</span> в любом сочетании считает их отрицательными.
				</li>
				<li>
					<span class="but">-</span> ведёт себя хитрее. Когда число со знакоцифрой
					уменьшаемое, т.&#8239;е. находится в регистре Y, то ведёт себя как
					отрицательное, но когда вычитаемое (находится в регистре X), то
					наоборот, как положительное. Например, возьмём
					<span class="first_bold">63</span> (6 &ndash; знакоцифра),
					тогда <span class="first_bold">63</span> &minus; 1 = &minus;4,
					а вот 1 &minus; <span class="first_bold">63</span> = &minus;2 (а не 4, как
					для 1 &minus; (&minus;3)).
					Отсюда следует, что вычитание двух чисел со знакоцифрами
					складывает их модули, но результат оставляет отрицательным,
					т.&#8239;е. ведёт себя в точности, как сложение(!).
				</li>
				<li>
					<span class="but">&times;</span>, <span class="but">&divide;</span>
					обрабатываются сложнее, нужна таблица (порядок операндов не важен):
					<p></p>
					<table class="center">
						<tr>
							<td></td>
							<td><span class="first_bold">+N</span></td>
							<td><span class="first_bold">2N</span></td>
							<td><span class="first_bold">3N</span></td>
							<td><span class="first_bold">4N</span></td>
							<td><span class="first_bold">5N</span></td>
							<td><span class="first_bold">6N</span></td>
							<td><span class="first_bold">7N</span></td>
							<td><span class="first_bold">8N</span></td>
							<td><span class="first_bold">9N</span></td>
							<td><span class="first_bold">&minus;N</span></td>
						</tr>
						<tr>
							<td><span class="first_bold">+N</span></td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><span class="first_bold">2N</span></td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><span class="first_bold">3N</span></td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><span class="first_bold">4N</span></td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><span class="first_bold">5N</span></td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><span class="first_bold">6N</span></td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><span class="first_bold">7N</span></td>
							<td>+</td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
						</tr>
						<tr>
							<td><span class="first_bold">8N</span></td>
							<td>+</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>+</td>
						</tr>
						<tr>
							<td><span class="first_bold">9N</span></td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>+</td>
							<td>+</td>
						</tr>
						<tr>
							<td><span class="first_bold">&minus;N</span></td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>&minus;</td>
							<td>+</td>
							<td>+</td>
							<td>+</td>
						</tr>
					</table>
					<p>
						Результат, по крайней мере, согласуется с поведением функций
						<span class="but_f">F</span><span class="op_f">1/x</span> и
						<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>.
					</p>
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">max</span> считает
					числа с разными знакоцифрами равными (если N одинаковый),
					например для <span class="first_bold">8N</span> и
					<span class="first_bold">2N</span> операция
					не будет делать ничего
					(кроме сброса X в X1), к каком бы порядке они не стояли.
					<br>Но при этом все они меньше, чем
					<span class="first_bold">+N</span>, и больше,
					чем <span class="first_bold">&minus;N</span>.
				</li>
			</ul>
			<p>
				Тут нужно остановиться на нуле. Как указано в функции
				<span class="but_k">К</span><span class="op_k">{x}</span>, может
				получиться ноль со знакоцифрой. Так вот, он ведёт себя как обычный ноль.
				Единственное отличие &ndash; это в функциях сравнения. Такой ноль ведёт
				себя так, как указано ранее для чисел со знакоцифрой. В частности число
				<span class="code">50.          </span>
				операторы
				<span class="but_f">F</span><span class="op_f">x&lt;0</span>,
				<span class="but_f">F</span><span class="op_f">x&ge;0</span>,
				<span class="but_f">F</span><span class="op_f">x=0</span>
				пропустят, как удовлетворяющее условию.
			</p>
		</details>

		<hr>

		<details id="id_zero_digit_sum" open="open">
			<summary><h3>Произвольная мантисса и выводы</h3></summary>
			<p>
				Как видно, почти все операции уничтожают знакоцифру. Гарантированная
				доступная возможность менять мантиссу без изменения знакоцифры &ndash;
				это использовать косвенную адресацию. И конечно мантиссу можно заранее
				подготовить. Пример (использую программу и цифру E, полученную выше):
			</p>
			<p>
				<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_b">В/О</span>&ensp;
				<span class="but_b">С/П</span>
				Получили
				<span class="code"> E9999998.   </span>.
				Затем
				<span class="but_b">x&rarr;П</span><span class="but">4</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but_b">В/О</span>&ensp;
				<span class="but_b">С/П</span>.
				Получим <span class="code">299999999.   </span>
				(Кстати, если нажать <span class="but">/-/</span>, то получим девять
				девяток). Теперь снова сделаем над ним операцию
				<span class="but_b">x&rarr;П</span><span class="but">4</span>&ensp;
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>.
				Мы увидим довольно симпатичный ненормализованный ноль
				<span class="code">300000000.   </span>, которому
				можно поставить любую первую цифру (но не знакоцифру), как сделано
				только что по программе. Кстати, если так сделать с девятью девятками,
				то получится <span class="code">-00000000.   </span>.
			</p>
			<p>
				Фактически, таким образом можно получать почти любые мантиссы
				(кроме шестнадцатеричных) с нужной знакоцифрой.
			</p>
			<p>
				Например, хотим получить <span class="first_bold">321</span>,
				где 3 &ndash; знакоцифра.
				Используя короткую программу, указанную в начале раздела, у числа
				<span class="code"> 10000019.   </span>, заменим
				первую цифру на E, получим
				<span class="code"> E0000019.   </span>.
				После косвенного увеличения станет
				<span class="code">240000020.   </span>. Снова заменим
				на E, получим
				<span class="code">2E0000020.   </span>. Повторное
				косвенное увеличение приведёт к
				<span class="code">340000021.   </span>. Теперь,
				после замены первой цифры на ноль, останется
				<span class="code">321.         </span>.
			</p>
			<p>
				Ещё пример. Хочу получить <span class="pi">&pi;</span>/2 (для работы с
				тригонометрическими функциями), и знакоцифру девять.
				<span class="pi">&pi;</span>/2 = 1.5707963.
				Начнем с
				<span class="code"> 15707962.   </span>, заменим
				первую цифру на E, получим
				<span class="code"> E5707962.   </span>.
				После косвенного увеличения станет
				<span class="code">245707963.   </span>. Нажмём
				<span class="but">/-/</span>, получим
				<span class="code">945707963.   </span> и сделаем
				замену первой цифра на 1:
				<span class="code">915707963.   </span>. Осталось
				только
				<span class="but">ВП</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">1</span>,
				и мы получили, что хотели
				<span class="code">91.5707963   </span>.
				Можно проверить тригонометрические функции
				на нем, например синус о него даёт &minus;1.
			</p>
			<p>
				На самом деле можно получить числа со знакоцифрам и шестнадцатеричными
				цифрами в мантиссе. Сначала получим, как указано в начале
				<span class="code">240000001.   </span>, а затем
				применим следующий алгоритм:
			</p>
			<ol>
				<li>Ставим первой шестнадцатеричную цифру (E из Re) по мини-программе.</li>
				<li>Если все цифры мантиссы уже шестнадцатеричные, то завершаем.</li>
				<li>
					Уменьшаем с помощью
					<span class="but">ВП</span>&ensp;
					<span class="but">1</span>&ensp;
					<span class="but">/-/</span> порядок на единицу.
				</li>
				<li>
					У полученного значения через косвенную адресацию в R7&hellip;Rd убираем
					дробную часть. При этом вместо первой цифры будет вписано
					знакоцифра &minus; 1, а наша шестнадцатеричная цифра отодвинется.
					Переходим на п.&#8239;1.
				</li>
			</ol>
			<p>
				По такому алгоритму и цифре E легко получается
				<span class="code">2EEEEEEEE.   </span>.
			</p>
			<p>
				Понятно, что в пункте 1 алгоритма можно вписать любую цифру
				(кроме E). И начать с числа с любой знакоцифрой. Таким образом можно
				получить практически любую мантиссу с
				любой знакоцифрой (кроме цифр F или ведущих нулей).
			</p>
			<p>
				Более того, такие знакоцифры влияют и на остальное. Возьмём, для примера,
				<a href="#id_x2_exp_SR">
					Восстановление X2 с отбрасыванием первой цифры
				</a>. На самом деле указанная там последовательность при восстановлении
				вместо первой цифры записывает знакоцифру &minus; 1, что для положительного
				числа равно нулю, т.&#8239;е. отбрасывание цифры. А вот если знакоцифра есть,
				то эта последовательность запишет её минус один вместо первого знака.
				Отсюда же понятно, почему для отрицательных запишет 9, это знак минус,
				как цифра A (= 10) минус один. Причём знакоцифра останется на месте.
			</p>
			<p>
				На <strong>практике</strong> автор не использовал такие числа просто
				в силу того,
				что в момент активного использования ПМК не обладал этими знаниями.
				И хотя нестандартность поведения многих функций с такими числами
				определяется только реакцией на знак числа, всё равно можно
				предположить, что и это можно использовать для оптимизации.
			</p>
		</details>

	</details>

	<hr>

	<details id="id_neg_zero_degree" open="open">
		<summary><h2>Числа с отрицательной нулевой степенью</h2></summary>
		<p>
			Из раздела по косвенной адресации мы знаем о правиле <q>сумма = 160</q> для
			отрицательных степеней, которые содержат шестнадцатеричные цифры. Есть
			интересный эффект, когда порядок доводится до &minus;160 и в результате
			сложения по правилу получается не нулевая степень, а минус нулевая.
			Оказывается числа с такой степенью тоже имеют необычные свойства.
		</p>

		<hr>

		<details id="id_nzd_get" open="open">
			<summary><h3>Способ получения</h3></summary>
			<p>
				Как можно получить число в такой степенью? Для начала получим число
				с отрицательной степенью, содержащей шестнадцатеричные цифры. Например,
				1.<sup>|&minus;E0</sup>
				(<span class="code"> 1.       -E0</span>):
				<span class="but">1</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_k">К</span><span class="but">-</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>.
				Получилось число как 1.<sup>|&minus;140</sup> или по правилу 160 = 1.<sup>|+20</sup>.
				Теперь если убрать ещё 20 из порядка:
				<span class="but">ВП</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">1</span>.
				то мы получим 1.<sup>|&minus;00</sup>
				(<span class="code"> 1.       -00</span>).
			</p>
			<p>
				Если вы думаете, что мантисса может быть только единица, то обрадую, что
				можно и другие. Для исследования чисел с разными мантиссами приведём
				программу, которая регистры R1&hellip;Re заполняет числами с нулевой
				отрицательной степенью, а на месте первой цифры будет стоять номер
				регистра (да, да, для последнего это будет E.<sup>|&minus;00</sup>).
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">3</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">8</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but">ВП</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but">2</span></td>
					<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
					<td><span class="but">В&uarr;</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but">/-/</span></td>
					<td><span class="but">5</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">1</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">1</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but_f">F</span><span class="op_f">L0</span></td>
					<td><span class="but">18</span></td>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td><span class="but_b">С/П</span></td>
					<td colspan="9"></td>
				</tr>
			</table>
			<p>
				Тут тоже используются недокументированные возможности. Большую часть
				(адреса с 00 по 17) это получение (документированное)
				той же 1.<sup>|&minus;00</sup>, что
				мы сделали руками, только без ЕГГ0Га. Причём не через E0, а через L0
				(просто число 13 нужно для цикла по оставшимся регистрам R2&hellip;Re).
				Из-за особенностей поведения <span class="but">ВП</span> в программном
				режиме X нужно копировать в X2. Первый раз нам помогает
				<span class="but">/-/</span> по адресу 08, второй раз уже явно делаем
				<span class="but">В&uarr;</span> по адресу 12. А вот с 18 адреса начинается
				<q>шаманство</q>. Фрагмент программы 18&hellip;21 увеличивает текущую цифру
				(в шестнадцатеричном смысле). Эта особенность была рассказана в разделе
				про регистр X2 и команду <span class="but">ВП</span>. А фрагмент
				22&hellip;25 (тот же раздел) подставляет эту цифру в число из R1.
				Потом с помощью регистра Re мы сохраняем это в нужном месте и повторяем.
			</p>
			<p>
				Обозначим такое число с необычной степенью как N. В общем случае,
				нулевая степень (пусть с минусом) в математическом смысле ничего не меняет,
				т.&#8239;е. число должно быть как бы без степени. И большинство операций так
				его и воспринимают, но есть исключения. Пройдёмся по всем
				операциям/функциям, использую значения регистров, внесённые программой выше.
			</p>
		</details>

		<hr>

		<details id="id_nzd_plus" open="open">
			<summary><h3>Сложение и вычитание</h3></summary>
			<p>
				Тут порядок операндов неважен. Правило такое: если целая
				часть второго операнда состоит только из одной цифры (сюда же попадают
				шестнадцатеричные цифры и дробная часть может быть любая), то этот
				операнд (т.&#8239;е. всё число) сначала умножается на 10 (то же и для
				шестнадцатеричных чисел), а затем выполняется операция с N. Примеры:
			</p>
			<p>
				2.<sup>|&minus;00</sup> + 5.1 = 53:
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but">+</span> =
				<span class="code"> 53.         </span>.
			</p>
			<p>
				2.1 &minus; 3.<sup>|&minus;00</sup> = 18:
				<span class="but">2</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code"> 18.         </span>.
			</p>
			<p>
				<span class="pi">&pi;</span> &minus; 3.<sup>|&minus;00</sup> = 28.415926;
				<span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code"> 28.415926   </span>.
			</p>
			<p>
				E.1 + 2.<sup>|&minus;00</sup> = 43:
				<span class="but">1</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_k">К</span><span class="but">-</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">+</span> =
				<span class="code"> 43.         </span>.
			</p>
			<p>
				Для двух и более значных операндов, выполняется как обычно. Примеры:
			</p>
			<p>
				2.<sup>|&minus;00</sup> + 51 = 53:
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but">+</span> =
				<span class="code"> 53.         </span>.
			</p>
			<p>
				21 &minus; 3.<sup>|&minus;00</sup> = 18:
				<span class="but">2</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code"> 18.         </span>.
			</p>
			<p>
				e<sup>&pi;</sup> &minus; 3.<sup>|&minus;00</sup> = 20.14069:
				<span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
				<span class="but_f">F</span><span class="op_f">e<sup>x</sup></span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code"> 20.14069    </span>.
			</p>
			<p>
				E1 + 2.<sup>|&minus;00</sup> = 43:
				<span class="but">1</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_k">К</span><span class="but">-</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">+</span> =
				<span class="code"> 43.         </span>.
			</p>
			<p>
				Если дробное число (целая часть нулевая), то выполняется как обычно.
				Примеры:
			</p>
			<p>
				0.5 + 4.<sup>|&minus;00</sup> = 4.5:
				<span class="but">0</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but">+</span> =
				<span class="code"> 4.5         </span>.
			</p>
			<p>
				E.1<sup>|&minus;01</sup> + 4.<sup>|&minus;00</sup> = 5.41:
				<span class="but">0</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>&ensp;
				<span class="but_k">К</span><span class="but">-</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but_k">К</span><span class="op_k">НОП</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
				<span class="but">+</span> =
				<span class="code"> 5.41        </span>.
			</p>
			<p>
				Сами с собой числа N правила умножения на 10 не придерживаются и выполняются
				как обычно.
			</p>
			<p>
				5.<sup>|&minus;00</sup> + 2.<sup>|&minus;00</sup> = 7:
				<span class="but_b">П&rarr;x</span><span class="but">5</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">+</span> =
				<span class="code"> 7.          </span>.
			</p>
			<p>
				2.<sup>|&minus;00</sup> &minus; 3.<sup>|&minus;00</sup> = &minus;1:
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but">-</span> =
				<span class="code">-1.          </span>.
			</p>
			<p>
				Так же, как обычно, работает, если второй операнд нулевой.
				9.<sup>|&minus;00</sup> + 0 = 9:
				<span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">+</span> =
				<span class="code"> 9.          </span>.
			</p>
			<p>
				Для сравнения:
				9.<sup>|&minus;00</sup> + 1 = 19:
				<span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but">+</span> =
				<span class="code"> 19.         </span>.
			</p>
		</details>

		<hr>

		<details id="id_nzd_mult" open="open">
			<summary><h3>Умножение и деление</h3></summary>
			<p>
				При <strong>умножении</strong>, когда число N перед операцией
				находится в регистре
				Y, а число в регистре X меньше единицы (в абсолютном значении), то
				получается число со степенью &minus;160, т.&#8239;е. само число N в операции
				воспринимается как число в степени &minus;160 (кстати, с учётом цикличности
				ПМК на 1000 степени можно считать это числом в 840 степени).
				В остальных случаях ведёт как обычное умножение. Пример:
			</p>
			<p>
				1.5 &times; 2.<sup>|&minus;00</sup> = 3:
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code"> 3.          </span>.
			</p>
			<p>
				0.7 &times; 2.<sup>|&minus;00</sup> = 1.4<sup>|&minus;160</sup>:
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code"> 0.          </span>.
				Вроде бы ноль, но это потому, что при нормализации числа в степени такого
				порядка преобразуются в ноль. Для проверки составим программу, которая
				полученное число умножит на 1.<sup>|+80</sup>:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">2</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but">.</span></td>
					<td><span class="but">7</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but">8</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_b">С/П</span></td>
				</tr>
			</table>
			<p>
				После <span class="but_b">В/0</span>&ensp;
				<span class="but_b">С/П</span> на экране будет
				<span class="code"> 1.4      -80</span>
			</p>
			<p>
				Если число в X меньше единицы, но имеет порядок меньше &minus;40, то
				умножение снова проводится как обычно:
			</p>
			<p>
				1.<sup>|&minus;43</sup> &times; 6.<sup>|&minus;00</sup> = 6.<sup>|&minus;43</sup>:
				<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
				<span class="but">4</span>&ensp;
				<span class="but">3</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>&ensp;
				<span class="but">&times;</span> =
				<span class="code"> 6.       -43</span>.
			</p>
			<p>
				1.<sup>|&minus;40</sup> &times; 6.<sup>|&minus;00</sup> = 6.<sup>|&minus;200</sup>:
				<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
				<span class="but">4</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>&ensp;
				<span class="but">&times;</span> =
				<span class="code"> 0.          </span>.
			</p>
			<p>
				&minus;1.<sup>|&minus;99</sup> &times; 6.<sup>|&minus;00</sup> = &minus;6.<sup>|&minus;99</sup>:
				<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">-6.       -99</span>.
			</p>
			<p>
				Если число в X больше единицы, но имеет порядок не меньше 60, то число
				N снова воспринимается, как число в степени &minus;160.
			</p>
			<p>
				1.<sup>|+62</sup> &times; 7.<sup>|&minus;00</sup> = 7.<sup>|&minus;98</sup>:
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">6</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>&ensp;
				<span class="but">&times;</span> =
				<span class="code"> 7.       -98</span>.
			</p>
			<p>
				1.<sup>|+60</sup> &times; 7.<sup>|&minus;00</sup> = 7.<sup>|&minus;100</sup>:
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">6</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>&ensp;
				<span class="but">&times;</span> =
				<span class="code"> 0.          </span>.
			</p>
			<p>
				&minus;1.<sup>|+99</sup> &times; 7.<sup>|&minus;00</sup> = &minus;7.<sup>|&minus;61</sup>:
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but">9</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code">-7.       -61</span>.
			</p>
			<p>
				Напомню, если число N находится в регистре X, то происходит обычное
				умножение, но если в Y тоже N (может другое),
				то будет как выше степень &minus;160.
			</p>
			<p>
				3.<sup>|&minus;00</sup> &times; 7.<sup>|&minus;00</sup> = 2.1<sup>|&minus;159</sup>:
				<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">7</span>&ensp;
				<span class="but">&times;</span> =
				<span class="code"> 0.          </span>.
				Для проверки
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">П&rarr;x</span><span class="but">3</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but">8</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				= <span class="code"> 2.1      -79</span>.
			</p>
			<p>
				Для <strong>деления</strong> ситуация похожая. Необычность возникает,
				только когда
				делят на N (N в регистре X). Если число в регистре Y по модулю в
				диапазоне 1 &les; Y &lt; 10 (сюда же попадают шестнадцатеричные цифры),
				то в операциях деления N выглядит как число со степенью &minus;160.
			</p>
			<p>
				8.<sup>|&minus;00</sup> &divide; 2 = 4:
				<span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code"> 4.          </span>.
			</p>
			<p>
				18 &divide; 2.<sup>|&minus;00</sup> = 9:
				<span class="but">1</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code"> 9.          </span>.
			</p>
			<p>
				0.8 &divide; 2.<sup>|&minus;00</sup> = 0.4:
				<span class="but">0</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code"> 4.       -01</span>.
			</p>
			<p>
				8 &divide; 2.<sup>|&minus;00</sup> = 4.<sup>|+160</sup>:
				<span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code"> ЕГГ0Г      </span>.
				Для проверки составим программу:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_cx">Cx</span></td>
					<td><span class="but">8</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">2</span></td>
					<td><span class="but">&divide;</span></td>
					<td><span class="but">7</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
					<td><span class="but">&divide;</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="1"></td>
				</tr>
			</table>
			<p>
				После <span class="but_b">В/0</span>&ensp;
				<span class="but_b">С/П</span> на экране будет
				<span class="code"> 4.        90</span>.
			</p>
			<p>
				Единственное исключение &ndash; это когда в Y тоже число N. Тогда
				деление снова проходит как обычно.
				<br>
				8.<sup>|&minus;00</sup> &divide; 2.<sup>|&minus;00</sup> = 4:
				<span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
				<span class="but">&divide;</span> =
				<span class="code"> 4.          </span>.
			</p>
		</details>

		<hr>

		<details id="id_nzd_func_F" open="open">
			<summary><h3><q>Жёлтые</q> функции</h3></summary>
			<p>
				<q>Жёлтые</q> функции &ndash; те, которые вызываются через кнопку
				<span class="but_f">F</span>.
			</p>
			<ul>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">&radic;</span>.
						При взятии корня вычисляется, как обычно, но результат делится на
						10.<sup>|+48</sup>, т.&#8239;е. степень числа будет &minus;48. Пример:
					</p>
					<p>
						&radic;(4.<sup>|&minus;00</sup>) = 2.<sup>|&minus;48</sup>:
						<span class="but_b">П&rarr;x</span><span class="but">4</span>&ensp;
						<span class="but_f">F</span><span class="op_f">&radic;</span> =
						<span class="code"> 2.       -48</span>.
					</p>
					<p>
						&radic;(E.<sup>|&minus;00</sup>) = 3.7416573<sup>|&minus;48</sup>:
						<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
						<span class="but_f">F</span><span class="op_f">&radic;</span> =
						<span class="code"> 3.7416573-48</span>.
					</p>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">1/x</span>.
						Обратная величина считает число N числом в степени &minus;160.
					</p>
					<p>
						1 / (2.<sup>|&minus;00</sup>) = 5.<sup>|+159</sup>:
						<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
						<span class="but_f">F</span><span class="op_f">1/x</span> =
						<span class="code"> ЕГГ0Г      </span>.
					</p>
					<p>
						Для проверки составим программу:
					</p>
					<table class="center">
						<tr>
							<th>&#8202;#&#8202;|&#8202;</th>
							<th>00</th>
							<th>01</th>
							<th>02</th>
							<th>03</th>
							<th>04</th>
							<th>05</th>
							<th>06</th>
							<th>07</th>
							<th>08</th>
							<th>09</th>
						</tr>
						<tr>
							<th>&#8202;00&#8202;|&#8202;</th>
							<td><span class="but_b">П&rarr;x</span><span class="but">2</span></td>
							<td><span class="but_f">F</span><span class="op_f">1/x</span></td>
							<td><span class="but">7</span></td>
							<td><span class="but">0</span></td>
							<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
							<td><span class="but">&divide;</span></td>
							<td><span class="but_b">С/П</span></td>
							<td colspan="3"></td>
						</tr>
					</table>
					<p>
						После <span class="but_b">В/0</span>&ensp;
						<span class="but_b">С/П</span> на экране будет
						<span class="code"> 5.        89</span>.
					</p>
				</li>
				<li>
					<p>
						Тригонометрические функции рассмотрим только на нескольких значениях.
					</p>
					<p>
						Для <span class="but_f">F</span><span class="op_f">sin</span> только
						в радианах будут отличия:
					</p>
					<table class="center">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.<sup>|&minus;00</sup></th>
							<td>8.4147098<sup>|&minus;01</sup></td>
							<td>1.5707317<sup>|&minus;02</sup></td>
							<td>1.7452405<sup>|&minus;02</sup></td>
						</tr>
						<tr>
							<th>1</th>
							<td>8.4147103<sup>|&minus;01</sup></td>
							<td>1.5707317<sup>|&minus;02</sup></td>
							<td>1.7452405<sup>|&minus;02</sup></td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						Для <span class="but_f">F</span><span class="op_f">cos</span> тоже:
					</p>
					<table class="center">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>2.<sup>|&minus;00</sup></th>
							<td>4.4721363<sup>|&minus;01</sup></td>
							<td>9.9950656<sup>|&minus;01</sup></td>
							<td>9.9939082<sup>|&minus;01</sup></td>
						</tr>
						<tr>
							<th>2</th>
							<td>&minus;4.1614688<sup>|&minus;01</sup></td>
							<td>9.9950656<sup>|&minus;01</sup></td>
							<td>9.9939082<sup>|&minus;01</sup></td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						Для <span class="but_f">F</span><span class="op_f">tg</span> тоже:
					</p>
					<table class="center">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>3.<sup>|&minus;00</sup></th>
							<td>3</td>
							<td>4.7158802<sup>|&minus;02</sup></td>
							<td>5.2407778<sup>|&minus;02</sup></td>
						</tr>
						<tr>
							<th>3</th>
							<td>&minus;1.4254648<sup>|&minus;01</sup></td>
							<td>4.7158802<sup>|&minus;02</sup></td>
							<td>5.2407778<sup>|&minus;02</sup></td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						Для <span class="but_f">F</span><span class="op_f">sin<sup>-1</sup></span>
						все отличаются:
					</p>
					<table class="center">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.<sup>|&minus;00</sup></th>
							<td>7.853981<sup>|&minus;01</sup></td>
							<td>50.000003</td>
							<td>45.000002</td>
						</tr>
						<tr>
							<th>1</th>
							<td>1.5707963</td>
							<td>100</td>
							<td>90</td>
						</tr>
						<tr>
							<th>2.<sup>|&minus;00</sup></th>
							<td>1.1071486</td>
							<td>70.483276</td>
							<td>63.434949</td>
						</tr>
						<tr>
							<th>2</th>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						Для <span class="but_f">F</span><span class="op_f">cos<sup>-1</sup></span>
						все отличаются:
					</p>
					<table class="center">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.<sup>|&minus;00</sup></th>
							<td>7.8539812<sup>|&minus;01</sup></td>
							<td>49.999997</td>
							<td>44.999998</td>
						</tr>
						<tr>
							<th>1</th>
							<td>0</td>
							<td>00</td>
							<td>00</td>
						</tr>
						<tr>
							<th>2.<sup>|&minus;00</sup></th>
							<td>4.6364761<sup>|&minus;01</sup></td>
							<td>29.516724</td>
							<td>26.565051</td>
						</tr>
						<tr>
							<th>2</th>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
							<td>ЕГГ0Г</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">tg<sup>-1</sup></span>
						для чисел N всегда даёт ноль:
					</p>
					<table class="center">
						<tr>
							<td>X</td><th>Р</th><th>ГРД</th><th>Г</th>
						</tr>
						<tr>
							<th>1.<sup>|&minus;00</sup></th>
							<td>0</td>
							<td>0</td>
							<td>00</td>
						</tr>
						<tr>
							<th>1</th>
							<td>7.853981<sup>|&minus;01</sup></td>
							<td>50.000003</td>
							<td>45.000002</td>
						</tr>
						<tr>
							<td colspan="4"></td>
						</tr>
						<tr>
							<th>8.<sup>|&minus;00</sup></th>
							<td>0</td>
							<td>0</td>
							<td>00</td>
						</tr>
						<tr>
							<th>8</th>
							<td>1.4464413</td>
							<td>92.083315</td>
							<td>82.874983</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
						вычисляет, как обычно, но порядок числа при этом уменьшается на 160.
						При нормализации получается ноль:
					</p>
					<p>
						(2.<sup>|&minus;00</sup>)<sup>2</sup> = 4.<sup>|&minus;160</sup>:
						<span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
						<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
						даёт <span class="code"> 0.          </span>.
					</p>
					<p>
						(8.<sup>|&minus;00</sup>)<sup>2</sup> = 6.4<sup>|&minus;159</sup>:
						<span class="but_b">П&rarr;x</span><span class="but">8</span>&ensp;
						<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
						даёт <span class="code"> 0.          </span>.
					</p>
					<p>
						Но небольшая проверка показывает истинную картину:
					</p>
					<table class="center">
						<tr>
							<th>&#8202;#&#8202;|&#8202;</th>
							<th>00</th>
							<th>01</th>
							<th>02</th>
							<th>03</th>
							<th>04</th>
							<th>05</th>
							<th>06</th>
							<th>07</th>
							<th>08</th>
							<th>09</th>
						</tr>
						<tr>
							<th>&#8202;00&#8202;|&#8202;</th>
							<td><span class="but_b">П&rarr;x</span><span class="but">8</span></td>
							<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
							<td><span class="but">7</span></td>
							<td><span class="but">0</span></td>
							<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
							<td><span class="but">&times;</span></td>
							<td><span class="but_b">С/П</span></td>
							<td colspan="3"></td>
						</tr>
					</table>
					<p>
						После <span class="but_b">В/0</span>&ensp;
						<span class="but_b">С/П</span> на экране будет
						<span class="code"> 6.4      -89</span>.
					</p>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">e<sup>x</sup></span>
						вычисляется как обычно.
					</p>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">lg</span>
						выдаёт так:
					</p>
					<table class="center">
						<tr>
							<td>X</td>
							<td><span class="but_f">F</span><span class="op_f">lg</span></td>
						</tr>
						<tr>
							<th>1.<sup>|&minus;00</sup></th>
							<td>0</td>
						</tr>
						<tr>
							<th>2.<sup>|&minus;00</sup></th>
							<td>&minus;43.128418</td>
						</tr>
						<tr>
							<th>3.<sup>|&minus;00</sup></th>
							<td>&minus;42.952326</td>
						</tr>
						<tr>
							<th>4.<sup>|&minus;00</sup></th>
							<td>&minus;42.827388</td>
						</tr>
						<tr>
							<th>5.<sup>|&minus;00</sup></th>
							<td>&minus;42.730478</td>
						</tr>
						<tr>
							<th>6.<sup>|&minus;00</sup></th>
							<td>&minus;42.651297</td>
						</tr>
						<tr>
							<th>7.<sup>|&minus;00</sup></th>
							<td>&minus;42.58435</td>
						</tr>
						<tr>
							<th>8.<sup>|&minus;00</sup></th>
							<td>&minus;42.526358</td>
						</tr>
						<tr>
							<th>9.<sup>|&minus;00</sup></th>
							<td>&minus;42.475205</td>
						</tr>
						<tr>
							<th>A.<sup>|&minus;00</sup></th>
							<td>&minus;42.429448</td>
						</tr>
						<tr>
							<th>B.<sup>|&minus;00</sup></th>
							<td>&minus;1.6057671</td>
						</tr>
						<tr>
							<th>C.<sup>|&minus;00</sup></th>
							<td>&minus;1.0267076</td>
						</tr>
						<tr>
							<th>D.<sup>|&minus;00</sup></th>
							<td>&minus;6.1309386<sup>|&minus;01</sup></td>
						</tr>
						<tr>
							<th>E.<sup>|&minus;00</sup></th>
							<td>&minus;3.0288357<sup>|&minus;01</sup></td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">ln</span>
						тоже начиная с B.<sup>|&minus;00</sup> выдаёт другой порядок:
					</p>
					<table class="center">
						<tr>
							<td>X</td>
							<td><span class="but_f">F</span><span class="op_f">ln</span></td>
						</tr>
						<tr>
							<th>1.<sup>|&minus;00</sup></th>
							<td>0</td>
						</tr>
						<tr>
							<th>2.<sup>|&minus;00</sup></th>
							<td>&minus;99.306853</td>
						</tr>
						<tr>
							<th>3.<sup>|&minus;00</sup></th>
							<td>&minus;98.901388</td>
						</tr>
						<tr>
							<th>4.<sup>|&minus;00</sup></th>
							<td>&minus;98.613706</td>
						</tr>
						<tr>
							<th>5.<sup>|&minus;00</sup></th>
							<td>&minus;98.390562</td>
						</tr>
						<tr>
							<th>6.<sup>|&minus;00</sup></th>
							<td>&minus;98.208241</td>
						</tr>
						<tr>
							<th>7.<sup>|&minus;00</sup></th>
							<td>&minus;98.05409</td>
						</tr>
						<tr>
							<th>8.<sup>|&minus;00</sup></th>
							<td>&minus;97.920559</td>
						</tr>
						<tr>
							<th>9.<sup>|&minus;00</sup></th>
							<td>&minus;97.802776</td>
						</tr>
						<tr>
							<th>A.<sup>|&minus;00</sup></th>
							<td>&minus;97.697415</td>
						</tr>
						<tr>
							<th>B.<sup>|&minus;00</sup></th>
							<td>&minus;3.6974155</td>
						</tr>
						<tr>
							<th>C.<sup>|&minus;00</sup></th>
							<td>&minus;2.3640818</td>
						</tr>
						<tr>
							<th>D.<sup>|&minus;00</sup></th>
							<td>&minus;1.4117008</td>
						</tr>
						<tr>
							<th>E.<sup>|&minus;00</sup></th>
							<td>&minus;6.974152<sup>|&minus;01</sup></td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>
						выдаёт ошибку не из-за переполнения, а как обычно: порядок вне
						диапазона. Хотя отрицательные значения как результат возведения
						в степень конечно удивляют.
					</p>
					<table class="center">
						<tr>
							<td>X</td>
							<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
						</tr>
						<tr>
							<th>1.<sup>|&minus;00</sup></th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>2.<sup>|&minus;00</sup></th>
							<td>&minus;13.02585</td>
						</tr>
						<tr>
							<th>3.<sup>|&minus;00</sup></th>
							<td>&minus;36.051703</td>
						</tr>
						<tr>
							<th>4.<sup>|&minus;00</sup></th>
							<td>&minus;59.077562</td>
						</tr>
						<tr>
							<th>5.<sup>|&minus;00</sup></th>
							<td>&minus;7.0398713</td>
						</tr>
						<tr>
							<th>6.<sup>|&minus;00</sup></th>
							<td>&minus;6.4318666</td>
						</tr>
						<tr>
							<th>7.<sup>|&minus;00</sup></th>
							<td>&minus;5.5095304</td>
						</tr>
						<tr>
							<th>8.<sup>|&minus;00</sup></th>
							<td>&minus;3.9441377</td>
						</tr>
						<tr>
							<th>9.<sup>|&minus;00</sup></th>
							<td>&minus;7.0326326<sup>|&minus;01</sup></td>
						</tr>
						<tr>
							<th>A.<sup>|&minus;00</sup></th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>B.<sup>|&minus;00</sup></th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>C.<sup>|&minus;00</sup></th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>D.<sup>|&minus;00</sup></th>
							<td>ЕГГ0Г</td>
						</tr>
						<tr>
							<th>E.<sup>|&minus;00</sup></th>
							<td>1</td>
						</tr>
					</table>
				</li>
				<li>
					<p>
						<span class="but_f">F</span><span class="op_f">x<sup>y</sup></span>
						ведёт себя тоже нестандартно.
						Если число N показатель степени, т.&#8239;е. в регистре Y, то нормально
						работает, только если число в X не меньше числа e (экспонента), а
						иначе даёт единицу.
					</p>
					<table class="center">
						<tr>
							<td><span class="but_f">F</span><span class="op_f">x<sup>y</sup></span></td>
							<td>1.<sup>|&minus;00</sup></td><td>1</td><td>2.<sup>|&minus;00</sup></td><td>2</td><td>3.<sup>|&minus;00</sup></td><td>3</td>
						</tr>
						<tr>
							<td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td>
						</tr>
						<tr>
							<td>2</td><td>1</td><td>2</td><td>1</td><td>4</td><td>1</td><td>7.9999993</td>
						</tr>
						<tr>
							<td>2.7182817</td>
							<td>1</td><td>2.7182817</td>
							<td>1</td><td>7.3890551</td>
							<td>1</td><td>20.085531</td>
						</tr>
						<tr>
							<td>2.7182818</td>
							<td>2.7182818</td><td>2.7182818</td>
							<td>7.3890557</td><td>7.3890557</td>
							<td>20.085535</td><td>20.085535</td>
						</tr>
						<tr>
							<td>3</td>
							<td>2.9999994</td><td>2.9999994</td>
							<td>8.9999984</td><td>8.9999984</td>
							<td>26.999992</td><td>26.999992</td>
						</tr>
					</table>
					<p>
						Если N основание, т.&#8239;е. в регистре X, то ситуация печальней.
						<br>
						1.<sup>|&minus;00</sup> работает, как обычно, т.&#8239;е. даёт единицу при любом показателе.
						<br>
						2.<sup>|&minus;00</sup> быстро скатывается в ошибку:
					</p>
					<table class="center">
						<tr>
							<td><span class="but_f">F</span><span class="op_f">x<sup>y</sup></span></td>
							<td>2</td><td>2.29</td><td>2.30</td><td>2.31</td><td>2.32</td>
						</tr>
						<tr>
							<td>2.<sup>|&minus;00</sup></td>
							<td>5.5355546<sup>|&minus;87</sup></td>
							<td>1.7215634<sup>|&minus;99</sup></td>
							<td>0(=6.3773317<sup>|&minus;100</sup>)</td>
							<td>ЕГГ0Г(=2.3624032<sup>|&minus;100</sup>)</td>
							<td>ЕГГ0Г(просто ошибка аргумента)</td>
						</tr>
					</table>
					<p>
						Для остальных показателей и степеней выдаёт ошибку, кроме степени 1.
						Причём опять идёт изменение уровня начиная с B.<sup>|&minus;00</sup>.
					</p>
					<table class="center">
						<tr>
							<td><span class="but_f">F</span><span class="op_f">x<sup>y</sup></span></td>
							<td>1</td>
						</tr>
						<tr>
							<td>2.<sup>|&minus;00</sup></td><td>7.4401479<sup>|&minus;44</sup></td>
						</tr>
						<tr>
							<td>3.<sup>|&minus;00</sup></td><td>1.1160242<sup>|&minus;43</sup></td>
						</tr>
						<tr>
							<td>4.<sup>|&minus;00</sup></td><td>1.4880297<sup>|&minus;43</sup></td>
						</tr>
						<tr>
							<td>5.<sup>|&minus;00</sup></td><td>1.8600371<sup>|&minus;43</sup></td>
						</tr>
						<tr>
							<td>6.<sup>|&minus;00</sup></td><td>2.2320432<sup>|&minus;43</sup></td>
						</tr>
						<tr>
							<td>7.<sup>|&minus;00</sup></td><td>2.6040517<sup>|&minus;43</sup></td>
						</tr>
						<tr>
							<td>8.<sup>|&minus;00</sup></td><td>2.9760592<sup>|&minus;43</sup></td>
						</tr>
						<tr>
							<td>9.<sup>|&minus;00</sup></td><td>3.3480707<sup>|&minus;43</sup></td>
						</tr>
						<tr>
							<td>A.<sup>|&minus;00</sup></td><td>3.7200738<sup>|&minus;43</sup></td>
						</tr>
						<tr>
							<td>B.<sup>|&minus;00</sup></td><td>2.478751<sup>|&minus;02</sup></td>
						</tr>
						<tr>
							<td>C.<sup>|&minus;00</sup></td><td>9.4035621<sup>|&minus;02</sup></td>
						</tr>
						<tr>
							<td>D.<sup>|&minus;00</sup></td><td>2.437284<sup>|&minus;01</sup></td>
						</tr>
						<tr>
							<td>E.<sup>|&minus;00</sup></td><td>4.9787053<sup>|&minus;01</sup></td>
						</tr>
					</table>
				</li>
			</ul>
		</details>

		<hr>

		<details id="id_nzd_func_K" open="open">
			<summary><h3><q>Синие</q> функции</h3></summary>
			<p>
				<q>Синие</q> функции &ndash; те, которые вызываются через кнопку
				<span class="but_k">К</span>.
			</p>
			<ul>
				<li>
					<span class="but_k">К</span><span class="op_k">[x]</span>
					считает числа N дробными, и выдаёт ноль.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">{x}</span>
					считает так же, и соответственно, не меняет их, даже
					шестнадцатеричные.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">max</span>
					работает, как обычно, причём она, например,
					числа 8 и 8.<sup>|&minus;00</sup> считает равными.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">|x|</span>
					тоже работает, как обычно, т.&#8239;е. если отрицательное, то минус уберёт,
					а мантиссу и порядок не трогает.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">ЗН</span>
					тоже работает, как обычно, т.&#8239;е. даёт &plusmn;1.
				</li>
				<li>
					<p>
						Набор функций
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;</span>,
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>,
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>,
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>,
						которые обычно редко используются, здесь помогают расширить
						диапазон мантисс для чисел N. Дело в том, что они так же считают
						такие числа дробными, но в отличии от остальных функций при
						обработке не трогают порядок. Это значит, что число по-прежнему
						остаётся с нулевой отрицательной степенью (если конечно в результате
						не понизится порядок). Пример:
						<br>
						<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>
						выдаст
						<span class="code"> 2.9999999-00</span>, если чуть изменить:
						<span class="but_b">П&rarr;x</span><span class="but">3</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>,
						то уже <span class="code"> 2.9945599-00</span>
						<br>
						Или
						<span class="but_b">П&rarr;x</span><span class="reg">e</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>&ensp;
						<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>&ensp;
						<span class="but">/-/</span>
						даст <span class="code">--.16     -00</span>.
					</p>
					<p>
						Понятно, что таким образом набор мантисс ограничен, но всё-таки
						позволяет разнообразить набор чисел N.
					</p>
				</li>
				<li>
					<p>
						Логические функции, как обычно, вообще не обращают внимание на
						порядок и делают свою обычную работу, убирая всё лишнее.
					</p>
				</li>
			</ul>
		</details>

		<hr>

		<details id="id_nzd_sum" open="open">
			<summary><h3>Итог</h3></summary>
			<p>
				На практике такие числа могут быть использованы своей двойственностью
				при выполнении вычислений. Т.&#8239;е. в обычном случае как обычная константа,
				но при определённых условиях вдруг меняющая свое поведение. Главным
				выглядят умножения и деления, и пусть там выходят числа с большим
				отрицательным порядком, фактически любая X2 влияющая команда тут же
				превратит их в обычный ноль.
			</p>
		</details>

	</details>

	<hr>

	<details id="id_tricks" open="open">
		<summary><h2>Трюки по оптимизации</h2></summary>
		<p>
			Здесь рассмотрены некоторые способы, которые позволяют оптимизировать
			программу. Большинство трюков &ndash; это использование документированных
			возможностей, но возможно необычным образом.
			Ясно, что все варианты не рассмотреть, а лишь несколько для
			демонстрации, как нужно нестандартно подходить к вопросу оптимизации.
		</p>
		<ol>
			<li>
				<strong>Косвенная адресация вместо прямой.</strong> Это очевидное решение,
				т.&#8239;к. (без)условный переход (или вызов подпрограммы) занимает две
				команды, а то же самое с косвенной адресацией &ndash; только одну. Чем
				больше таких вызовов, тем выгоднее.
				<p></p>
			</li>
			<li>
				<strong>Правильный порядок в стеке.</strong> Это так же
				очевидное решение, при
				котором порядок вычисления меняют так, чтобы операнды по максимуму
				использовали стек (а не регистры памяти), и при этом располагались в
				порядке последующего вычисления. Или ещё &ndash; использование стека
				вычислений для дублирования числа. Пусть некое число нужно многократно
				использовать в вычислениях. Чтобы не вызывать его несколько раз из
				регистра памяти (а может даже и не сохранять), используется следующая
				методика: число вычисляют раньше, чем положено, затем после него
				делаются другие вычисления, но так, чтобы наше число <q>дошло</q> до
				регистра T. Затем другие вычисления завершаются, а регистры стека
				Y&hellip;T остаются заполнены нашим числом (причём и далее будут им
				заполняться). Экономия в командах на вызов из регистра.
				<p></p>
			</li>
			<li>
				<strong>Использования побочной ветви адресного пространства</strong> для
				сокращения программы. Эти способы уже были рассмотрены ранее в
				разделе по <a href="#id_addr_space">адресному пространству</a>.
				<p></p>
			</li>
			<li>
				<strong>Замена <span class="but_b">БП</span>&ensp;
				<span class="but">01</span> на <span class="but_b">В/О</span>.</strong>
				Это работает, только если стек возврата адресов пустой (нулевой).
				См. в <a href="#id_commands">приложении</a> комментарий по команде
				<span class="but_b">В/О</span>.
				<p>
					На самом деле с механизмом возврата
					на адрес 01 через <span class="but_b">В/О</span> используются много разных
					способов оптимизации. Вот пример: программа состоит из кода начальное подготовки
					HEAD, основного цикла MAIN, который начинается с вызова попрограммы
					SUB (она даже потом вызывается несколько раз, иначе зачем делать
					подпрограммой). А в конце цикла делается возрат на начало
					(<span class="but_b">Б/П</span>&ensp;<span class="but">00</span> или
					аналогичное). Так вот, оптимизация состоит в том, что программа
					выстраивается в таком порядке:
					по адресу 00
					<span class="but_k">К</span><span class="but_b">БП</span><span class="reg">R</span>
					(R - содержит некий адрес, с которого фактически начинается HEAD),
					затем тело SUB без вызова через <span class="but_b">ПП</span> (!).
					По окончании процедуры пройдет возврат на адрес 01 по команде
					<span class="but_b">В/О</span>, с которого
					продолжиться тело MAIN до адреса в регистре R, т.е. до начала цикла.
					Где экономия? Почти всё то же, но нет одного вызова <span class="but_b">ПП</span>,
					а это одна (для косвенного) или две команды.
					</p>
				<p></p>
			</li>
			<li>
				<strong>Совмещение адреса перехода и команды.</strong> В этом случае адрес
				перехода для двойных команд (чаще всего <span class="but_b">БП</span>)
				используется одновременно и как обычная команда для другой
				последовательности. Очевидно, что требуется знание кодов операций.
				Благодаря наличию побочных ветвей адресации или её неоднозначности можно
				<q>подогнать</q> адрес под нужную команду. Например, последовательность
				<span class="but_b">БП</span>&ensp;
				<span class="but">53</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="reg">d</span>
				можно заменить на
				<span class="but_b">БП</span>&ensp;
				<span class="but">4D</span>,
				т.&#8239;к. адрес 4D = 53, а 4D = это
				<span class="but_b">x&rarr;П</span><span class="reg">d</span>.
				<p>
					Иногда ради такой <q>подгонки</q> делают перестроение программы:
					перемешивание независимых кусков программы, располагая их по
					разным адресам. Сюда же относится пример из журнала
					<a href="https://zhurnalko.net/=nauka-i-tehnika/tehnika-molodezhi/1985-09--num50" target="_blank">
						ТМ №9 за 1985:
					</a>
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;60&#8202;|&#8202;</th>
						<td><span class="but_f">F</span><span class="op_f">x&lt;0</span></td>
						<td><span class="but">61</span></td>
						<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
						<td><span class="but">63</span></td>
						<td><span class="but_b">С/П</span></td>
						<td colspan="5"></td>
					</tr>
				</table>
				Когда перед остановкой выводилось содержимое нужного регистра при
				проверке условия. Экономия на том, что адрес перехода совпадает с
				командой извлечения из регистра.
				<p></p>
			</li>
			<li>
				<strong>Удаление условных операторов.</strong> Речь идёт о замене условных
				операторов, которые обычно двойные, на простую арифметику.
				<p>
					Пусть есть часть программы, где при X &ne; 0 нужно к регистру R9
					добавить единицу (некий счётчик). Решение в лоб:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
						<td><span class="but">06</span></td>
						<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td><span class="but">1</span></td>
						<td><span class="but">+</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td colspan="4"></td>
					</tr>
				</table>
				<p>
					Решение с удалением условия:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
						<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td><span class="but">+</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td colspan="6"></td>
					</tr>
				</table>
				<p>
					В случае, если X может быть и отрицательным, будет чуть длиннее, но
					всё равно короче прямого решения:
				</p>
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
						<td><span class="but_k">К</span><span class="op_k">&mid;x&mid;</span></td>
						<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
						<td><span class="but">+</span></td>
						<td><span class="but_b">x&rarr;П</span><span class="but">9</span></td>
						<td colspan="5"></td>
					</tr>
				</table>
				<p></p>
			</li>
			<li>
				<strong>Нестандартное использование циклов FLx.</strong>
				<ul>
					<li>
						Знание того, что цикл по завершении оставит единицу, позволяет
						не инициализировать его при повторном заходе.
					</li>
					<li>
						Быстрая проверка на единицу содержимого регистров R0&hellip;R3 с
						переходом при невыполнении. Иногда для этой возможности
						переставляют регистры, т.&#8239;е. специально используется R0&hellip;R3
						вместо других для такой возможности.
					</li>
					<li>
						Выполнение операций, не имеющих отношение к циклу. Например,
						нужно в конце некой подпрограммы уменьшить счётчик попыток в
						регистре R2 и перейти на адрес (пусть 77). Вместо
						<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">2</span>&ensp;
						<span class="but_b">БП</span>&ensp;
						<span class="but">77</span>
						которое, кстати, портит стек (и для исправления может
						потребоваться ещё команда), сделать:
						<span class="but_f">F</span><span class="op_f">L2</span>&ensp;
						<span class="but">77</span>.
						Разумеется, счётчик должен не кончаться или сразу после этого кода
						идёт проверка по его окончанию. При этом для <q>бесконечности</q>
						счётчика иногда делают его отрицательным, если в конце вычислений важна
						только разница между началом и концом.
					</li>
				</ul>
				<p></p>
			</li>
			<li>
				<strong>Проверка на больше/меньше единицы.</strong> Если известно, что число
				не отрицательное, то вместо отнимания единицы и проверки на
				больше/меньше нуля можно сразу взять
				<span class="but_f">F</span><span class="op_f">lg</span> и проверить на
				больше/меньше нуля.
				<p></p>
			</li>
			<li>
				<strong>Остановка по ошибке при условии.</strong> Вот несколько способов
				сгенерировать ошибку и сделать остановку без проверки условия:
				<ul>
					<li>
						Если ноль &ndash; <span class="but_f">F</span><span class="op_f">1/x</span>
					</li>
					<li>
						Если меньше или равно нулю &ndash;
						<span class="but_f">F</span><span class="op_f">lg</span>
					</li>
					<li>
						Если меньше нуля &ndash;
						<span class="but_f">F</span><span class="op_f">&radic;</span>
					</li>
					<li>
						Если больше единицы &ndash;
						<span class="but_f">F</span><span class="op_f">cos<sup>-1</sup></span> или
						<span class="but_f">F</span><span class="op_f">sin<sup>-1</sup></span>
					</li>
					<li>
						Если больше или равно 100 &ndash;
						<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>
					</li>
					<li>
						Если дробная часть больше или равно 0.6 &ndash;
						<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
					</li>
				</ul>
				<p></p>
			</li>
			<li>
				<strong>Вызов части подпрограммы.</strong> Пример, пусть есть некий алгоритм,
				который особым образом обрабатывает число, но только целое или
				дробное отдельно. А нужно сделать её более универсальной, т.&#8239;е. для
				любого числа. Можно сделать так:
				<table class="center">
					<tr>
						<th>&#8202;#&#8202;|&#8202;</th>
						<th>00</th>
						<th>01</th>
						<th>02</th>
						<th>03</th>
						<th>04</th>
						<th>05</th>
						<th>06</th>
						<th>07</th>
						<th>08</th>
						<th>09</th>
					</tr>
					<tr>
						<th>&#8202;00&#8202;|&#8202;</th>
						<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
						<td><span class="but">0</span></td>
						<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
						<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
						<td><span class="but_b">ПП</span></td>
						<td><span class="but">07</span></td>
						<td><span class="but">&larr;&rarr;</span></td>
						<td colspan="3"></td>
					</tr>
					<tr><td colspan="11">&hellip;</td></tr>
					<tr>
						<th>&#8202;30&#8202;|&#8202;</th>
						<td><span class="but">+</span></td>
						<td><span class="but_b">В/О</span></td>
						<td colspan="8"></td>
					</tr>
				</table>
				Что здесь происходит? Сначала подготавливается на будущее дробная
				часть, затем заталкивается ноль и оставляется целая часть.
				Далее вызывается часть кода (часть кода текущей подпрограммы),
				которая делает обработку над целой частью, а в конце делает сложение
				(с нулём, в данном случае). Затем целая и дробная часть меняются
				местами и код повторяется, причём в конце сложение уже делает
				объединение, а затем возврат. Где экономия? Если бы мы вызывали
				обрабатываемую часть по очереди, то нам всё равно потребовалось бы
				разделять на целую и дробную часть, обрабатывать по очереди, а затем
				объединять сложением. Для этого потребовались бы всё те же команды,
				кроме <span class="but">0</span>. Но при это пришлось бы делать дважды
				<span class="but_b">ПП</span>, а это две команды. Заменив на одну команду
				<span class="but">0</span> и вызвав свой <q>хвост</q>, мы сэкономили одну команду.
				<p></p>
			</li>
			<li>
				<strong>Совмещение констант и адресов перехода.</strong> В данном
				случае речь
				идёт о том, что некоторая константа, используемая для вычислений,
				одновременно содержит и адрес перехода. Иногда это делают
				искусственно, перемещая программу под значение константы, а иногда
				удаётся совместить. Пример из практики автора &ndash; для битового
				положения игрока использовался формат N.0000H, где N &ndash; некий <q>этаж</q>,
				H &ndash; бит (число 1, 2, 4 или 8), а количество нулей в дробной части
				определяет положение на <q>этаже</q>. Движение по <q>этажу</q> выполнялось над
				дробной частью, путём умножения/деления на два (биты) и путем
				умножения/деления десять (влево/вправо на этаже). Подводный камень &ndash;
				в автоматическом округлении ПМК, возникающим при сложении чисел
				разных порядков. В данном случае при дробной части =
				0.000000H (H.<sup>|&minus;07</sup>) и делении на 10 получается число <q>вне этажа</q>,
				H.<sup>|&minus;08</sup>, которое должно обнулиться. Для H = 1, 2, 4 при сложении с
				целым так и есть, но если H = 8, то происходит исключение: в
				результате округления 8.<sup>|&minus;08</sup> превращается
				в 1.<sup>|&minus;07</sup> (неожиданный
				телепорт). Чтобы программа вела себя корректно, необходимо перед
				сложением от полученного числа отнять некое значение в диапазоне
				3.<sup>|&minus;08</sup> &les; X &lt; 5.<sup>|&minus;08</sup>, тогда это не испортит случая
				H = 1, 2, 4, и сделает число с H = 8 обнуляемым при округлении.
				Так вот, используя знание
				<a href="#id_indirect_addr">косвенной адресации</a> можно к
				3.<sup>|&minus;08</sup> (или 4.<sup>|&minus;08</sup>) добавить пару цифр.
				Это на исправление округления
				не скажется, но позволит использовать эти цифры как адрес перехода.
				Пусть нужна косвенная адресация с адресом 77, тогда константа будет
				3.77<sup>|&minus;08</sup>. А если учесть, что при косвенной адресации оно будет
				ненормализовано, то оно же использовалось для видеоизображения особой
				ситуации: <span class="code"> 0.0000377-03</span>.
			</li>
		</ol>
	</details>

	<hr>

	<details id="id_demo" open="open">
		<summary><h2>Демонстрационная программа</h2></summary>
		<details id="id_demo_preface" open="open">
			<summary><h3>Описание интерфейса программы</h3></summary>
			<p>
				В качестве демонстрации используется <strong>модификация</strong> программы
				<q>Пещера сокровищ</q>, опубликованной в журнале
				<a href="https://zhurnalko.net/=nauka-i-tehnika/tehnika-molodezhi/1987-07--num42" target="_blank">
					Техника Молодёжи №7 за 1987.
				</a>
			</p>
			<p>
				Для тех, кто не хочет идти по ссылке (или высматривать мелкий шрифт скана)
				опишем игру. Это трёхмерный лабиринт (3 этажа размером 7&times;4),
				где каждая ячейка на этаже может быть или свободна, или
				занята &ndash; <q>стена</q>. Цель игры &ndash; находясь в некоторой начальной
				точке лабиринта пройти весь (выход в левой нижней точке на третьем
				этаже &ndash; влево) и собрать максимальное количество
				сокровищ.
				Для понимания адресации вот план 1-го этажа из публикации
				в журнале:
			</p>
			<table>
				<tr>
				<td></td><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th>
				</tr>
				<tr>
				<th>1</th>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				</tr>
				<tr>
				<th>2</th>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>&emsp;</td>
				<td>&emsp;</td>
				<td>&emsp;</td>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				</tr>
				<tr>
				<th>4</th>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>&emsp;</td>
				<td>&emsp;</td>
				</tr>
				<tr>
				<th>8</th>
				<td class="wall_color">&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>&emsp;</td>
				<td class="wall_color">&emsp;</td>
				<td>X</td>
				</tr>
			</table>
			<p>
				Сверху нумерация колонок, слева &ndash; строк (для битовой арифметики),
				а затемнённые ячейки <span class="wall_color">&emsp;</span> обозначают
				стенки. Причём крестиком сразу показано положение игрока (для примера)
				в точке 1.0000008. Именно так расшифровываются координаты:
			</p>
			<ul>
				<li>Целая часть &ndash; номер этажа.</li>
				<li>
				Степень дробной части (количество нулей) &ndash; положение по
				горизонтали (колонка).
				</li>
				<li>Цифра в дробной части &ndash; положение по вертикали (строка).</li>
			</ul>
			<p>
				С учётом этого выход из лабиринта (который предопределён) &ndash;
				влево от точки 3.8.
			</p>
			<p>
				У игрока есть ограниченные ресурсы:
			</p>
			<ul>
				<li>
					Еда (в оригинале вода, но так как хранится в регистре Re, то
					удобнее называть еда). Тратится при любом ходе.
				</li>
				<li>
					Динамит или гранаты (для запоминания хранится в регистре
					Rd или в обозначении ПМК
					<span class="code"> Г.          </span>)
					&ndash; используется для пробивания стенок (их уничтожения).
				</li>
				<li>
					Просто сокровища (хранится, аналогично, в Rc). Именно их нужно набрать
					побольше. В данной модификации реально набрать не меньше десяти
					(за одну игру).
				</li>
			</ul>
			<p>
				Ресурс можно пополнить, поискав его (т.&#8239;е. его может и не быть).
				Поэтому далее будем называть их кладами. При этом
				на 1-м этаже будет еда (+9, в оригинале +10), на 2-м &ndash; динамит (+4)
				и только на 3-м сокровища (+1). Особенность &ndash; как только нашли, то
				на всех этажах в той же ячейке кладов уже нет.
			</p>
			<p>
				Управление игрока &ndash; задание команды на движение, или поиск кладов,
				или подрыв стены (последней ячейки, где не удалось пройти). Каждая команда
				расходует еду (подрыв, понятно, ещё и динамит). Код направления движения
				определяется положением цифр на клавиатуре относительно центра:
				2,4,6,8,&plusmn;5 &ndash; вниз/влево/вправо/вверх и выше/ниже этажом.
				Подрыв стены нулём (в оригинале число
				<span class="but_f">F</span><span class="op_f">&pi;</span>, но обычно
				при неудаче прохода выдаёт 0, так что сразу и удобнее его
				использовать для команды подрыва).
				Поиск &ndash; число 10 (в оригинале ноль, но 1/0 как бы намекает
				на найдём/нет).
			</p>
			<p>
				Если движение прошло успешно, то по окончании отображается новая
				координата игрока (в кодировке, как описано выше). Если нет &ndash; ноль.
				Выход из лабиринта определяется числом 11
				(в оригинале трамвай 11-го маршрута).
			</p>
			<p>
				При поиске клада: если не найдено &ndash; ноль.
				Если найдено, то показывает новое количество ресурса,
				а в регистре Y букву типа клада и позицию, где нашли, например:
				<span class="code"> E.00002     </span>.
				При этом (как в оригинале) с разбойником, который защищал клад, можно
				бороться (<span class="but">В&uarr;</span>) или пропустить
				(<span class="but">0</span>), затем <span class="but_b">С/П</span>.
				Если боремся, то в результате общее количество (с
				учётом найденных кладов) данного ресурса может как увеличиться,
				так и уменьшиться.
			</p>
			<p>
				При успешном подрыве &ndash; новое положение игрока, т.&#8239;е. подрыв
				подразумевает сразу ход в новую ячейку (в оригинале для этого приходилось
				делать отдельный ход). При неудаче &ndash; ноль.
			</p>
			<p>
				Несколько отличий демонстрационной программы от оригинала уже было сказано,
				но приведём весь список:
			</p>
			<ul>
				<li class="li_change">
					Для подрыва используется два динамита (всё-таки программа сложнее &#9786;).
					На самом деле, изменен способ отображения нехватки еды/динамита, и
					чтобы их отличить используется такое <q>увеличение</q>.
					Соответственно добавляется не по два, а по четыре, и вначале даётся
					не два, а четыре.
				</li>
				<li class="li_change">
					При нехватке динамита или еды вместо ЕГГ0Г отображается
					соответственно &minus;1 или &minus;2 (еда или динамит).
				</li>
				<li class="li_add">
					Подрыв определяется числом ноль (а не <span class="pi">&pi;</span>), причём
					игрок сразу делает ход в новую ячейку (иначе зачем подрыв?).
				</li>
				<li class="li_add">
					Поиск определяется числом 10, а не ноль. Кроме буквы типа
					показывается и положение клада на этаже (в оригинале только буква).
					Например, <span class="code"> E.00002</span>.
				</li>
				<li class="li_add">
					Стенки удаляются, а не делается <q>xor</q>. Хотя можно сделать в коде и так
					(поменяв <span class="but_k">К</span><span class="op_k">&or;</span>
					на <span class="but_k">К</span><span class="op_k">&oplus;</span>), но
					ставить новые стенки для затруднения прохода на мой
					взгляд нецелесообразно.
				</li>
				<li class="li_add">
					Блокируется неожиданный <q>телепорт</q> из N.0000008 в N.0000001 при
					движении вправо (сказываются особенности округления). В оригинале
					автор в примере в нескольких местах поставил стенки, чтобы
					это не проявлялось.
				</li>
				<li class="li_add">
					Блокируется подрыв <q>капитальных</q> стен. Это которые по краям лабиринта
					(слева, справа, сверху, снизу, в том числе подвал и крыша).
					В оригинале это можно делать, что приводило к непредсказуемым
					результатам.
				</li>
				<li class="li_add">
					Не портится стек возврата. В оригинале при ЕГГ0Г не отрабатывала
					команда <span class="but_b">В/О</span>, что забивало стек возврата. Хотя
					на работу самой программы это и не сказывалось.
				</li>
				<li class="li_add">
					Начальное значение счётчиков (кроме сокровищ) заполняются
					автоматически программой. Не требуется вводить в начале игры. Понятно,
					что и <q>начало</q> сделано по-другому.
				</li>
				<li class="li_add">
					И <strong>главное</strong> &ndash; ПМК сам(!) генерит как лабиринт, так и
					расположение кладов (в оригинале нужно было самому разработать,
					закодировать и вбить лабиринт) при каждой новой игре, причём начальное
					положении игрока обеспечивается <q>не в стенке</q>. Получается, что в отличии от
					оригинала у игрока нет плана лабиринта и кладов. С учётом этого было
					принято решение немного увеличить начальный объем еды
					(36 против исходных 30), т.&#8239;к. план неизвестен и придётся
					многократно упираться в стенки при изучении. Также подрыв стены
					совмещен с ходом на новое место.
				</li>
			</ul>
		</details>

		<hr>

		<details id="id_demo_detail" open="open">
			<summary><h3>Разбор программы</h3></summary>
			<p>
				Полный код программы приведём в конце, а по ходу изложения будем
				приводить фрагменты, изучая трюки и использование недокументированных
				особенностей ПМК, без которых не удалось обойтись, с учётом всех
				улучшений. Сначала общий алгоритм программы. Как в оригинале
				сказано, это демонстрация возможностей ПМК работать с отдельными битами
				(шестнадцатеричные числа). Планы этажей и кладов представляются
				битовыми масками (хватает одного числа на весь этаж), а местоположение
				игрока фактически определяет один бит. Именно он <q>двигается</q>,
				накладываясь на битовые маски, определяя возможность пройти.
				Так же биты в масках удаляются (при взятии клада) или устанавливаются
				(при удалении стенок).
				Большая часть кода программы &ndash; это преобразование хода игрока в
				правильные битовые операции, проверка границ, ресурсов и т.&#8239;п.
			</p>
			<p>
				Распределение регистров во многом совпадает с оригиналом.
			</p>
			<ul>
				<li>R0 &ndash; план кладов.</li>
				<li>R1&hellip;R3 &ndash; план 1&hellip;3 этажей.</li>
				<li>
					R4&hellip;R7 &ndash; специальные числовые константы для преобразования
					движения в битовую операцию: 2; 10; 0.1; 0.5 (точнее вместо 0.1 другое
					число, но смысл тот же). Т.&#8239;е. берётся дробная часть положения игрока
					(положение на этаже) и производится умножение на указанные величины,
					как бы сдвигая бит вниз (2), влево (10), вправо (&#8530;) и вверх (&frac12;).
					В оригинале это всё вычисляется программно, но я предпочёл убрать
					в регистры памяти, чтобы освободить большего место для команд.
					Хотя это и привело к дефициту регистров памяти.
				</li>
				<li>
					R8, R9 &ndash; содержат вспомогательные константы для адресов перехода
					и др., которые так же не меняются между играми. Детальное значение ниже
					по ходу изложения.
				</li>
				<li>
					Ra &ndash; текущее положение игрока в кодировке, указанной в
					описательной части.
				</li>
				<li>
					Rb &ndash; будущее положение игрока (куда он не смог пройти). Также
					этот регистр (всего один!) используется как рабочий для всевозможных
					вычислений, поэтому при <q>не ходах</q> там может быть совсем другое
					значение, но в любом случае подрыв контролирует и это.
				</li>
				<li>
					Rc, Rd, Re, как было указано выше, используются для хранения ресурсов
					(сокровища/динамит/еда).
				</li>
			</ul>
			<p>
				Итак, начнем с&hellip; начала. Как начинается игра (предполагая что глобальные
				константы вбиты, как и сама программа)? А вот так: задаётся начальное
				положение игрока на плане, например
				<span class="code"> 1.0000001   </span>, затем
				<span class="but_b">БП</span>&ensp;
				<span class="but">48</span>&ensp;
				<span class="but_b">С/П</span>.
				Тут же фрагментик:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td colspan="8"></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">6</span></td>
				</tr>
				<tr>
					<th>&#8202;50&#8202;|&#8202;</th>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
					<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>y</sup></span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">8</span></td>
					<td colspan="7"></td>
				</tr>
			</table>
			<p>
				Положение игрока запоминается в Rb (как бы куда хотим пойти). Начальное
				количество динамита берем 6, а не 4, т.&#8239;к. два придётся потратить на
				удаление возможной стенки в месте игрока &ndash; мы же ещё не знаем
				лабиринт. 36 (6<sup>2</sup>) &ndash; как начальное количество еды.
				А вот с регистром R0 проводим хитрые манипуляции. Благодаря особенностям
				косвенной адресации при первом обращении ноль превратится
				в &minus;99999999, что соответствует регистру R3, затем в &minus;99999998 &ndash; R2
				и так пока не дойдёт до R0, где &minus;99999996 перепишется новым
				сгенерированным значением (уже положительным!), это и отслеживаем в цикле.
				Цикл возвращается на адрес 55, который и
				записан в R8 (точнее &minus;55, но на адресацию это не влияет, а почему минус
				объясню позже).
				Сами операнды для
				<span class="but_k">К</span><span class="op_k">&or;</span> получаются из
				<span class="but_k">К</span><span class="op_k">СЧ</span> через функции
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span> и
				<span class="but_f">F</span><span class="op_f">x<sup>y</sup></span>,
				которые <q>размазывают</q> цифры мантиссы случайного числа на все
				разряды и делают его более случайным.
				Причём испытания показали, что выгодней сделать
				<span class="but_f">F</span><span class="op_f">Вx</span> и
				<span class="but_f">F</span><span class="op_f">x<sup>y</sup></span> вместо
				повтора <span class="but_k">К</span><span class="op_k">СЧ</span> и
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span> для
				второго операнда (таки циклится датчик, а эти операции его <q>сбивают</q>).
				Любители усложнения лабиринта (больше стенок и меньше кладов), могут
				заменить
				<span class="but_k">К</span><span class="op_k">&or;</span> на
				<span class="but_k">К</span><span class="op_k">&oplus;</span>
			</p>
			<p>
				Следующий фрагмент, это снова начало&hellip;, но уже в программном виде
				(я отображаю фрагменты так, чтобы было понятнее позднее что и как):
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">В/О</span></td>
					<td><span class="but_b">С/П</span></td>
					<td colspan="8"></td>
				</tr>
			</table>
			<p>
				Да, такой вот маленький фрагмент, поэтому явно требуются пояснения.
			</p>
			<p>
				Для начала хочу обратить внимание, что в R7 у нас записано 0.5, что
				при косвенной адресации даёт нулевой адрес (не меняя R7), а это значит,
				что мы всегда можем быстро вернуться на начало через
				<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span>,
				или подобное. Поэтому <span class="but_b">С/П</span> и располагается в
				самом начале.
			</p>
			<p>
				Но, есть и другой момент.
				Можно расположить в конце адресного пространства подпрограмму без
				<span class="but_b">В/О</span>, т.&#8239;к. благодаря побочной ветви адресного
				пространства этот <span class="but_b">В/О</span> <q>сыграет</q>. Более того,
				могу сразу сказать, что несмотря на наличие четырёх логических подпрограмм
				программа содержит всего этот один <span class="but_b">В/О</span>.
				Две подпрограммы удалось наложить на хвост другой, а
				начальный <span class="but_b">В/О</span>
				смог <q>сыграть</q> в двух разных адресных побочных ветвях.
			</p>
			<p>
				Иногда разницу в методах возврата используют для различения
				ситуации. Например, в оригинале в начале стоит
				<span class="but_cx">Cx</span>, куда возвращается управление при неудаче,
				или на +01 при удаче. Но мне удалось
				сэкономить даже на этой команде. Позднее поясню как.
			</p>
			<p>
				Прежде, чем продолжить код инициализации, который мы бросили, хочу
				привести <strong>основную</strong> подпрограмму, которая делает битовую
				проверку.
				Сначала приведём формализацию: на входе ожидается в регистре X
				план этажа для проверки (битовая маска). В регистре Y положение игрока (бит).
				После исполнения: значение Y безусловно запишется в регистр Rb.
				Если битовая проверка прошла успешно (совпадение), то значение из Y также
				попадёт в регистр Ra, в Y останется дробная часть (положение на этаже),
				а само значение будет уже в X.
				Если битовая проверка не успешна, то вернет ноль в регистрах X и Y.
				Посмотрим, как это делается.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td></td>
					<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">max</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">a</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				Если с битовым умножением и копированием Y в Rb всё ясно, то вот
				<span class="but_k">К</span><span class="op_k">max</span> явно использован
				<q>недокументированно</q>. При неудаче ноль из регистра Y будет
				<q>недокументированно</q> скопирован как <q>самое большое число</q> в X.
				Т.&#8239;е. при неудаче будет ноль (что от подпрограммы и требуется).
				А если битовая операция успешная (есть дробная часть), то ничего
				не произойдёт, т.&#8239;е. исходный Y останется в X, а дробная часть,
				которая конечно меньше, в Y.
				И результат будет скопирован в Ra.
			</p>
			<p>
				На самом деле эта подпрограмма полезна ещё в другом случае. Если
				(на входе) в одном из регистров X или Y число состоит из одной цифры,
				то эта процедура безусловно (из-за логического умножения) даст
				на выходе ноль. Эта возможность
				тоже используется в программе, поэтому назовём её также
				процедурой <strong>очистки</strong>.
			</p>
			<p>
				Но внимательный читатель спросит, а где же <span class="but_b">В/О</span>?
				А он расположен по адресу&hellip; ноль!
				Так вот, тут используется побочная ветвь адресного пространства, но
				только не после 105 адреса, а после F9-го. Да, адрес F9 = 47, а значит
				если подпрограмма начинается не с адреса 41 (как будто), а с того же
				адреса, но как F3, то после адреса F9 (47) управление перейдёт
				на 00, т.&#8239;е. на ту самую <span class="but_b">В/О</span>.
			</p>
			<p>
				Здесь уже можно раскрыть, что константа в регистре R9 (он
				используется для вызова этой подпрограммы) заканчивается на F3
				(можно и на ED). Точнее в R9 хранится
				<span class="code"> 4. 3     -08</span>
				(или <span class="code"> 4.EГ     -08</span>,
				кому как больше нравиться). Зачем вначале идёт 4 и такой порядок будет
				пояснено позднее (хотя, если читали весь документ, то об этом уже
				упоминалось). Главное, что такой <q>довесок</q> не меняет косвенной
				адресации. Упомяну только, что после <q>использования</q> в
				косвенной адресации значение в R9 станет ненормализованным
				<span class="code"> 0.00004 3-03</span>,
				зато сразу покажет адрес перехода.
			</p>
			<p>
				Продолжим код инициализации (начальной генерации лабиринта). Точнее
				он уже закончился и плавно переходит в подпрограмму, которая
				<q>взрывает</q> стенки. В чем смысл такого <q>слияния</q>? Во-первых, не
				требуются какие-либо <span class="but_b">БП</span>, во-вторых, нам
				всё равно нужно обеспечить, чтобы в точке высадки стенок
				не было, т.&#8239;е. как бы убрать её (даже если её там не было).
				Вот поэтому и было вначале на два динамита больше. Итак:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td colspan="3"></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">d</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				Тут вроде понятно, что из ресурса динамита (Rd) убирается два, проверяется
				что что-то осталось (не отрицательное) и остаток сохраняется обратно.
				Если динамита не осталось, то переходит на начало, с этой <q>&minus;2</q>, что по
				смыслу программы и нужно для сигнализации, что динамита нет. Причём
				сохранение остатка делается после проверки, чтобы не было
				&minus;2, &minus;4, &minus;6 и т.&#8239;д.
				Продолжим.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td colspan="8"></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">4</span></td>
				</tr>
				<tr>
					<th>&#8202;70&#8202;|&#8202;</th>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">9</span></td>
					<td colspan="3"></td>
				</tr>
			</table>
			<p>
				Напомню, что координаты взламываемой стены находятся в Rb. Вначале
				проверяем, что это значение в пределах регистров R1&hellip;R3
				(т.&#8239;е. &lt; 4), причём R0 тоже пройдёт проверку, но это не страшно
				и вот почему.
				На самом деле в Rb число меньше единицы может быть или в виде одной цифры
				(например, хотели с первого этажа 1.0002 пойти вниз и получили 0.0002)
				или просто ноль (есть такой путь при попытке выхода за границы этажа).
				Главное, что число будет из одной цифры, т.&#8239;е. со второго разряда цифр нет,
				а значит в этом случае план этажа извлечётся из плана кладов R0,
				потому что косвенная адресация через Rb будет равна нулю (да,
				последние две цифры мантиссы будут нулевыми, даже для числа 1.<sup>|&minus;07</sup>,
				что можно посмотреть в главе по косвенной адресации). Затем операция
				<span class="but_k">К</span><span class="op_k">&or;</span> ничего не
				изменит (нет цифр у второго операнда) и вернет обратно в R0 значение
				неизменным.
				А если число больше или равно 4, то мы перейдём на процедуру очистки
				(зануления) через регистр R9. С учётом работы остальной части программы
				(это можно потом прикинуть) для Rb &gt;= 4 число в Rb либо состоит из
				одной цифры (взлом левой стенки) и процедура очистки безусловно
				сработает, либо это <q>крыша</q> (Rb = 4.{&hellip;}). Но в R4 (как это
				я так удачно всё расположил, сам удивляюсь)
				у нас тоже константа из одной цифры,
				а значит процедура очистки тоже сработает.
			</p>
			<p>
				Для R1&hellip;R3 это операция установит бит из Rb в плане этажа.
				В этом случае в X у нас план этажа, в Y точка взлома, которую мы тут
				устанавливаем. В этом случае основная процедура успешно пройдёт битовую
				проверку (мы же только что этот бит поставили) и завершится, записав
				новое расположение в регистре Ra. Т.&#8239;е. мы сразу сделаем ход в новое место.
			</p>
			<p>
				Итак. Инициализация закончена. Игрок в точке высадки, стенки там нет.
				Мы познакомились с основной процедурой из регистра R9, она же процедура
				очистки и процедурой взлома стены (с адреса 63), которая тщательно
				проверяет все варианты. Теперь можно вернуться на точку остановки
				(начальный <span class="but_b">С/П</span>) и 	начать самый частый (основной) код:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td colspan="2"></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">e</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td colspan="2"></td>
				</tr>
			</table>
			<p>
				Тут, очевидно, уменьшается еда, похожим образом, как динамит, учитывая,
				что будет выдано &minus;1 при неудаче. Обращаю внимание, что если
				исключить наш случай, когда регистров просто не хватает, тут всё равно
				делается экономия на команде. Всё-таки
				<span class="but_b">x&rarr;П</span><span class="but">R</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="but">R</span> &ndash; это
				две команды, а <span class="but">&larr;&rarr;</span> &ndash; только одна.
				Но это конечно при условии, что запомненное значение не понадобится ещё раз.
				Далее.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td colspan="8"></td>
					<td><span class="but">2</span></td>
					<td><span class="but">&divide;</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">63</span></td>
					<td colspan="8"></td>
				</tr>
			</table>
			<p>
				Вот и проверка команды на взлом стены (ноль). <q>Но позвольте, зачем сначала
				деление, а только потом проверка на ноль?</q> спросите вы. Ответ в том,
				что нам не хватает регистров (кстати, обратите внимание, что рабочий
				регистр Rb с последней попытки хода пока не задействован, и взлом
				будет на его основе). Поэтому выбор пользователя (точнее получается
				уже полвыбора &#9786;) мы запоминаем в регистре&hellip; X2. Да, да,
				вспомните, ведь проверка условий при успехе запоминает X в X2. А дальше
				посмотрим, как мы это используем:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td colspan="2"></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">ВП</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<p>
				Ага, вот и выбор пользователя преобразован в номер регистра для
				коэффициента умножения. Для прояснения, приведу таблицу с возможным выбором
				игрока (ноль уже исключили), и то что попало в регистр Rb:
			</p>
			<table class="center">
				<tr>
					<th>Ход игрока</th><th>После &divide; 2</th><th>После + 3</th>
				</tr>
				<tr>
					<th>2</th><td>1</td><td>4</td>
				</tr>
				<tr>
					<th>4</th><td>2</td><td>5</td>
				</tr>
				<tr>
					<th>&plusmn;5</th><td>&plusmn;2.5</td><td>Что-то больше нуля</td>
				</tr>
				<tr>
					<th>6</th><td>3</td><td>6</td>
				</tr>
				<tr>
					<th>8</th><td>4</td><td>7</td>
				</tr>
				<tr>
					<th>10</th><td>5</td><td>8</td>
				</tr>
			</table>
			<p>
				Вариант &plusmn;5 не будет использовать регистр Rb, как мы увидим позднее.
			</p>
			<p>
				Обратите внимание, что мы на самом деле сложили не с тройкой, а с
				числом <span class="pi">&pi;</span>. Почему? Дело в том, что команда
				<span class="but_f">F</span><span class="op_f">&pi;</span> не X2-влияющая,
				к тому же при косвенной адресации дробная часть значения не имеет
				(вспоминаем &ndash; всё это из главы по косвенной адресации).
				Т.&#8239;е. для нас всё равно, будет в Rb число 7 или 7.1415926, при
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>
				он всё равно извлечёт 0.5 (значение в R7).
			</p>
			<p>
				А самое главное, это то, что останется после
				команды <span class="but">ВП</span>.
				Вспомним из главы про X2, что сочетание этой команды с предшествующей
				командой сохранения в регистр <q>съест</q> первую цифру числа из X2
				(важно ещё то, что в результате сложения с <span class="pi">&pi;</span> значение в X
				не отрицательное) и восстановит его в X. А что у нас в X2?
				Это значение во второй колонке таблицы выше. Т.&#8239;е. он для всех
				вариантов из таблицы оставит ноль, и
				только от &plusmn;2.5 оставит &plusmn;0.5.
				Вот сколько может сделать одна недокументированная команда!
				Далее обработка варианта с вверх/вниз (&plusmn;0.5):
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td colspan="6"></td>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">D4</span></td>
					<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td><span class="but_b">БП</span></td>
					<td><span class="but">EA</span></td>
					<td colspan="8"></td>
				</tr>
			</table>
			<p>
				Что он делает? Он преобразует движение между этажами &plusmn;0.5
				в &plusmn;1 (тоже, кстати, трюк вместо умножения на 2) и переходит
				на некий адрес EA.
				Другие движения будут обработаны с адреса D4
				(если кто не знает, при наборе программы и вводе таких
				адресов вместо цифр нажимаются кнопки с соответствующими буквами).
				Что за странные адреса, спросите вы? А дело в том, что в конце всё
				это закончится на основной процедуре, которая расположена по
				нестандартным адресам, а значит и текущую ветвь выполнения нужно
				<q>завернуть</q>.
				D4 &ndash; тот же адрес 22, т.&#8239;е. как раз окончание этого
				кода, а EA равно 38. Точнее, адресу 38 соответствует адрес F0, но
				такое не ввести, поэтому мы заменяем аналогом (трюк).
				Ладно, займемся этим адресом, когда туда дойдём, а сейчас продолжим
				движение по этажу (или проверку клада), но сначала таинственное
				пропускание вперёд:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td colspan="2"></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">6</span></td>
					<td colspan="7"></td>
				</tr>
			</table>
			<p>
				Так, пришла пора раскрыть, что же находится в регистре R6, которое
				почти 0.1. Там хранится число D.<sup>|&minus;02</sup>
				(<span class="code"> Г.       -02</span>).
				Дело в том, что в операции умножения, если D находится слева (в X), то
				оно ведёт себя как 10 (кто забыл, просмотрите главу про шестнадцатеричную
				арифметику), а для степени &minus;02 получается как 0.1
				(10 &times; 10.<sup>|&minus;2</sup> = 10.<sup>|&minus;1</sup>). А когда справа (в Y), то
				гораздо хитрее. Это <q>хитрее</q> нам понадобится позднее, поэтому пока
				загоняем число в стек, чтобы оно было <q>справа</q> (я мысленно стек
				представляю как X1&ndash;X&ndash;Y&ndash;Z&ndash;T, если кто-то по другому,
				то <q>справа</q> поменяйте на другое).
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td colspan="3"></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
					<td><span class="but">77</span></td>
					<td></td>
				</tr>
			</table>
			<p>
				Ну вот, наконец-то умножение дробной части числа Ra (положение на этаже)
				на коэффициент движения (не забыли, что у нас в Rb?). Тут же проводится
				отсечка варианта поиска клада (команда = 10). Дело в том, что в R8
				(вариант 10 / 2 + 3)
				число отрицательное (&minus;55, если кто забыл, и вот оказывается для чего
				минус), а значит поиск уходит на адрес 77. Но это не всё.
				Тут мы опять используем регистр X2 (через X2-влияющую операцию сравнения).
				Мы сохраняем новое положение игрока на этаже в X2, но не потому что нет
				регистра, а для экономии команд:
				<span class="but_b">x&rarr;П</span><span class="reg">b</span>&ensp;
				<span class="but_b">П&rarr;x</span><span class="reg">b</span> это две
				команды, а <span class="but">.</span>, всего одна, а сравнение всё равно
				нужно делать. Именно поэтому сравнение делается не сразу после
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>,
				а после умножения, чтобы запомнить в X2 итог.
			</p>
			<p>
				Так, теперь, после получения нового значения на этаже нам нужно проверить,
				что в результате мы не вышли за границы этажа. Изучим такую
				проверку подробнее.
			</p>
			<p>
				Рассмотрим для начала левую границу. Как мы можем за нее попасть? Только
				если перед этим было число M.N (M = 1, 2, 3; N = 1, 2, 4, 8), а затем мы N
				умножили на 10. Понятно, что потом мы <q>дробную</q> часть приплюсуем к
				этажу M. В данном случае она очень даже не дробная, но в результате
				сложения итоговых вариантов не так много, и самое главное, они будут в
				диапазоне 2&hellip;11 и состоять только из одной цифры (кроме 11). А одна
				цифра бинарную конъюнкцию
				(<span class="but_k">К</span><span class="op_k">&and;</span>)
				<q>не переживёт</q> в процедуре очистки. Вариант с 11 (влево от 3.8) &ndash;
				это исключение, поэтому он и выбран как выход из лабиринта.
				Причём будет выполнена операция
				<span class="but">1</span>
				<span class="but">1</span>
				<span class="but_k">К</span><span class="op_k">&and;</span>
				<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span>.
				Т.&#8239;е. даже регистр Rb (b = 11, кто забыл) выбран не случайно
				(трюк с подтасовкой регистров)!
				В общем, левая граница <q>защитилась</q> автоматически.
			</p>
			<p>
				Правая граница. Там значение дробной части становится порядка 1.<sup>|&minus;08</sup>
				и при сложении с номером этажа просто потеряется
				(точности не хватит на 9 цифр), опять же оставляя только
				одну целую часть, которая будет 1&hellip;3 и конъюнкцию не переживёт.
				Исключение составляет 8.<sup>|&minus;08</sup> (округление до 1.<sup>|&minus;07</sup>),
				но и его мы победим позднее.
			</p>
			<p>
				Верх и низ. При переходе верхней границы (1 &times; 0.5) получается число,
				оканчивающиеся на 5, а при переходе нижней (8 &times; 2), число из двух цифр.
				Вот тут нам и пригодится таинственное D.<sup>|&minus;02</sup> из R6. Используя знания
				шестнадцатеричной арифметики можно узнать, что при умножении
				(D.<sup>|&minus;02</sup> как раз осталось справа) на число 1, 2, 4 или 8 результат будет
				содержать только одну цифру, а на 5 и тем более 16 уже больше.
				Это поясняет последующий код:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td colspan="9"></td>
					<td><span class="but">&times;</span></td>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_f">x=0</span><span class="but">9</span></td>
					<td colspan="7"></td>
				</tr>
			</table>
			<p>
				Здесь кроме того, что указано, применяется ещё один трюк. После умножения
				будет число с одной или более цифрой.
				Как же вычислить одна или больше? Приходит на помощь операция
				<span class="but_k">К</span><span class="op_k">&or;</span>
				при том, что в регистре Y остался ноль ещё после
				команды <span class="but">ВП</span> по адресу 15 (какой автор
				предусмотрительный, даже давний ноль у него при деле &#9786;).
				В результате
				будет 8. &ndash; всё хорошо или 8.{с чем-то} &ndash; плохо, а после
				<span class="but_k">К</span><span class="op_k">{x}</span> либо ноль,
				либо 0.{что-то}. Вот это плохое <q>что-то</q> последняя команда и отправит
				на процедуру очистки. Для очистки важно, чтобы в одном из регистров X
				или Y было число с одной цифрой &ndash; число ноль в Y
				вполне подходит (да, в логических бинарных операциях второй
				операнд не исчезает, но это таки документировано).
				Продолжим далее.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td colspan="3"></td>
					<td><span class="but">.</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but">-</span></td>
					<td colspan="4"></td>
				</tr>
			</table>
			<p>
				Первое что мы делаем, это восстанавливаем X2 (новое положение на этаже)
				ещё с команды сравнения по адресу 27,
				т.&#8239;к. все команды в промежутке были не X2-влияющие. А потом
				корректируем значение на маленькую величину порядка 4.<sup>|&minus;08</sup>. Это не
				изменит итог ни для кого, кроме 8.<sup>|&minus;08</sup>. В этом случае оно тоже станет
				очень маленьким. Вот где заблокирован <q>телепорт</q> и вот зачем в R9 к
				адресу переход были добавлены четвёрка вначале и порядок &minus;08.
				Далее проще:
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td colspan="6"></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td colspan="9"></td>
				</tr>
			</table>
			<p>
				Мы к нашему новому значению на этаже прибавляем номер этажа
				(целая часть Ra), заталкиваем новые координаты в Y, а в X оставляем план
				этажа. На самом деле в Rb могло получиться не только 1&hellip;3, но и
				другое, поэтому идёт переход на основную процедуру (она идёт
				следом с адреса 41 = F3, и мы её уже смотрели), которая отбросит все
				нестандартные этажи (одна цифра в числе), а также случай, когда битовая
				карта этажа просто не совпадёт с положением игрока. Обращаю внимание, что
				основная процедура запомнит в Rb полное значение нового положения, т.&#8239;е.
				если даже по этажу не пройти, мы запомним точку, куда
				хотели попасть. В случае удачи эта процедура автоматически обновит
				содержимое Ra.
			</p>
			<p>
				Вспомним про адрес перехода 38 = EA, куда мы попадаем при движении между
				этажами. Оказывается &ndash; банальный плюс, но с учётом раннего
				&plusmn;1 и извлеченного Ra, это <q>то, что доктор прописал</q> (вверх/вниз).
				Так вариант с движением вверх/вниз плавно влился в текущий кусок
				кода (очередной трюк).
			</p>
			<p>
				Ну вот основная часть кода рассмотрена, остался поиск клада (и разбойник!).
				Там тоже не всё так просто.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;70&#8202;|&#8202;</th>
					<td colspan="7"></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="but_b">ПП</span><span class="but">9</span></td>
				</tr>
				<tr>
					<th>&#8202;80&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">&oplus;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td colspan="6"></td>
				</tr>
			</table>
			<p>
				Тут мы для проверки битов (возможности взять клад) пользуемся
				основной процедурой. При этом в регистр Y ставим содержимое Ra, чтобы
				при удаче, оно же и сохранилось в Ra (это факт действия основной процедуры).
				Понятно, что если кладов уже нет (убран бит в нужном месте), то
				по нулю уходим на начало. Далее убираем бит клада из маски
				в регистре R0.
			</p>
			<p>
				А теперь мы приведём код, который из номера этажа получит
				шестнадцатеричную цифру, из соответствия 1 = E, 2 = D, 3 = C.
				В оригинале автор использовал для этого заранее сохранённую
				константу <q>E</q> и цикл с уменьшением её через регистр R0.
				Мы сделаем то же самое без
				использования дополнительных регистров и короче, пользуясь
				недокументированными возможностями.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;80&#8202;|&#8202;</th>
					<td colspan="4"></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td colspan="9"></td>
				</tr>
			</table>
			<p>
				Тут снова придётся вспомнить раздел про регистр X2 и команду
				<span class="but">ВП</span>, которая восстанавливает его. Сначала с помощью
				сложения с 10 (константа из R5) мы номер этажа загоняем во второй разряд.
				Тут порядок операндов важен, т.&#8239;к. последний
				<span class="but_b">П&rarr;x</span> и будет содержаться в X2.
				Затем с помощью инверсии и отсеканию целой части (первой цифры)
				мы получим, что нужная буква находится в первом разряде. Но в X вроде
				ещё что-то есть? Так вот, восстановление X2 через
				<span class="but">ВП</span>, сделает так, что
				при восстановлении X2 только первая цифра останется из X, т.&#8239;е. 2.00004
				восстановится в D.00004. То, что нам нужно. Ещё нужно помнить, что перед
				<span class="but">ВП</span> должна быть любая не X2-влияющая команда,
				которая будет выполнена, но результат проигнорирован. Обычно для этих
				целей используется <span class="but_k">К</span><span class="op_k">НОП</span>,
				но мы используем <span class="but_k">К</span><span class="op_k">СЧ</span>. Дело
				в том, что основная процедура может использовать
				<span class="but_k">К</span><span class="op_k">max</span> с нулём в Y, а это
				<q>сбрасывает</q> датчик случайных чисел. Для последующих игр
				(вдруг захочется пройти другой лабиринт) желательно <q>оживить</q> датчик
				случайных чисел (<q>с паршивой овцы хоть шерсти клок</q> &ndash; даже
				из игнорируемой команды пытаемся получить эффект). Идем далее.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">С/П</span></td>
					<td></td>
				</tr>
			</table>
			<p>
				Сохраняем полученную букву с дробной частью в Rb и оставляем его в стеке
				для информации игроку. Потом не только извлекаем старое значение ресурса,
				но и заодно отсекаем дробную часть от буквы (при косвенной адресации),
				чтобы потом преобразовать её в нужную добавку.
				Тут нужно пояснить, что именно происходит для вычисления <q>добавки</q>, в
				зависимости от значения регистра X (C, D или E).
				При вычитании срабатывают правила шестнадцатеричной арифметики.
			</p>
			<table class="center">
				<tr>
					<th>X</th>
					<th>После <q>&minus; 1</q></th>
					<th>После x<sup>2</sup></th>
				</tr>
				<tr>
					<th>C</th>
					<td>1</td><td>1 (сокровище)</td>
				</tr>
				<tr>
					<th>D</th>
					<td>2</td><td>4 (динамит)</td>
				</tr>
				<tr>
					<th>E</th>
					<td>3</td><td>9 (еды)</td>
				</tr>
			</table>
			<p>
				Код борьбы с разбойником полностью взят из оригинала. Главное,
				чтобы переключатель Р-ГРД-Г был в положении Р. Окончательное значение
				ресурса сохраняется.
			</p>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td colspan="9"></td>
					<td><span class="but_f">F</span><span class="op_f">sin</span></td>
				</tr>
				<tr>
					<th>&#8202;A0&#8202;|&#8202;</th>
					<td><span class="but">1</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<p>
				Вот собственно и всё, финальный <span class="but_b">В/О</span>
				по адресу A5 (или 00) <q>сыграет</q>, чтобы <q>сбить</q> программу с малой
				побочной ветви и вернуть в нормальное русло.
			</p>
		</details>

		<hr>

		<details id="id_demo_full" open="open">
			<summary><h3>Полный текст программы</h3></summary>
			<table class="center">
				<tr>
					<th>&#8202;#&#8202;|&#8202;</th>
					<th>00</th>
					<th>01</th>
					<th>02</th>
					<th>03</th>
					<th>04</th>
					<th>05</th>
					<th>06</th>
					<th>07</th>
					<th>08</th>
					<th>09</th>
				</tr>
				<tr>
					<th>&#8202;00&#8202;|&#8202;</th>
					<td><span class="but_b">В/О</span></td>
					<td><span class="but_b">С/П</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">e</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">&divide;</span></td>
				</tr>
				<tr>
					<th>&#8202;10&#8202;|&#8202;</th>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">63</span></td>
					<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">ВП</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
					<td><span class="but">D4</span></td>
					<td><span class="but_k">К</span><span class="op_k">ЗН</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				</tr>
				<tr>
					<th>&#8202;20&#8202;|&#8202;</th>
					<td><span class="but_b">БП</span></td>
					<td><span class="but">EA</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">6</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
					<td><span class="but">77</span></td>
					<td><span class="but">&times;</span></td>
				</tr>
				<tr>
					<th>&#8202;30&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="but_b">x=0</span><span class="but">9</span></td>
					<td><span class="but">.</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				</tr>
				<tr>
					<th>&#8202;40&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">&and;</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but">&larr;&rarr;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">max</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">a</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but">6</span></td>
				</tr>
				<tr>
					<th>&#8202;50&#8202;|&#8202;</th>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
					<td><span class="but">0</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
					<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
					<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>y</sup></span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
				</tr>
				<tr>
					<th>&#8202;60&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">8</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">d</span></td>
					<td><span class="but">2</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">7</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">4</span></td>
				</tr>
				<tr>
					<th>&#8202;70&#8202;|&#8202;</th>
					<td><span class="but">-</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&lt;0</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="op_k">&or;</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">БП</span><span class="but">9</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="but_b">ПП</span><span class="but">9</span></td>
				</tr>
				<tr>
					<th>&#8202;80&#8202;|&#8202;</th>
					<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">0</span></td>
					<td><span class="but_k">К</span><span class="op_k">&oplus;</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_k">К</span><span class="op_k">ИНВ</span></td>
					<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
					<td><span class="but_k">К</span><span class="op_k">СЧ</span></td>
				</tr>
				<tr>
					<th>&#8202;90&#8202;|&#8202;</th>
					<td><span class="but">ВП</span></td>
					<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but_b">П&rarr;x</span><span class="reg">b</span></td>
					<td><span class="but">1</span></td>
					<td><span class="but">-</span></td>
					<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
					<td><span class="but">+</span></td>
					<td><span class="but_b">С/П</span></td>
					<td><span class="but_f">F</span><span class="op_f">sin</span></td>
				</tr>
				<tr>
					<th>&#8202;A0&#8202;|&#8202;</th>
					<td><span class="but">1</span></td>
					<td><span class="but">+</span></td>
					<td><span class="but">&times;</span></td>
					<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
					<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
					<td colspan="5"></td>
				</tr>
			</table>
			<p>
				Начальные значения констант (которые не меняются между играми):
			</p>
			<ul>
				<li>R4 = 2</li>
				<li>R5 = 10</li>
				<li>R6 = D.<sup>|&minus;02</sup>
					(<span class="code"> Г.       -02</span>
				</li>
				<li>R7 = 0.5</li>
				<li>R8 = &minus;55 (с минусом)</li>
				<li>
					R9 = 4.F3<sup>|&minus;08</sup>
					(<span class="code"> 4. 3     -08</span>
				</li>
			</ul>
			<p>
				Вот последовательность для ввода констант:
				<br>
				<span class="but">5</span>&ensp;
				<span class="but">5</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">8</span>
				<br>
				<span class="but">4</span>&ensp;
				<span class="but">4</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">3</span>&ensp;
				<span class="but">В&uarr;</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but_k">К</span><span class="op_k">&or;</span>&ensp;
				<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">9</span>
				<br>
				<span class="but">1</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">5</span>
				<br>
				<span class="but">2</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">4</span>
				<br>
				<span class="but_f">F</span><span class="op_f">1/x</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">7</span>
				<br>
				<span class="but">2</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but_k">К</span><span class="op_k">ИНВ</span>&ensp;
				<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">1</span>&ensp;
				<span class="but_k">К</span><span class="op_k">[x]</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but">/-/</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">6</span>
			</p>
			<p>
				Положение переключателя Р-ГРД-Г должно быть в Р.
				Перед первой игрой (или каждой, если не хотите аккумулировать сокровища)
				регистр Rc нужно обнулить.
			</p>
			<p>
				И напомню порядок начала игры: задаётся начальное положение игрока на
				плане, например 1.0000001 &ndash; можно быстро получить как
				<span class="but_b">П&rarr;x</span><span class="but">9</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>
				(кто-то может подумать, что автор даже это предусмотрел, но нет,
				это, но только это, случайно так совпало).
				Затем <span class="but_b">БП</span>&ensp;
				<span class="but">48</span>&ensp;
				<span class="but_b">С/П</span>
			</p>
		</details>

		<hr>

		<details id="id_demo_tricks" open="open">
			<summary>
				<h3>Список трюков и недокументированных особенностей в программе</h3>
			</summary>
			которые мы использовали в программе для её сокращения
			(чтобы всё влезло).
			<ul>
				<li>
					Адрес перехода хранится в регистре для сокращения длины команды при
					косвенном обращении. Для R7 это команды по адресам 05, 46, 66, и 80.
					Для R8 &ndash; команда по адресу 62.
					Для R9 &ndash; команды по адресам 32, 71, 76, 79.
				</li>
				<li>
					Использование константы в двух смыслах. R5 &ndash; как коэффициент
					умножения по адресу 26, так и для <q>сдвига</q> во второй разряд
					по адресу 86.
					R7 &ndash; тоже как коэффициент умножения, но и как адрес перехода.
					R8 &ndash; кроме косвенной адресации используется отрицательным для
					проверки хода поиска клада по адресу 27. R9 &ndash; кроме косвенной
					адресации используется для корректировки округления по адресу 34.
				</li>
				<li>
					Цикличность адресного пространства. В процедуре после команды по адресу
					47 нет команды <span class="but_b">В/О</span>, и последняя команда в
					программе так же не <span class="but_b">В/О</span>,
					которая <q>удачно</q> расположена по нулевому адресу, для этих случаев.
				</li>
				<li>
					Использование хвоста одной процедуры для другой: основная подпрограмма,
					которая вызывается из многих мест,
					идёт сразу после окончания вычисления нового положения (адрес 41).
				</li>
				<li>
					<q>Слияние</q> окончания одной процедуры с другой для исключения команды
					перехода. В данном случае окончание инициализации и начало
					взлома стены по адресу 63. А также слияние двух веток вычисления
					(этажной и межэтажной) по адресу 38.
				</li>
				<li>
					Регистр X2. Несколько раз. Сохранение по адресу 10, чтобы
					извлечь по адресу 15, уже после того, как значение поучаствовало в
					операции сложения (экономия регистра), причём с применением не
					X2-влияющей <span class="pi">&pi;</span> вместо тройки. Сохранение по адресу 27 и
					восстановление по адресу 33 (экономия одной команды). Сохранение
					по адресу 85 и нестандартное восстановление по адресу 90
					(экономия нескольких команд).
				</li>
				<li>
					Использование ВП. Совмещение восстановления X2 с неявной операцией
					взятия дробной части по адресу 15. Объединение X2 и шестнадцатеричной
					цифры по адресу 90.
				</li>
				<li>
					Использование знаний косвенной адресации. Кроме значений в регистре
					R7 &hellip; R9, это <q>игнорирование</q> дробной части после сложения по
					адресам 13 или 38, и умышленное <q>отрубание</q> её по адресу 92.
					А также необычное использование регистра R0 в цикле по адресу 62
					с отрицательным счётчиком.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">ЗН</span> как команда
					умножения на 2 по адресу 19.
				</li>
				<li>
					<span class="but_k">К</span><span class="op_k">&or;</span> для
					проверки, что число содержит более одной цифры по адресу 30. Тут
					следует сравнить с оригиналом, где автор для проверки выхода за
					границы верх/низ использовал конъюнкцию квадрата нового положения
					и числа <span class="pi">&pi;</span>, проверяя нулевой бит (and 1) во втором разряде
					(после возведения в квадрат 5² = 25 и 16² = 256 его содержат,
					а 1² = 1, 2² = 4, 4² = 16, 8² = 64 &ndash; нет).
					Вроде, это выглядит как альтернатива, вместо команд
					<span class="but_b">П&rarr;x</span><span class="but">6</span>&ensp;
					<span class="but">&times;</span>&ensp;
					<span class="but_k">К</span><span class="op_k">&or;</span>
					использовать
					<span class="but_f">F</span><span class="op_f">&pi;</span>&ensp;
					<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>&ensp;
					<span class="but_k">К</span><span class="op_k">&and;</span>, при условии,
					чтобы <span class="pi">&pi;</span> было <q>справа</q> (чтобы правильно пройти
					процедуру очистки, благодаря отрезанию первой цифры и тому,
					что биты 2 и 3 у числа <span class="pi">&pi;</span>
					не пересекаются: для 3.14&hellip; это 1 и 4).
					Это даже можно сделать, длина
					программы не изменится, даже R6 можно сделать обычным 0.1.
					Но тут есть подводный камень:
					процедура очистки также запомнит число <q>справа</q> в Rb, а для процедуры
					подрыва и проверки выхода за границу Rb такое количество цифр в числе
					недопустимо (процедура очистки вместо очистки внесёт в Ra что-то
					случайное). Вот так, иногда приходится использовать недокументированные
					возможности для корректности поведения алгоритма
					(без увеличения длины программы).
				</li>
				<li>
					Использование шестнадцатеричной арифметики. Содержимое регистра R6
					используется то как 0.1 по адресу 26, то как увеличения количества
					значащих цифр по адресу 29. Операция вычитания по адресу 95 приводит
					цифры C, D, E к более удобным 1, 2, 3.
				</li>
				<li>
					Использование <span class="but_k">К</span><span class="op_k">max</span>
					в нестандартном случае для <q>просвечивания</q> нуля из Y по адресу 45.
					Тут нужно заметить, что процедура по адресу 41 может быть реализована
					разными способами. Например и так:
					<span class="but">&larr;&rarr;</span>&ensp;
					<span class="but_b">x&rarr;П</span><span class="reg">b</span>&ensp;
					<span class="but_k">К</span><span class="op_k">&and;</span>&ensp;
					<span class="but_k">К</span><span class="op_k">{x}</span>&ensp;
					<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">7</span>&ensp;
					<span class="but_b">П&rarr;x</span><span class="reg">b</span>&ensp;
					<span class="but_b">x&rarr;П</span><span class="reg">a</span>.
					Но при этом в стеке останется план этажа/кладов при неудаче. А этой
					подсказки хотелось бы избежать, т.&#8239;к. многие команды игры подразумевают
					дополнительную информацию в регистре Y после остановки.
					При том порядке что у нас, план этажа/кладов безвозвратно
					теряется из стека в любом случае (удача или нет).
				</li>
			</ul>
			<p>
				Как не странно, даже такую <q>плотную</q> программу можно ещё улучшить.
				Например, если потребовать в начале каждой игры
				после ввода начального положения нажатия
				<span class="but">В&uarr;</span> перед <span class="but_b">C/П</span>.
				Тогда начало можно переместить на адрес 44,
				где уже есть команда <span class="but_b">x&rarr;П</span><span class="reg">b</span>,
				и убрать её с адреса 48. При этом, кстати, будет реализован редкий
				трюк, связанный с исполнением одних и тех же команд, но в
				разных адресных ветках вычисления (и с разными целями и результатом).
				А потом, например, использовать
				сэкономленную команду для начального обнуления количества сокровищ, например
				<span class="but_b">x&rarr;П</span><span class="reg">с</span> по адресу 54.
			</p>
		</details>

	</details>

	<hr>

	<details id="id_commands" open="open">
		<summary><h2>Приложение. Все команды</h2></summary>
		<p>
			Список всех 256 команд ПМК с дополнительным комментарием, в случае
			наличия недокументированных возможностей.
		</p>
		<table>
			<tr>
				<th>Код</th>
				<th>Вид</th>
				<th>Название</th>
				<th>Комментарий</th>
			</tr>
			<tr>
				<th>00&hellip;09</th>
				<td class="center nowrap">
					<span class="but">0</span>&hellip;<span class="but">9</span>
				</td>
				<td>Ввод числа</td>
				<td>
					Ввод цифр идёт даже через границу
					<span class="but_b">С/П</span>. Т.&#8239;е. если в начале программы
					идёт цифра(ы), а перед её запуском тоже ввод, то он продолжится.
					То же касается и разделителя <span class="but">.</span>, он может
					как заканчивать ввод в режиме вычислений, так и начинать в
					программе &ndash; будет воспринят как разделитель целой и дробной
					части.
					<br>
					Второе нажатие <span class="but">.</span> для разделения разрядов
					игнорируется.
					<br>
					Если предыдущая команда была не ввод цифры или разделителя, а так
					же не команда <span class="but">В&uarr;</span>, то предварительно
					осуществляется сдвиг стека под новое число.
				</td>
			</tr>
			<tr>
				<th>0A</th>
				<td class="center nowrap">
					<span class="but">.</span>
				</td>
				<td>Разделитель целой и дробной части</td>
				<td>
					Кроме того, что указано выше восстановление X2&rarr;X
					в программном режиме. См.
					<a href="#id_x2_point">Таинственный регистр X2</a>.
				</td>
			</tr>
			<tr>
				<th>0B</th>
				<td class="center nowrap">
					<span class="but">/-/</span>
				</td>
				<td>Смена знака</td>
				<td>
					Предыдущее значение НЕ копируется в X1.
					Cм. также <a href="#id_x2_exp_neg">Таинственный регистр X2</a>.
					Если смена знака идёт после ввода цифры, и далее снова идёт
					ввод цифры, то стек не сдвигается, а новое вводимое значение
					заменяет в регистре X то, что было после смены знака.
				</td>
			</tr>
			<tr>
				<th>0C</th>
				<td class="center nowrap">
					<span class="but">ВП</span>
				</td>
				<td>Ввод порядка</td>
				<td>
					Для многих чисел ввод порядка означает умножение на 10 в соответствующей степени.
					<br>
					После ввода порядка можно ещё раз нажать <span class="but">ВП</span> и
					ввести число &ndash; в этом случае порядки складываются.
					<br>
					Знак порядка можно ввести как сразу после <span class="but">ВП</span>,
					так и после ввода цифр.
					<br>
					Если мантисса регистра X нулевая, то первая цифра заменяется на 1,
					причём, если была нажата смена знака
					<span class="but">/-/</span> до команды
					<span class="but">ВП</span>, то будет уже &minus;1, даже в
					программном режиме. Причём у <q>минус</q> нуля до этого
					знак не отображается. На самом деле в программном режиме
					это будет восстановление &minus;0 с увеличением первой
					цифры на 1, как указано в разделе
					<a href="#id_x2_exp_combine">Таинственный регистр X2</a>.
					Например, выполнение программы
					<table class="center">
						<tr>
							<th>&#8202;#&#8202;|&#8202;</th>
							<th>00</th>
							<th>01</th>
							<th>02</th>
							<th>03</th>
							<th>04</th>
							<th>05</th>
							<th>06</th>
							<th>07</th>
							<th>08</th>
							<th>09</th>
						</tr>
						<tr>
							<th>&#8202;00&#8202;|&#8202;</th>
							<td><span class="but_cx">Cx</span></td>
							<td><span class="but">/-/</span></td>
							<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
							<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
							<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
							<td><span class="but">ВП</span></td>
							<td><span class="but_b">С/П</span></td>
							<td colspan="3"></td>
						</tr>
					</table>
					приведёт к &minus;А (<span class="code">--.          </span>).
					<br>
					Пример для нестандартной нулевой мантиссы. Возьмём число
					<span class="code">200000000.   </span> (двойка на месте знака!),
					которое получается после косвенного обращения через R4&hellip;R6,
					если до того там содержалось 99999999. Тут после нажатия
					<span class="but">ВП</span> число превратится в
					<span class="code">210000000.   </span>.
				</td>
			</tr>
			<tr>
				<th>0D</th>
				<td class="center nowrap">
					<span class="but_cx">Сx</span>
				</td>
				<td>Сброс X в ноль</td>
				<td>
					Важное свойство &ndash; стек не двигается.
					Предыдущее значение НЕ копируется в X1. Если последующий ввод
					будет не команда, а цифра, то ввод пойдёт в регистр X без
					сдвига стека с заменой нуля.
				</td>
			</tr>
			<tr>
				<th>0E</th>
				<td class="center nowrap">
					<span class="but">В&uarr;</span>
				</td>
				<td>Сдвиг стека</td>
				<td>
					Если последующая команда &ndash; ввод числа, то будет ввод в X, если
					извлечение из памяти или
					<span class="but_f">F</span><span class="op_f">&pi;</span> &ndash;
					то стек ещё раз сдвинется.
				</td>
			</tr>
			<tr>
				<th>0F</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">Вx</span>
				</td>
				<td>Полный сдвиг, включая X1</td>
				<td>
					Единственная документированная и вводимая команда с цифрой F в коде.
				</td>
			</tr>
			<tr>
				<th>10</th>
				<td class="center nowrap">
					<span class="but">+</span>
				</td>
				<td>Сложение</td>
				<td>
					Результат проверяется только при X&rarr;X2, т.&#8239;е. можно использовать
					для получения сверхчисел.
				</td>
			</tr>
			<tr>
				<th>11</th>
				<td class="center nowrap">
					<span class="but">-</span>
				</td>
				<td>Вычитание</td>
				<td>
					Результат проверяется только при X&rarr;X2, т.&#8239;е. можно использовать
					для получения сверхчисел.
				</td>
			</tr>
			<tr>
				<th>12</th>
				<td class="center nowrap">
					<span class="but">&times;</span>
				</td>
				<td>Умножение</td>
				<td>
					Результат проверяется при X&rarr;X2, т.&#8239;е. можно использовать
					для получения сверхчисел.
				</td>
			</tr>
			<tr>
				<th>13</th>
				<td class="center nowrap">
					<span class="but">&divide;</span>
				</td>
				<td>Деление</td>
				<td>
					Ошибка деления на ноль возникает безусловно, остальное при
					X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>14</th>
				<td class="center nowrap">
					<span class="but">&larr;&rarr;</span>
				</td>
				<td>Обмен X и Y</td>
				<td></td>
			</tr>
			<tr>
				<th>15</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>
				</td>
				<td>Возведение в степень числа 10</td>
				<td>
					Аргументы на переполнение порядка (сверхчисло) проверяется
					безусловно, а не при X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>16</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">e<sup>x</sup></span>
				</td>
				<td>Возведение в степень числа e (экспонента)</td>
				<td>
					Аргументы на переполнение порядка (сверхчисло) проверяется
					безусловно, а не при X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>17</th>
				<td class="center nowrap"><span class="but_f">F</span><span class="op_f">lg</span></td>
				<td>Десятичный логарифм</td>
				<td>
					Аргументы (должно быть больше нуля) проверяется безусловно, а не
					при X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>18</th>
				<td class="center nowrap"><span class="but_f">F</span><span class="op_f">ln</span></td>
				<td>Натуральный (экспоненциальный) логарифм</td>
				<td>
					Аргументы (должно быть больше нуля) проверяется безусловно, а не
					при X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>19</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">sin<sup>-1</sup></span>
				</td>
				<td>Арксинус</td>
				<td>
					Аргументы (должно |X|&les;1) проверяется безусловно, а не при
					X&rarr;X2. Для ГРД/Г и X = 0 выводит X = 00.
				</td>
			</tr>
			<tr>
				<th>1A</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">cos<sup>-1</sup></span>
				</td>
				<td>Арккосинус</td>
				<td>
					Аргументы (должно |X|&les;1) проверяется безусловно, а не при
					X&rarr;X2. arccos(1) для ГРД/Г даёт ненормализованное 00.
				</td>
			</tr>
			<tr>
				<th>1B</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">tg<sup>-1</sup></span>
				</td>
				<td>Арктангенс</td>
				<td>
					Для чисел x &ges; 1<sup>8</sup> результат выдаёт близкий к
					<q>максимуму</q> &ndash; для радиан это почти &pi;/2, для градов 99.999999.
					Может быть вычислен и для 1<sup>100</sup>
					в радианах (из-за того, что порядок снижается), но не градусах.
				</td>
			</tr>
			<tr>
				<th>1C</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">sin</span>
				</td>
				<td>Синус</td>
				<td>
					Аргументы (должно |X|&lt;1<sup>10</sup>) проверяется безусловно, а не при
					X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>1D</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">cos</span>
				</td>
				<td>Косинус</td>
				<td>
					Аргументы (должно |X|&lt;1<sup>10</sup>) проверяется безусловно, а не при
					X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>1E</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">tg</span>
				</td>
				<td>Тангенс</td>
				<td>
					Аргументы (должно |X|&lt;1<sup>10</sup>) проверяется безусловно, а не при X&rarr;X2.
					При X = <span class="pi">&pi;</span>/2 + n &times; <span class="pi">&pi;</span>
					тоже будет ошибка.
				</td>
			</tr>
			<tr>
				<th>1F</th>
				<td></td>
				<td>Пустой оператор</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>20</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">&pi;</span>
				</td>
				<td>Число <span class="pi">&pi;</span> (пи)</td>
				<td>
					Кроме того, что сдвигает стек (это документировано), также копирует
					предыдущее X в X1, как арифметическая операция (а это нет).
				</td>
			</tr>
			<tr>
				<th>21</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">&radic;</span>
				</td>
				<td>Квадратный корень</td>
				<td>Аргументы проверяется безусловно (X&ges;0), а не при X&rarr;X2.</td>
			</tr>
			<tr>
				<th>22</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>
				</td>
				<td>Возведение в квадрат</td>
				<td>
					Результат проверяется при X&rarr;X2, т.&#8239;е. можно использовать
					для получения сверхчисел.
				</td>
			</tr>
			<tr>
				<th>23</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">1/x</span>
				</td>
				<td>Обратная величина</td>
				<td>
					Ошибка деления на ноль возникает безусловно, остальное
					при X&rarr;X2.
				</td>
			</tr>
			<tr>
				<th>24</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">x<sup>y</sup></span>
				</td>
				<td>Возведение в степень.</td>
				<td>
					Ошибка, если X &les; 0. Не принимает отрицательный X, даже когда это
					математически допустимо.
					<br>
					Ошибка переполнения возникает безусловно, а не при X&rarr;X2.
					<br>
					Стек не сокращается, в отличие от обычных арифметических операций.
					Т.&#8239;е. число в Y остаётся на месте (позволяя ещё раз возвести в ту
					же степень).
				</td>
			</tr>
			<tr>
				<th>25</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">&orarr;</span>
				</td>
				<td>Подтягивание стека</td>
				<td></td>
			</tr>
			<tr>
				<th>26</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;</span>
				</td>
				<td>
					Перевод угловых или временных величин из обычной формы в часть целой
				</td>
				<td>
					Если дробное значение &ges;0.6, то будет ошибка.
					Целая часть не меняется, даже если шестнадцатеричное число.
				</td>
			</tr>
			<tr>
				<th>27</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="but">-</span>
				</td>
				<td>Ошибка</td>
				<td><span class="code"> ЕГГ0Г      </span>.</td>
			</tr>
			<tr>
				<th>28</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="but">&times;</span>
				</td>
				<td>Ошибка</td>
				<td><span class="code"> ЕГГ0Г      </span>.</td>
			</tr>
			<tr>
				<th>29</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="but">&divide;</span>
				</td>
				<td>Ошибка</td>
				<td><span class="code"> ЕГГ0Г      </span>.</td>
			</tr>
			<tr>
				<th>2A</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
				</td>
				<td>
					Перевод угловых или временных величин из обычной формы в часть
					целой, включая секунды
				</td>
				<td>
					Если дробное значение &ges;0.6, то будет ошибка.
					Целая часть не меняется, даже если шестнадцатеричное число.
				</td>
			</tr>
			<tr>
				<th>2B&hellip;2E</th>
				<td></td>
				<td>Ошибка</td>
				<td><span class="code"> ЕГГ0Г      </span>.</td>
			</tr>
			<tr>
				<th>2F</th>
				<td></td>
				<td>Пустой оператор</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>30</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;&quot;</span>
				</td>
				<td>
					Перевод угловых или временных величин из части целого в обычную
					форму, включая секунды
				</td>
				<td>
					Если дробная часть &les; 2.<sup>|&minus;07</sup>, то обратное преобразование
					уже не срабатывает. Если = 1.<sup>|&minus;07</sup> то уже и прямое преобразование
					не меняет значение. Если целая часть шестнадцатеричное число и нет
					дробной части или оно = 1.<sup>|&minus;07</sup> &ndash; оно
					<a href="#is_glos_normalization">нормализуется</a>, как в
					операциях с шестнадцатеричными цифрами. Иначе остаётся без изменений.
				</td>
			</tr>
			<tr>
				<th>31</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">&mid;x&mid;</span>
				</td>
				<td>Модуль</td>
				<td>
					Удаляет знак (делает знакоцифру = 1, что выглядит как пустое
					место и соответствует положительным числам).
				</td>
			</tr>
			<tr>
				<th>32</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">ЗН</span>
				</td>
				<td>Знак числа</td>
				<td>У отрицательного нуля знак положительный (т.е. для нуля знакоцифра игнорируется).</td>
			</tr>
			<tr>
				<th>33</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">&deg;&larr;&prime;</span>
				</td>
				<td>
					Перевод угловых или временных величин из части целого в обычную
					форму
				</td>
				<td>
					Если дробная часть &les; 2.<sup>|&minus;07</sup>, то обратное преобразование
					уже не срабатывает. Если = 1.<sup>|&minus;07</sup> то уже и прямое преобразование
					не меняет значение. Если целая часть шестнадцатеричное число и нет
					дробной части или оно = 1.<sup>|&minus;07</sup> &ndash; оно
					<a href="#is_glos_normalization">нормализуется</a>, как в
					операциях с шестнадцатеричными цифрами. Иначе остаётся без изменений.
				</td>
			</tr>
			<tr>
				<th>34</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">[x]</span>
				</td>
				<td>Целая часть</td>
				<td>
					Простое отбрасывание дробной части, а не математическое нахождение
					целой части, т.&#8239;е. [&minus;1.2] = &minus;1, а не &minus;2.
					<br>
					Если число целое и шестнадцатеричное &ndash; оно преобразуется, как в
					операциях с шестнадцатеричными цифрами. Если есть дробная часть, то
					целая шестнадцатеричная часть остаётся без изменений.
				</td>
			</tr>
			<tr>
				<th>35</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">{x}</span>
				</td>
				<td>Дробная часть</td>
				<td>
					Простое отбрасывание целой части, а не математическое нахождение
					дробной части, т.&#8239;е. {&minus;1.2} = &minus;0.2, а не 0.8.
					<br>
					Для целых чисел по модулю &lt; 10.<sup>|+7</sup> (точнее числа, которым
					нужно меньше восьми знакомест) получается отрицательный
					ноль (в сравнениях идёт как отрицательное число и как ноль). Т.&#8239;е.
					{&minus;1234567} = &minus;0, но {&minus;12345678} = 0.
					<br>
					Шестнадцатеричные цифры (в дробной части) сохраняются.
				</td>
			</tr>
			<tr>
				<th>36</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">max</span>
				</td>
				<td>Максимум</td>
				<td>
					Ноль исключение &ndash; самое большое число.
					<br>
					Обмена X и Y не происходит, т.&#8239;е. либо X и Y после операции
					совпадают (в Y был максимум), либо остаются как есть
					(кроме копирования X в X1).
				</td>
			</tr>
			<tr>
				<th>37</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">&and;</span>
				</td>
				<td>Логическое умножение (AND)</td>
				<td rowspan="4">
					В логических операциях первая цифра заменяется на 8, а над
					остальными цифрами мантиссы проводится побитовая операция, как с
					шестнадцатеричными числами. Порядок и знак исходных чисел
					значения не имеют, они могут быть даже пустышкой.
					Результат всегда в форме 8.HHHHHHH
					<br>
					Стек для двухоперандных операций не сокращается, что позволяет
					выполнить операцию ещё раз.
					<br>
					Перед выполнением операнды нормализуются (убираются ведущие нули)!
				</td>
			</tr>
			<tr>
				<th>38</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">&or;</span>
				</td>
				<td>Логическое сложение (OR)</td>
			</tr>
			<tr>
				<th>39</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">&oplus;</span>
				</td>
				<td>Логическое исключающее или (XOR)</td>
			</tr>
			<tr>
				<th>3A</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">ИНВ</span>
				</td>
				<td>Логическая инверсия (NOT)</td>
			</tr>
			<tr>
				<th>3B</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">СЧ</span>
				</td>
				<td>Случайное число</td>
				<td>
					Единица не бывает. Ноль бывает в редких случаях (когда в Y
					шестнадцатеричное число, то последовательность может выдавать и ноль).
					Датчик не очень хороший, часто циклится (от применения команд с К).
					<br>
					Сбросить на начало (как при включении) можно с помощью операции
					<span class="but_k">К</span><span class="op_k">max</span>,
					когда регистр Y нулевой.
				</td>
			</tr>
			<tr>
				<th>3C</th>
				<td></td>
				<td>Ошибка</td>
				<td><span class="code"> ЕГГ0Г      </span>.</td>
			</tr>
			<tr>
				<th>3D</th>
				<td></td>
				<td>
					То же, что и команда
					<span class="but_k">К</span><span class="op_k">&deg;&rarr;&prime;&quot;</span>
					(код 2A)
				</td>
				<td></td>
			</tr>
			<tr>
				<th>3E</th>
				<td></td>
				<td>Копирование Y в X (а X&rarr;X1)</td>
				<td>
					Те же действия, что и пара команд
					<span class="but_f">F</span><span class="op_f">&orarr;</span>&ensp;
					<span class="but">В&uarr;</span>, только не X2-влияющая.
				</td>
			</tr>
			<tr>
				<th>3F</th>
				<td></td>
				<td>Пустой оператор</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>40&hellip;4E</th>
				<td class="center nowrap">
					<span class="but_b">x&rarr;П</span><span class="but">R</span>
				</td>
				<td>Сохранение X в регистр R0&hellip;Re</td>
				<td></td>
			</tr>
			<tr>
				<th>4F</th>
				<td></td>
				<td>Сохранение X в регистр R0</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>50</th>
				<td class="center nowrap">
					<span class="but_b">С/П</span>
				</td>
				<td>Стоп/пуск</td>
				<td></td>
			</tr>
			<tr>
				<th>51</th>
				<td class="center nowrap">
					<span class="but_b">БП</span>
				</td>
				<td>Безусловный переход</td>
				<td></td>
			</tr>
			<tr>
				<th>52</th>
				<td class="center nowrap">
					<span class="but_b">В/О</span>
				</td>
				<td>Возврат обратно</td>
				<td>
					Стек обратных адресов подпрограмм из 5 ячеек, вначале нулевых.
					При возврате из подпрограммы берётся значение верхней ячейки
					стека + 1 (для определения точки возврата) и стек сдвигается,
					поэтому сразу после включения ПМК команда
					<span class="but_b">В/О</span> эквивалентна
					<span class="but_b">БП</span><span class="but">01</span>.
					Но если стек адресов возврата заполнился до конца, то последний
					адрес стека начинает копироваться и <span class="but_b">В/О</span>
					будет на этот адрес + 1. Для зануления стека, в этом случае,
					можно воспользоваться знаниями Еггогологии и вызвать нулевого 3Г0ГГа:
					<span class="but_cx">Cx</span>&ensp;
					<span class="but">В&uarr;</span>&ensp;
					<span class="but">&divide;</span>&ensp;
					<span class="but">ВП</span>&ensp;
					<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>&ensp;
					<span class="but_cx">Cx</span>&ensp;
					<span class="but">&larr;&rarr;</span>&ensp;
					<span class="but_cx">Cx</span>.
					Или запустить ненадолго бесконечную программу из одного
					оператора, например
					<span class="but_k">K</span><span class="but_b">ПП</span><span class="but">9</span>,
					при условии, что R9 = 0.
				</td>
			</tr>
			<tr>
				<th>53</th>
				<td class="center nowrap">
					<span class="but_b">ПП</span>
				</td>
				<td>Вызов подпрограммы</td>
				<td>
					Переход на адрес подпрограммы, указанный следующей командой. Этот
					адрес запоминается в стеке обратных адресов
					(см. <span class="but_b">В/О</span>).
				</td>
			</tr>
			<tr>
				<th>54</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_k">НОП</span>
				</td>
				<td>Пустой оператор</td>
				<td></td>
			</tr>
			<tr>
				<th>55</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="but">1</span>
				</td>
				<td>Пустой оператор</td>
				<td></td>
			</tr>
			<tr>
				<th>56</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="but">2</span>
				</td>
				<td>Пустой оператор</td>
				<td></td>
			</tr>
			<tr>
				<th>57</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">x&ne;0</span>
				</td>
				<td>Если не ноль</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X не равно нулю (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>58</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">L2</span>
				</td>
				<td>Цикл по регистру R2</td>
				<td></td>
			</tr>
			<tr>
				<th>59</th>
				<td class="center nowrap"
					><span class="but_f">F</span><span class="op_f">x&ge;0</span>
				</td>
				<td>Если больше или равно нулю</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X больше или равно нулю (в большинстве языков обычно наоборот,
					переход на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>5A</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">L3</span>
				</td>
				<td>Цикл по регистру R3</td>
				<td></td>
			</tr>
			<tr>
				<th>5B</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">L1</span>
				</td>
				<td>Цикл по регистру R1</td>
				<td></td>
			</tr>
			<tr>
				<th>5C</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">x&lt;0</span>
				</td>
				<td>Если меньше нуля</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X меньше нуля (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>5D</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">L0</span>
				</td>
				<td>Цикл по регистру R0</td>
				<td></td>
			</tr>
			<tr>
				<th>5E</th>
				<td class="center nowrap">
					<span class="but_f">F</span><span class="op_f">x=0</span>
				</td>
				<td>Если равно нулю</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X равно нулю (в большинстве языков обычно наоборот, переход на
					адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>5F</th>
				<td></td>
				<td>Зависание</td>
				<td>
					Визуально воспринимается как зависание. ПМК не реагирует на ввод
					команд и ничего не отображает.
					<br>
					Обычным образом такую команду не ввести.
				</td>
			</tr>
			<tr>
				<th>60&hellip;6E</th>
				<td class="center nowrap">
					<span class="but_b">П&rarr;x</span><span class="but">R</span>
				</td>
				<td>Извлечение из регистра R0&hellip;Re в X</td>
				<td></td>
			</tr>
			<tr>
				<th>6F</th>
				<td></td>
				<td>Извлечение из регистра R0 в X</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>70&hellip;7E</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">R</span>
				</td>
				<td>
					Косвенный условный переход при неравенстве нулю, адрес перехода в
					регистре R0&hellip;Re
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X не равно нулю (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>7F</th>
				<td></td>
				<td>
					Косвенный условный переход при неравенстве нулю, адрес перехода в
					регистре R0
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X не равно нулю (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
					<br>
					Обычным образом такую команду не ввести.
				</td>
			</tr>
			<tr>
				<th>80&hellip;8E</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="but_b">БП</span><span class="but">R</span>
				</td>
				<td>
					Косвенный безусловный переход на адрес перехода в регистре
					R0&hellip;Re
				</td>
				<td></td>
			</tr>
			<tr>
				<th>8F</th>
				<td></td>
				<td>Косвенный безусловный переход на адрес перехода в регистре R0</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>90&hellip;9E</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="but">R</span>
				</td>
				<td>
					Косвенный условный переход, если больше или равно нулю, адрес
					перехода в регистре R0&hellip;Re
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X больше или равно нулю (в большинстве языков обычно наоборот,
					переход на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>9F</th>
				<td></td>
				<td>
					Косвенный условный переход, если больше или равно нулю, адрес
					перехода в регистре R0
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X больше или равно нулю (в большинстве языков обычно наоборот,
					переход на адрес при выполнении условия).
					<br>
					Обычным образом такую команду не ввести.
				</td>
			</tr>
			<tr>
				<th>A0&hellip;AE</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="but_b">ПП</span><span class="but">R</span>
				</td>
				<td>
					Косвенный вызов подпрограммы по адресу в регистре R0&hellip;Re
				</td>
				<td></td>
			</tr>
			<tr>
				<th>AF</th>
				<td></td>
				<td>Косвенный вызов подпрограммы по адресу в регистре R0</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>B0&hellip;BE</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">R</span>
				</td>
				<td>
					Косвенное сохранение X в регистр, по номеру в регистре
					R0&hellip;Re
				</td>
				<td></td>
			</tr>
			<tr>
				<th>BF</th>
				<td></td>
				<td>Косвенное сохранение X в регистр, по номеру в регистре R0</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>C0&hellip;CE</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="but">R</span>
				</td>
				<td>
					Косвенный условный переход, если меньше нуля, адрес перехода в
					регистре R0&hellip;Re
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X меньше нуля (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>CF</th>
				<td></td>
				<td>
					Косвенный условный переход, если меньше нуля, адрес перехода в
					регистре R0
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X меньше нуля (в большинстве языков обычно наоборот, переход
					на адрес при выполнении условия).
					<br>
					Обычным образом такую команду не ввести.
				</td>
			</tr>
			<tr>
				<th>D0&hellip;DE</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">R</span>
				</td>
				<td>
					Косвенное извлечение X из регистра, по номеру в регистре
					R0&hellip;Re
				</td>
				<td></td>
			</tr>
			<tr>
				<th>DF</th>
				<td></td>
				<td>Косвенное извлечение X из регистра, по номеру в регистре R0</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
			<tr>
				<th>E0&hellip;EE</th>
				<td class="center nowrap">
					<span class="but_k">К</span><span class="op_f">x=0</span><span class="but">R</span>
				</td>
				<td>
					Косвенный условный переход, если равно нулю, адрес перехода в
					регистре R0&hellip;Re
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X равно нулю (в большинстве языков обычно наоборот, переход на
					адрес при выполнении условия).
				</td>
			</tr>
			<tr>
				<th>EF</th>
				<td></td>
				<td>
					Косвенный условный переход, если равно нулю, адрес перехода в
					регистре R0
				</td>
				<td>
					Пропуск адреса перехода, и выполнение следующей после него команды,
					если X равно нулю (в большинстве языков обычно наоборот, переход на
					адрес при выполнении условия).
					<br>
					Обычным образом такую команду не ввести.
				</td>
			</tr>
			<tr>
				<th>F0&hellip;FF</th>
				<td></td>
				<td>Пустой оператор</td>
				<td>Обычным образом такую команду не ввести.</td>
			</tr>
		</table>
		<p>
			Все команды, которые приводят к ошибке (при проверке границ,
			неверном аргументе или просто помеченные, как приводящие к ошибке),
			успевают скопировать X &rarr; X1 перед исполнением и выдачей ошибки.
			Но если возникает переполнение (слишком большое число), то
			копирование X &rarr; X1 будет в операции, вызвавшей переполнения, а
			не когда ошибка проявится из-за перевода
			X &rarr; X2 (понятно, это только в программном режиме).
			Пример, в программе
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="but_b">ПП</span><span class="reg">c</span></td>
				<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
				<td><span class="but">&divide;</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="6"></td>
			</tr>
		</table>
		<p>
			ошибка возникнет на шаге 02 (деление на ноль), и &pi; попадёт в X1.
			А если так:
		</p>
		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
				<td><span class="but">8</span></td>
				<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
				<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
				<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
				<td><span class="but_k">К</span><span class="op_k">НОП</span></td>
				<td><span class="but">/-/</span></td>
				<td><span class="but">ВП</span></td>
				<td colspan="2"></td>
			</tr>
		</table>
		<p>
			то переполнение будет на шаге 04, именно там
			10.<sup>|+64</sup> попадёт в X1, а команда <span class="but">/-/</span>
			только проявит ошибку на экране.
		</p>

		<hr>

		<details id="id_F_commands" open="open">
			<summary><h3>Команды с кодом F</h3></summary>
			<p>
				Некоторые команды с цифрой F в коде можно получить тоже
				недокументированным образом.
			</p>
			<p>
				Команды F0&hellip;FE получаются по адресам 30&hellip;44 после выполнения
				в режиме вычислений пары команд
				<span class="but_b">В/О</span>&ensp;
				<span class="but_k">К</span><span class="but_b">ПП</span><span class="but">R</span>
				(R = 0&hellip;e), которые переведут ПМК в режим ввода программы и вставят
				код с цифрой F. При этом в регистрах R0&hellip;R3 должно быть число
				заканчивающееся на 1 или 2 (точнее такое, чтобы после косвенной адресации
				заканчивалось на 1 или 2). Если там будет другое (например, ноль, как
				после включения ПМК), то для R1&hellip;R3 вставится F0&hellip;F2 по
				адресу 30&hellip;32, а для R0 это будет самый быстрый способ получить
				3Г0ГГа (причём перехода в режим ввода программы не произойдёт,
				но, увы, этот 3Г0ГГ очистку стека возврата не делает).
			</p>
			<p>
				Так же по адресам 50&hellip;59 можно вставить команды, начинающиеся
				с цифры F. При этом можно даже управлять, на какую цифру заканчивается
				и по какому адресу именно вставиться (в пределах указанного диапазона).
				Для этого сначала сделаем ЕГГ0Г (как число, а не ошибку). Например, как
				<span class="but">5</span>&ensp;
				<span class="but">0</span>&ensp;
				<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>&ensp;
				<span class="but_f">F</span><span class="op_f">x<sup>2</sup></span>.
				Можно его и сохранить, чтобы повторить шаги.
				После появления ЕГГ0Га (так или извлечения из регистра) набираем
				<span class="but">ВП</span>&ensp;
				<span class="but">{D1}</span>&ensp;
				<span class="but">{D2}</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">0</span>, где {D1} и {D2} цифры. Так вот, в
				этот момент ПМК перейдёт в режим ввода программы и по адресу 5{D1},
				и будет вставлена команда F{D2}. Т.&#8239;е. при вводе
				<span class="but">ВП</span>&ensp;
				<span class="but">3</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">.</span>&ensp;
				<span class="but">0</span>, по адресу 53 будет вставлена команда F7.

			</p>
			<p>
				Последовательность 5 команд FF (через одну) можно получить
				по любому адресу, если стек возврата <q>забить</q> числом, начинающимся
				с пустышки, и перед переходом в режим ПРГ нажимается
				<span class="but">БП</span> <q>Адрес</q>. Тогда
				начиная с адреса <q>Адрес</q>&minus;11 через одну будут проставлены команды FF.
				<br>
				Для начала получим адрес с начальной пустышкой, например число F8, и
				сохраним в регистр, например в R7. Не забыть при этом в конце убрать
				такое число с начальной пустышкой из RX!
				<br>
				<span class="but">8</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but">8</span>&ensp;
				<span class="but">В&uarr;</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but">7</span>&ensp;
				<span class="but_k">K</span><span class="op_k">&or;</span>&ensp;
				<span class="but_k">K</span><span class="op_k">{x}</span>&ensp;
				<span class="but">ВП</span>&ensp;
				<span class="but">2</span>&ensp;
				<span class="but_b">x&rarr;П</span><span class="but">7</span>&ensp;
				<span class="but_cx">Cx</span>
				<br>
				Теперь по этому <q>темному</q> адресу вставим команду вызова подпрограммы
				по R7:
				<br>
				<span class="but_k">K</span><span class="but_b">БП</span><span class="but">7</span>&ensp;
				<span class="but_f">F</span><span class="op_f">ПРГ</span>&ensp;
				<span class="but_k">K</span><span class="but_b">ПП</span><span class="but">7</span>&ensp;
				<span class="but_f">F</span><span class="op_f">АВТ</span>&ensp;
				<span class="but_k">K</span><span class="but_b">БП</span><span class="but">7</span>
				<br>
				Потом 5 раз, чтобы забить стек возврата, нажмём <span class="but_b">ПП</span>
				<br>
				После этого уже выбираем, где нам нужны команды FF. Пусть мы хотим их с
				адреса 80. Тогда делаем переход на 80+11=91
				<span class="but_b">БП</span><span class="but">91</span> и
				<span class="but_f">F</span><span class="op_f">ПРГ</span>&ensp;
				<span class="but_f">F</span><span class="op_f">АВТ</span>
				<br>
				Теперь по адресам 80, 82, 84, 86, 88 добавилась команда FF. Если нужно
				побольше, например ещё и по адресам 81, 83, 85, 87, 89, то просто снова
				заполним стек возврата
				<span class="but_k">K</span><span class="but_b">БП</span><span class="but">7</span>,
				5 раз <span class="but_b">ПП</span>, и после
				<span class="but_b">БП</span><span class="but">92</span> и
				<span class="but_f">F</span><span class="op_f">ПРГ</span>&ensp;
				<span class="but_f">F</span><span class="op_f">АВТ</span>
				получим то, что хотели.
				<br>
				Не забудьте в конце почистить стек возврата (как указано в примечание для
				команды В/О)!
			</p>
		</details>

	</details>

	<hr>

	<details id="id_glossary" open="open">
		<summary><h2>Список терминов</h2></summary>
		<dl>
			<dt id="id_glos_err100">ЕГГ0Г</dt>
				<dd>
					В общем случае отображение об ошибке операции, в
					частности числа в диапазоне 1.<sup>|+100</sup>&hellip;1.<sup>|+199</sup>.
				</dd>
			<dt id="id_glos_err200">3Г0ГГ</dt>
			<dd>
				Числа в диапазоне 1.<sup>|+200</sup>&hellip;1.<sup>|+299</sup>.
			</dd>
			<dt id="id_glos_errors">Еггогология</dt>
			<dd>
				Изучение недокументированных возможностей ПМК,
				главным образом в области сверхчисел. См.
				<a href="https://ru.wikipedia.org/wiki/Еггогология" target="_blank">
					https://ru.wikipedia.org/wiki/Еггогология
				</a>
			</dd>
			<dt>Знакоцифра</dt>
			<dd id="id_glos_zero_digit">
				Цифра, которая располагается на месте знака. См.
				<a href="#id_zero_digit">
					Числа, у которых вместо знака стоит цифра.
				</a>
			</dd>
			<dt id="is_glos_unnormalize">Ненормализованные числа</dt>
			<dd>
				Числа, у которых отображаются ведущие нули.
			</dd>
			<dt id="is_glos_normalization">Нормализация</dt>
			<dd>
				Нормализация &ndash; вывод числа без ведущих нулей. Также в контексте
				преобразования числа с шестнадцатеричными цифрами означает
				преобразование в число с десятичными числами, с переносом лишней
				десятки в старший разряд.
			</dd>
			<dt id="id_glos_calculator">ПМК</dt>
			<dd>
				Программируемый микрокалькулятор.
				В контексте статьи &ndash; МК-61.
			</dd>
			<dt id="id_glos_F">Пустышка</dt>
			<dd>
				Число, у которого первая цифра представлена
				шестнадцатеричной цифрой F. Такие цифры не отображаются ПМК, т.&#8239;е.
				выглядят как пустое знакоместо.
			</dd>
			<dt>Регистр X2</dt>
			<dd>
				Или экранный регистр &ndash; см.
				<a href="#id_x2">Таинственный регистр X2</a>.
			</dd>
			<dt id="id_glos_super_num">Сверхчисло</dt>
			<dd>
				Число, порядок которого превышает документированный
				диапазон чисел для ПМК, т.&#8239;е. порядок не в диапазоне &minus;99&hellip;99,
				например 1.<sup>|+120</sup>, или 4.<sup>|&minus;180</sup>.
			</dd>
			<dt id="id_glos_shadow">Тёмные адреса</dt>
			<dd>
				Шестнадцатеричные адреса, располагаясь на которых
				в режиме ввода программы ПМК не отображает коды операций (тёмный экран).
			</dd>
		</dl>
	</details>

	<footer>
		<address class="align_right">Автор документа: Анваров С.&#8239;Р.</address>
	</footer>

</body>
</html>