<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta content="true" name="HandheldFriendly">
	<meta content="width" name="MobileOptimized">
	<meta content="yes" name="apple-mobile-web-app-capable">
	<meta name="description" content="Охота на лис 100. Игра. ПМК. МК-61">
	<title>Охота на лис 100</title>

<style>

span.but, span.but_f, span.but_k, span.but_cx, span.but_b, span.reg, span.op_f, span.op_k {
	border:thin solid black;
	border-radius:4px;
	display:inline-block;
	font-size:1.1em;
	font-weight:bold;
	font-family:monospace;
	text-align:center;
	min-width:2.3em;
	white-space:nowrap;
}

sup {
	line-height:0;
}

span.but {
	background-color:#CCCCCC;
	color:black;
}

span.but_f {
	background-color:#F5E345;
	color:black;
}

span.but_k {
	background-color:LightSkyBlue;
	color:white;
}

span.but_cx {
	background-color:#F00505;
	color:white;
}

span.but_b {
	background-color:black;
	color:white;
}

span.reg {
	background-color:black;
	color:white;
}

span.op_f {
	background-color:black;
	color:yellow;
}

span.op_k {
	background-color:black;
	color:#00BFFF;
}

.code {
	background-color:#103810;
	color:#77FF77;
	font-size:1.1em;
	font-family:monospace;
	font-weight:bold;
	padding:1px 2px 1px 2px;
	white-space:pre;
}

table {
	border-collapse:collapse;
}

table, th, td {
	border:1px solid black;
}

.zero {
	background-color: lightgray;
}

.selected {
	background-color: lightblue;
}

.center {
	text-align:center;
}

details summary {
	cursor: pointer;
}
details summary > * {
	display: inline;
}

a[target="_blank"] {
	background: url(https://upload.wikimedia.org/wikipedia/commons/6/64/Icon_External_Link.png) center right no-repeat;
    padding-right: 0.8em;
}

</style>

</head>

<body>
	<header>
		<h1>Охота на лис 100</h1>
	</header>
	<p>
		Игра <a href="https://ru.wikipedia.org/wiki/Охота_на_лис_(логическая_игра)" target="_blank">Охота на лис (логическая игра)</a>.
	</p>

	<h2>Задача</h2>

	<p>
		Найти всех лис.
	</p>

	<h2>Общее описание</h2>

	<p>
		На поле 10 на 10 случайным образом расположены лисы, количество которых (Count) задаётся в начале игры.
		Count это число от 1 до 100. Все в разных клетках!
		Вы задаёте своё положение, указав координаты клетки (координаты охотника). В ответ
		<a href="https://ru.wikipedia.org/wiki/Программируемый_калькулятор" target="_blank">ПМК</a>
		выдаёт количество лис, пеленгуемых из указанной клетки.
		Это число указывает, сколько лис расположено в одной вертикали, горизонтали и диагоналях
		с указанной клеткой.
	</p>
	<p>
		Если координаты клетки совпадают с положением одной из лис, то она считается найденной,
		и исключается из дальнейшей пеленгации. В этом случае ПМК отображает общее количество
		оставшихся лис со знаком минус, чтобы не путать с обычным ответом.
		В регистре Y можно посмотреть исходные координаты.
	</p>

	<h2>Игровой процесс</h2>

	<h3>Начало</h3>

	<p>
		Убедитесь, что переключатель Р-ГРД-Г расположен в положении ГРД (посередине).
		Для корректной работы программы это важно!
	</p>
	<p>
		Перед запуском укажите случайное число от 0 до 1. Оно будет использовано
		для генерации положений лис, затем <span class="but">В&uparrow;</span>,
		количество лис, <span class="but_b">В/О</span>, <span class="but_b">С/П</span>.
	</p>
	<p>
		ПМК расставит лис случайным образом и по окончании выдаст &minus;Count, как бы сообщая,
		что осталось Count лис. Если количество лис большое, то это может занять время,
		потому что ПМК не ставит две лисы в одно поле, а датчик случайных чисел может
		выдавать одинаковые первые цифры, что заставляет ПМК пробовать другое число и т.д.
	</p>

	<h3>Игра</h3>

	<p>
		Вы задаёте координаты клетки, из которой хотите провести пеленгацию, числом
		в виде пары цифр, разделённых десятичной точкой.
		Обычно целая часть – вертикальная координата,
		а дробная – горизонтальная. Впрочем, можете считать наоборот,
		для игры это не важно – поле-то квадратное!
		После <span class="but_b">С/П</span> ПМК выдаст результат на экран.
		Вот возможные результаты:
	</p>
	<ul>
		<li>
			Число отрицательное, ответ был выдан мгновенно. Это значит, что вы указали
			недопустимые координаты. Число должно быть в диапазоне [0&hellip;10). Введенные
			координаты можно посмотреть в регистре Y. Абсолютное значение регистра X
			показывает количество оставшихся лис.
			Неверные координаты можно специально использовать для получения такой информации.
			Случай неверных координат в подсчёт ходов не входит.
		</li>
		<li>
			Число отрицательное, ответ был выдан с задержкой. Это значит, что координаты
			совпали с координатами одной из лис. Введенные
			координаты можно посмотреть в регистре Y. Абсолютное значение регистра X
			показывает количество оставшихся лис, за минусом найденной.
		</li>
		<li>
			Число &ge; 0.
			Количество лис, запеленгованных из заданной координаты. Сами координаты (ход)
			находятся в регистре Y. Для вас, конечно, идеальный ответ это ноль.
			В этом случае сразу столько клеток поля исключаются из рассмотрения.
		</li>
	</ul>

	<h3>Окончание</h3>

	<p>
		Если вы нашли всех лис, то на экран будет выдано
		<span class="code"> -99999975.   </span>, как признак окончания игры.
		В регистре Y указано количество ходов, которые вы сделали за игру.
		Соревновательный момент состоит в том, чтобы как можно быстрее обнаружить
		всех лис. Т.&#8239;е. за меньшее число ходов. При одинаковом входном значении
		случайного числа лисы <q>рассаживаются</q> одинаково.
	</p>
	<p>
		Для начала новой игры повторите действия, указанные в разделе <q>Начало</q>.
	</p>

	<h2>Дополнительная информация</h2>

	<h3>Контроль со стороны ПМК</h3>

	<ul>
		<li>
			Если число лис в начале игры содержит дробную часть, то она отбрасывается.
		</li>
		<li>
			Если количество лис меньше единицы, то ПМК выдаст
			<span class="code"> ЕГГ0Г      </span>. В этом случае
			нужно начать заново, указав корректное значение.
		</li>
		<li>
			Если закончив одну игру вы начинаете следующую, забыв указать
			<span class="but_b">В/О</span>, то тоже выдаст
			<span class="code"> ЕГГ0Г      </span>.
		</li>
		<li>
			В течении игры проверяется, что введённые координаты охотника
			находятся в диапазоне [0&hellip;10).
		</li>
	</ul>

	<p>
		Число 100 в названии отражает максимальное количество лис, которые можно разместить.
		Если вы укажите больше, то просто не дождётесь расстановки, потому что невозможно
		разместить более 100 лис на поле 10 x 10.
		Число 100 указать можно, ПМК заполнит всё поле, хотя не зная этого будет стараться
		сделать это <q>случайным</q> образом, поэтому долго. Но играть будет уже не так интересно.
	</p>
	<p>
		Над каждым ходом ПМК <q>долго думает</q>, поэтому если используете эмулятор с ускорением – ускорьте.
		Для примера, ход в обычном режиме занимает чуть меньше двух минут, если конечно не найдена лиса,
		в этом случае быстрее. Со включенным ускорением – 8 секунд.
	</p>

	<hr>

	<details>
		<summary>
			<h2>Далее только для тех, кто не только играет&hellip;</h2>
		</summary>

		<p>
			Программа делится на две части. Первая – расстановка лис на основе
			случайного числа, ведённого игроком. Вторая – цикл поиска лис.
		</p>

		<h3>Распределение регистров</h3>
		<table>
			<tr>
				<th>R0, R1, Rb, Re</th>
				<td>Битовые поля для хранения положения лис. Инициализируются нулём.</td>
			</tr>
			<tr>
				<th>R2</th>
				<td>
					Переменная цикла. В первой части, чтобы расставить всех лис,
					во второй - чтобы проверить все координаты поля.
					Инициализируется значением, указанным в начале игры.
				</td>
			</tr>
			<tr>
				<th>R3</th>
				<td>
					Хранит число оставшихся лис.
					Инициализируется значением, указанным в начале игры.
				</td>
			</tr>
			<tr>
				<th>R4</th>
				<td>Введённые координаты охотника.</td>
			</tr>
			<tr>
				<th>R5</th>
				<td>
					Результат хода (ответ ПМК). Либо количество запеленгованных лис,
					либо дубль R3 с отрицательным значением.
				</td>
			</tr>
			<tr>
				<th>R6</th>
				<td>
					Количество ходов за игру.
					Инициализируется нулём.
				</td>
			</tr>
			<tr>
				<th>R7</th>
				<td>Номер регистра для битового поля (0,1,11,14).</td>
			</tr>
			<tr>
				<th>R8</th>
				<td>70. Адрес кода, где происходит приращение счётчика обнаруженных лис.</td>
			</tr>
			<tr>
				<th>R9</th>
				<td>
					Константа -75.
					Хвостик (75) – это адрес процедуры проверки лисы по заданным в RX координатам.
					После первого использования в регистре уже будет
					<span class="code"> -99999975.   </span>, как признак окончания игры.
				</td>
			</tr>
			<tr>
				<th>Ra</th>
				<td>10. Константа, используемая для вычислений.</td>
			</tr>
			<tr>
				<th>Rc</th>
				<td>43. Адрес начала цикла по проверке всех координат.</td>
			</tr>
			<tr>
				<th>Rd</th>
				<td>
					Число <span class="code"> 8.3048126^-01</span>.
					Используется для вычисления 2<sup>x</sup>. А хвостик – это адрес
					начала общего цикла программы.
				</td>
			</tr>
		</table>

		<h3>Текст программы</h3>

		<table class="center">
			<tr>
				<th>&#8202;#&#8202;|&#8202;</th>
				<th>00</th>
				<th>01</th>
				<th>02</th>
				<th>03</th>
				<th>04</th>
				<th>05</th>
				<th>06</th>
				<th>07</th>
				<th>08</th>
				<th>09</th>
			</tr>
			<tr>
				<th>&#8202;00&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">2</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">3</span></td>
				<td><span class="but_f">F</span><span class="op_f">Lg</span></td>
				<td><span class="but_cx">Cx</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">6</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">0</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">1</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">b</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">e</span></td>
			</tr>
			<tr>
				<th>&#8202;10&#8202;|&#8202;</th>
				<td><span class="but">&lt;-&gt;</span></td>
				<td><span class="but">7</span></td>
				<td><span class="but">&times;</span></td>
				<td><span class="but_f">F</span><span class="op_f">&pi;</span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but">В&uarr;</span></td>
				<td><span class="but">ВП</span></td>
				<td><span class="but">2</span></td>
				<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
			</tr>
			<tr>
				<th>&#8202;20&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="but_b">ПП</span><span class="but">9</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="reg">a</span></td>
				<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
				<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">7</span></td>
				<td><span class="but">&minus;</span></td>
				<td><span class="but_f">F</span><span class="op_f">L2</span></td>
				<td><span class="but">10</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">3</span></td>
				<td><span class="but">/-/</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">5</span></td>
			</tr>
			<tr>
				<th>&#8202;30&#8202;|&#8202;</th>
				<td><span class="but_b">П&rarr;x</span><span class="but">4</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
				<td><span class="but_b">С/П</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">4</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="reg">d</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				<td><span class="but">&minus;</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&lt;0</span><span class="reg">d</span></td>
				<td><span class="but">0</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">5</span></td>
			</tr>
			<tr>
				<th>&#8202;40&#8202;|&#8202;</th>
				<td><span class="but_f">F</span><span class="op_f">cos<sup>-1</sup></span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">2</span></td>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">6</span></td>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">2</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">2</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
				<td><span class="but">30</span></td>
				<td><span class="but_k">К</span><span class="but_b">ПП</span><span class="but">9</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ge;0</span><span class="reg">c</span></td>
				<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
			</tr>
			<tr>
				<th>&#8202;50&#8202;|&#8202;</th>
				<td><span class="but_b">П&rarr;x</span><span class="but">4</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">2</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="reg">a</span></td>
				<td><span class="but">&divide;</span></td>
				<td><span class="but">&minus;</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ne;0</span></td>
				<td><span class="but">98</span></td>
				<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">4</span></td>
			</tr>
			<tr>
				<th>&#8202;60&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
				<td><span class="but">&minus;</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">8</span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_k">К</span><span class="op_f">x&ne;0</span><span class="but">8</span></td>
				<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
				<td><span class="but">&divide;</span></td>
				<td><span class="but_f">F</span><span class="op_f">x<sup>2</sup></span></td>
				<td><span class="but_f">F</span><span class="op_f">cos</span></td>
				<td><span class="but_k">К</span><span class="op_f">x=0</span><span class="reg">c</span></td>
			</tr>
			<tr>
				<th>&#8202;70&#8202;|&#8202;</th>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">5</span></td>
				<td><span class="but_k">К</span><span class="but_b">БП</span><span class="reg">c</span></td>
				<td><span class="but">&divide;</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="but">7</span></td>
				<td><span class="but_f">F</span><span class="op_f">&orarr;</span></td>
				<td><span class="but">4</span></td>
				<td><span class="but">&divide;</span></td>
				<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
				<td><span class="but_f">F</span><span class="op_f">Вx</span></td>
				<td><span class="but_k">К</span><span class="op_k">{x}</span></td>
			</tr>
			<tr>
				<th>&#8202;80&#8202;|&#8202;</th>
				<td><span class="but_b">П&rarr;x</span><span class="reg">d</span></td>
				<td><span class="but">/-/</span></td>
				<td><span class="but_b">x&rarr;П</span><span class="reg">d</span></td>
				<td><span class="but_f">F</span><span class="op_f">x&ge;0</span></td>
				<td><span class="but">72</span></td>
				<td><span class="but">&divide;</span></td>
				<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
				<td><span class="but_k">К</span><span class="op_k">[x]</span></td>
				<td><span class="but">&lt;-&gt;</span></td>
				<td><span class="but">1</span></td>
			</tr>
			<tr>
				<th>&#8202;90&#8202;|&#8202;</th>
				<td><span class="but">+</span></td>
				<td><span class="but_f">F</span><span class="op_f">10<sup>x</sup></span></td>
				<td><span class="but">+</span></td>
				<td><span class="but_k">К</span><span class="but_b">П&rarr;x</span><span class="but">7</span></td>
				<td><span class="but">&lt;-&gt;</span></td>
				<td><span class="but_k">К</span><span class="op_k">&oplus;</span></td>
				<td><span class="but">&minus;</span></td>
				<td><span class="but_b">В/О</span></td>
				<td><span class="but">&lt;-&gt;</span></td>
				<td><span class="but_k">К</span><span class="but_b">x&rarr;П</span><span class="but">7</span></td>
			</tr>
			<tr>
				<th>&#8202;A0&#8202;|&#8202;</th>
				<td><span class="but_f">F</span><span class="op_f">L3</span></td>
				<td><span class="but">27</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">6</span></td>
				<td><span class="but_b">П&rarr;x</span><span class="but">9</span></td>
				<td><span class="but_b">С/П</span></td>
				<td colspan="5"></td>
			</tr>
		</table>

		<h3>Объяснение работы программы</h3>

		<h4>Алгоритм работы на словах</h4>

		<p>
			Для начала общая идея. Как ПМК хранит до 100 разных координат при 15 регистрах?
			Ответ: координаты лис хранятся в виде битов. ПМК умеет
			обрабатывать шестнадцатеричные значения в 7 разрядах числа. Каждая
			шестнадцатеричная цифра это 4 бита. Итого в одном числе (регистре) можно сохранить
			7 &times; 4 = 28 бит.
			Четырёх регистров хватит на 4 &times; 28 = 112 бит. Для нас более чем достаточно.
			Т.&#8239;е. всё поле представлено битами в диапазоне 0&hellip;99.
		</p>

		<p>
			Поэтому общая структура программы не сложная.
		</p>
		<ol>
			<li>
				Расстановка лис. Кроме начального зануления нужных регистров цикл инициализация
				можно описать следующим образом.
				Сгенерировать случайное число в диапазоне 0&hellip;99. Проверить, что
				такой бит ещё не установлен. Если уже есть, то на начало цикла без изменения
				счётчика лис, если нет, то установить бит и уменьшить счётчик лис.
				Если ещё остались, то на начало цикла, а иначе завершение инициализации.
			</li>
			<li>
				Основной цикл поиска лис. Ввести координаты охотника с проверкой. Увеличить счётчик
				ходов, обнулить счётчик найденных лис.
				В цикле от 0 до 99 проверить, что в заданной индексом координате есть лиса. Если нет, то
				на начало цикла. Если есть, то сначала сравнение с координатой охотника. При
				совпадении прерывание цикла с уменьшением количества лис. Если уже не осталось, то
				завершение работы. Если ещё есть, то на начало цикла.
				Если есть лиса, но не совпадает с координатой охотника, то провести вычисления
				<q>видимости</q> данной лисы с места охотника. При успехе увеличить счётчик
				найденных лис. На начало цикла. По окончании цикла вывести результат и ожидать
				ввода игрока.
			</li>
		</ol>

		<p>
			Теперь детали.
		</p>

		<h4>Процедура проверки, только интерфейс</h4>

		<p>
			Самая сложная и часто используемая часть – это процедуры проверки установленного бита.
			Адрес её в регистре R9. Опишем её контракт.
		</p>
		<p>
			На входе в регистре X целое число в диапазоне 0&hellip;99.
			На выходе сразу несколько значений:
		</p>
		<ol>
			<li>
				Знак регистра X отражает факт наличия бита (ранее установленной лисы).
				Меньше нуля – нет. Больше нуля – есть.
				Само значение роли не имеет.
			</li>
			<li>
				Регистр R7 содержит номер регистра, в котором <q>живёт</q> данный бит. Ссылка на один из
				регистров R0, R1, Rb, Re.
			</li>
			<li>
				Регистр X1 – новый битовый план регистра, на который ссылается R7, чтобы изменить
				значение бита: если он был, то удалит, если не было, то поставит.
			</li>
		</ol>
		<p>
			Ещё у этой процедуры есть удобное свойство. Если на входе в регистре Y что-то было, то на
			выходе это что-то там же и останется.
		</p>
		<p>
			Процедура достаточно сложная, поэтому её рассмотрение перенесём на конец, сейчас же просто
			задекларировали, как её нужно использовать.
		</p>

		<h4>Расстановка лис</h4>

		<p>
			Пойдём по порядку, с адреса 00. Напомним ввод игрока: RX – количество лис,
			RY - случайное число.
			По адресам 00&hellip;03 целая часть числа лис сохраняется, и проверяется, что больше нуля.
			Затем по адресу 04&hellip;09 обнуляются счётчик ходов и битовые поля. С адреса 10 уже идёт
			сам цикл расстановки.
		</p>
		<p>
			Цикл расстановки использует генератор случайных чисел, который работает по
			формуле N<sub>i+1</sub> = {N<sub>i</sub> &times; 7 + &pi;}.
		</p>
		<p>
			Адрес 10. Напомню, что случайное число сейчас в RY. Поэтому его <q>подтягиваем</q> из RY
			и передаём на вход генератору случайных чисел.
			Кстати, оно так и хранится в дальнейшем в регистре Y.
			Сохраняет его новое значение там команда по адресу 06, заодно обеспечивая
			валидность последующего возведения во вторую степень.
		</p>
		<p>
			Адрес 20. Вызов процедуры проверки. Последнее случайное число всё еще в регистре Y.
			После проверки, если уже была лиса по таким координатам (&gt;0), то возврат на
			адрес 10 (Ra=10). Если нет, то извлечение
			из X1 нового битового плана и сохранение его в нужном месте через R7. Затем
			по адресу 24 используется арифметическая операция, чтобы <q>подтащить</q> уехавшее в стек
			случайное число обратно в регистр Y. И стандартное завершение цикла по R2 (количеству лис).
			С адреса 27 уже начинается основной цикл поиска лис.
		</p>

		<h4>Основной цикл поиска лис</h4>

		<h5>Вывод, ввод, проверка, подготовка</h5>

		<p>
			Начало (до С/П) простое – копирование в R5 счётчика оставшихся лис, только со знаком минус.
			Потом вывод R4 и R5. Дело в том, что при нормальном ходе в R5 будет число найденных лис,
			но тогда вывод начинается с адреса 30. А при ошибках или после расстановки – с адреса 27.
			Конечно R4 у нас не инициализировано, но по условиям после расстановки про регистр
			RY ничего и не сказано, а в дальнейшем там будут координаты охотника (ввод игрока).
		</p>
		<p>
			Адрес этого начала, для быстрого возврата, хранится в Rd, хотя это и не очевидно.
			Дело в том, что числа порядка &minus;01 не меняются при косвенной адресации, и последние
			две цифры (7,8 разряды) Rd содержат адрес перехода. Тут он вообще-то равен 26, а не 27,
			как положено. Но в данном случае это не критично для выполнения, т.&#8239;к. по адресу 26
			идёт 10 – это код команды сложения, которая ничего не портит. А 27 в конце не походит
			для процедуры проверки. Ага, заинтриговал, как же сделана эта процедура, что для
			неё критично значение в восьмом разряде после запятой. Но это в конце, потерпите.
		</p>
		<p>
			Адреса 33&hellip;37. Сохранение координат в R4 и проверка, что больше или равно нулю и меньше 10.
			Тут всё просто.
		</p>
		<p>
			Адреса 38&hellip;39. Зануление счётчика найденных лис.
		</p>
		<p>
			Адреса 40&hellip;41. Подготовка цикла с нуля до 99. В регистр R2 заносится число 100.
			Вот тут нам и пригодилось, что Р-ГРД-Г в положении ГРД, при котором arccos(0) = 100.
		</p>

		<h5>Цикл по всему полю от 0 до 99</h5>

		<p>
			Начинается с адреса 43 (он же в Rc). Дело в том, что обычные циклы в ПМК идут от
			1 до 100, и на это рассчитаны команды FLx. Но нам нужно от 0 до 99. Поэтому мы не
			пользуемся FLx, а самостоятельно уменьшаем счётчик цикла, причём сразу.
			Фактически получается цикл от 99 до 0. Если при уменьшении индекс стал отрицательным,
			то стоп циклу. Именно это выполняется по адресам 43&hellip;46.
		</p>
		<p>
			Адреса 47&hellip;48. Вызов процедуры проверки. Если лисы нет в этой ячейке, то на начало цикла.
		</p>
		<p>
			Адрес 49. Сохранение в стеке значение X1, которое содержит новый битовый план,
			чтобы при случае удалить лису. Случай, кстати, настанет только по адресу 99.
		</p>
		<p>
			Адреса 50&hellip;56. Проверка на совпадение координат лисы и охотника.
			При удаче переход на адрес 98. Перед вычитанием координаты поля в битовом представлении
			0&hellip;99 переводится в координаты игры 0,0&hellip;9,9 путём деления на 10.
		</p>
		<p>
			Для объяснения дальнейших проверок удобнее ввести формулы.
			Обозначим координаты лисы как F.f (число), а координаты охотника (в R4) как H.h.
			Если перейти к дробям, то (F + f/10) и (H + h/10) соответственно.
			Тогда разность (которая сейчас в RX) будет (H + h/10) &minus; (F + f/10).
		</p>
		<p>
			Адреса 57&hellip;62. Находим разность дробных частей, которая получится (f/10 &minus; h/10).
			Если нулевая, что означает, что лиса на одной горизонтали с охотником, то переходим
			на адрес 70 (R8=70), где увеличивается счётчик обнаруженных лис.
		</p>
		<p>
			Адреса 63&hellip;64. Проверяем совпадение по вертикали. Для этого мы просто
			складываем ((H + h/10) &minus; (F + f/10)) + (f/10 &minus; h/10).
			В результате получим (H &minus; F). Если успех (ноль), то снова на адрес 70.
		</p>
		<p>
			Адреса 65&hellip;69. Проверяем совпадение по диагонали. Для этого делим (H &minus; F) на
			(f/10 &minus; h/10) из X1. Делитель точно не ноль, это уже проверили.
			Если клетки расположены на одной диагонали, то разница между вертикальными и
			горизонтальными координатами должна совпадать. С учётом того, что целая часть в 10 раз
			больше дробной, разница совпадает, если результат деления равен ровно 10 (или &minus;10).
			Или квадрат числа равен 100. Это и делается, т.&#8239;к. при положении ГРД (снова пригодился)
			cos(100) = 0.
			Если и тут нет (не ноль), то эта лиса не видна и просто переход на начало цикла (Rc=43).
		</p>
		<p>
			Адреса 70&hellip;71. Увеличение счётчика обнаруженных лис и безусловный переход на
			начало цикла.
		</p>

		<h5>Завершение программы</h5>

		<p>
			Адреса 98&hellip;A4. Сюда попадаем, если координаты охотника совпали с координатой лисы.
			Если вспомнить, то по адресу 49 мы сохранили в стеке битовую карту без этой лисы.
			Сейчас она находится в RY. Поэтому мы её берём и сохраняем через R7. Затем
			проверяем, что ещё остались лисы через <span class="but_f">F</span><span class="op_f">L3</span>.
			Если есть, то на начало цикла поиска, если уже всё, то вывод счётчика ходов, вывод специального
			значения для завершения и остановка.
			Игра закончена.
			Кстати, программа к концу <q>забывает</q> сколько исходно было лис. Первое значение в R2
			<q>тратится</q> при расстановке. Второе в R3 уже здесь. Впрочем, и случайное число тоже
			теряется во время работы.
		</p>
		<p>
			Следует пояснить, почему если не нажать <span class="but_b">В/О</span>, то
			произойдёт <span class="code"> ЕГГ0Г      </span>. Дело в том, что у ПМК
			две ветви исполнения после адреса A4. Одна короткая пойдёт на A5, который
			равен 00, затем дойдёт до адреса B1, который равен 06, но потом уйдёт на длинную
			ветвь и снова вернётся на 00 (B2), но теперь уже с RX=0, который был установлен
			при первом проходе. А <span class="but_f">F</span><span class="op_f">Lg</span>
			по адресу 03 и вызовет ошибку.
		</p>

		<h4>Процедура проверки, реализация</h4>

		<p>
			Ну вот и добрались до вкусного. В общих словах то, как процедура выполняет проверку,
			можно разбить на четыре части.
		</p>
		<ol>
			<li>
				Сначала исходное число делится на 4. Остаток, а точнее дробные числа 0, 0.25, 0.5, 0.75
				преобразуются в номер регистра для хранения битового плана.
			</li>
			<li>
				Целая часть от деления 0&hellip;24 снова делится на 4. Но тут остаток или, если быть
				точным, снова дробная часть преобразуется в бит. И получаются числа 1, 2, 4, 8.
			</li>
			<li>
				Новая целая часть 0&hellip;6 используется как порядок для <q>отодвигания</q> бита в нужный
				разряд и складывается с этим битом.
				Просто 10<sup>1&hellip;7</sup> + бит будет то, что на нужно.
			</li>
			<li>
				Полученное число для бита, например число 100004, через
				<span class="but_k">К</span><span class="op_k">&oplus;</span> совмещается с
				исходным битовым планом. А затем из исходного битового плана вычитается
				полученное значение.
				Если бита не было, и он появился, то разность будет отрицательной и наоборот.
			</li>
		</ol>

		<h5>Часть 1</h5>
		<p>
			Как из дробной части деления на 4 получить ссылки на регистры
			R0, R1, Rb, Re? Тут пригодилось деление этого остатка на число Rd = 0.83048126.
			Лучше вывести результат в виде таблицы:
		</p>
		<table>
			<tr>
				<th>X</th>
				<th>X &div; Rd</th>
				<th>Хвостик</th>
				<th>Регистр</th>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
				<td>00</td>
				<td>R0</td>
			</tr>
			<tr>
				<td>0.25</td>
				<td>0.30103027</td>
				<td>27</td>
				<td>R1</td>
			</tr>
			<tr>
				<td>0.5</td>
				<td>0.60206054</td>
				<td>54</td>
				<td>Re</td>
			</tr>
			<tr>
				<td>0.75</td>
				<td>0.90309081</td>
				<td>81</td>
				<td>Rb</td>
			</tr>
		</table>

		<p>
			Детально, почему это можно использовать для косвенной адресации и как получились такие номера
			регистров можно узнать здесь:
			<a href="https://sergeanvarov.github.io/russian/mk61/uf/indirect_addr.html" target="_blank">
				Недокументированные возможности</a
			>.
		</p>
		<p>
			Тут можно раскрыть, почему нам не подходит Rd = 0.8304812<strong><u>7</u></strong>. Дело в том,
			что в этом случае получаются другие числа и другие регистры. А для нормальной работы
			программы нужно, чтобы было свободно два регистра из серии автоуменьшения (R0&hellip;R3),
			два из серии автоувеличения (R4&hellip;R6), и не более двух из остальных, т.&#8239;к.
			они нужны для косвенной адресации (уменьшения длины программы). А в данном случае
			вообще 0.25 &div; Rd = 0.30103026. Что соответствует R0, а он же получается и для нуля.
		</p>

		<h5>Часть 2</h5>

		<p>
		    Тут мы остаток преобразуем по-другому. В общем, мы хотим
			получить N = 2<sup>(X mod 4)</sup>. Для этого используется константа приблизительно
			равная 4 &times; Lg2.
			Тогда 10<sup>{X/4}&times;4&times;Lg2</sup> и будет нужным значением. Функция 10<sup>x</sup>
			неточная, поэтому константа подобрана так, чтобы полученное число было немногим больше,
			чтобы целая часть была точно 1, 2, 4 или 8.
		</p>
		<p>
			А значение Rd = 0.83048126 и есть эта константа, только в виде обратной величины:
			1 / (4 &times; Lg2). Чтобы её можно было использовать и для косвенной адресации.
		</p>

		<h5>Детальный код всей процедуры</h5>

		<p>
			Теперь смотрим код. С адреса 75 по 79. Всё как положено по части 1: делим на 4, целую
			часть от деления задвигаем пока в стек, начинаем что-то делать с дробной частью.
			Но далее идёт некий трюк, который я сейчас опишу.
		</p>
		<p>
			Дело в том, что нам нужно дважды провернуть почти одно и тоже, связанное
			с делением, остатком и т.п. Но регистров циклов уже свободных нет.
			Тогда делаем так: некую константу, которая нам нужна, мы после извлечения
			пересохраняем, но со знаком минус. И проверяем, что она положительная.
			Если это не так, а первый раз точно не так, повторяем код, но при втором проводе
			она уже будет положительной.
		</p>
		<p>
			Что и делается по адресам 80&hellip;84. И переход идёт не на вход процедуре, а
			немного раньше – на адрес 72, где выполняется деление и сохранения полученного
			значение в R7, чтобы по нему ссылаться на битовый план. Обратите внимание, что
			тут в R7 число будет отрицательным, а не так, как в таблице выше, но для
			косвенной адресации это не важно.
		</p>
		<p>
			И после того, как мы уберём из стека по адресу 74 ненужное уже значение, мы
			перейдём на часть 2.
			Убрать из стека нужно только так, а не через <span class="but">&lt;-&gt;</span>,
			потому что процедура должна сохранить то, что было на входе в регистре Y.
		</p>
		<p>
			И вот при повторном проходе условие по адресу 83 уже выполняется. Поэтому
			мы выходи из <q>замкнутого круга</q> и выполняем то, что нужно в части 2
			по адресам 85&hellip;87.
		</p>
		<p>
			После чего, поменяв местами X и Y, выполняем часть 3 по адресам 89&hellip;92.
		</p>
		<p>
			В оставшихся адресах 93&hellip;96 выполняем часть 4.
		</p>

		<p>
			Тут следует заметить, что такой необычный цикл можно было бы избежать,
			просто оформив повторяющуюся часть кода в виде отдельной процедуры.
			В этом случае вместо странных значений в R7 можно было бы, как в части 2,
			сделать обычные 1, 2, 4, 8. И общая длина программы осталось бы такой же.
			Так почему так не сделано? Потому что изначально так и было, но ради
			скорости выполнения переделано по-другому. Благодаря отказу от
			<span class="but_b">ПП</span> и одному
			<span class="but_f">F</span><span class="op_f">10<sup>x</sup></span>
			скорость программы возросла на 20%(!). Потому что процедура проверки
			вызывается 100 раз, и даже небольшая оптимизация в ней приводит к таким
			результатам.
		</p>

	</details>
</body>

</html>